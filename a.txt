/* @(#) rn-newp2.p 1.767 03/06/23 @(#) */
  /* block ? in orig-value and rate fields for paid off: mar 221 2018*/
/*------------------------------------------------------------------------------
  File:  rn-newp2.p

  Syntax:
    run rn-newp2.p(gwkreg).
  Input Parameters:
    gwkreg - register number
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
    History:   added rto print change task 3789
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i


------------------------------------------------------------------------------*/
DEFINE VARIABLE oScreen AS fn.Screen NO-UNDO.

oScreen = NEW fn.Screen(). 

FUNCTION get-frame-handle RETURN HANDLE (tFrameName AS CHAR):
  RETURN oScreen:GetFrameHandle(tFrameName). 
END FUNCTION.

FUNCTION hide-frame RETURN LOG (tFrameName AS CHAR):
  RETURN oScreen:HideFrame(tFrameName).
END FUNCTION.

FUNCTION get-widget-screen-row RETURNS INT (INPUT pHandle AS HANDLE):
  RETURN oScreen:GetWidgetScreenRow(pHandle).
END FUNCTION.

FUNCTION get-widget-screen-col RETURNS INT (INPUT pHandle AS HANDLE):
  RETURN oScreen:GetWidgetScreenCol(pHandle).
END FUNCTION.


FUNCTION center-frame RETURNS LOG(INPUT pHandle AS HANDLE):
  RETURN oScreen:CenterFrame(pHandle).
END FUNCTION.


FUNCTION frame-first-sensitive RETURNS HANDLE (INPUT pHandle AS HANDLE):
  RETURN oScreen:FrameFirstSenstive(pHandle).
END FUNCTION.

FUNCTION frame-next-sensitive RETURNS HANDLE (INPUT pWidget AS HANDLE):
  RETURN oScreen:FrameNextSensitive(pWidget).
END FUNCTION.


FUNCTION frame-last-sensitive RETURNS HANDLE (INPUT pHandle AS HANDLE):
  RETURN oScreen:FrameLastSensitive(pHandle).
END FUNCTION.

FUNCTION save-frames RETURNS CHAR():
  RETURN oScreen:SaveFrames().
END FUNCTION.

FUNCTION save-frames-and-focus RETURNS CHAR(OUTPUT pFocus AS HANDLE):
  RETURN oScreen:SaveFramesAndFocus(pFocus).
END FUNCTION.

FUNCTION restore-frames RETURNS LOG(pHandles AS CHAR):
  oScreen:RestoreFrames(pHandles).
  RETURN YES. 
END FUNCTION.

FUNCTION restore-frames-and-focus RETURNS LOG
  (pHandles AS CHAR,pFocus AS HANDLE):
  oScreen:RestoreFramesAndFocus(pHandles,pFocus).
  RETURN YES. 
END FUNCTION.

FUNCTION reverse-video RETURNS LOG(pFieldHandle AS WIDGET-HANDLE):
  oScreen:ReverseVideo(pFieldHandle).
  RETURN YES.
END FUNCTION.

FUNCTION rv-underline RETURNS LOG(pFieldHandle AS WIDGET-HANDLE):
  oScreen:ReverseVideoUnderline(pFieldHandle).
  RETURN YES.
END FUNCTION.

FUNCTION flashing RETURNS LOG(p-field-handle AS WIDGET-HANDLE):
  /* sets the field color attribute to flashing */
  p-field-handle:DCOLOR = 5.
  RETURN YES.
END FUNCTION.


/*------------------------------------------------------------------------------
  File:
    im/locsrl-val.i
    
  Description:
    It runs the pricing program as persistent and does all the pricing

    destroy-locsrl-val() - call this when exiting your program to destroy 
                           the instants of im/locsrl-val1.p 

    get-orig-retail      - returns the original retail of a serial# 
                          PARAMETERS REQUIRED:
                          INPUT p-sku AS INTEGER
                          INPUT p-serial-no AS CHARACTER,
  
    get-current-retail   - returns the currenct depreciaited retail 
                           PARAMETERS REQUIRED:
                           INPUT p-sku AS INTEGER
                           INPUT p-serial-no AS CHARACTER,
    
    get-retail-at        - returns the depreciated retail at a specific date 
                           PARAMETERS REQUIRED:
                           INPUT p-sku AS INTEGER
                           INPUT p-serial-no AS CHARACTER,
                           INPUT p-date AS DATE
    get-orig-cost        - returns the original cost of a serial# 
                           PARAMETERS REQUIRED:
                           INPUT p-sku AS INTEGER
                           INPUT p-serial-no AS CHARACTER,
  
    get-current-cost     - returns the currenct depreciated cost
                           PARAMETERS REQUIRED:
                           INPUT p-sku AS INTEGER
                           INPUT p-serial-no AS CHARACTER,
    
    get-cost-at          - returns the depreciated cost at a specific date 
                           PARAMETERS REQUIRED:
                           INPUT p-sku AS INTEGER
                           INPUT p-serial-no AS CHARACTER,
                           INPUT p-date AS DATE
           
  
  Syntax:
    {im/locsrl-val.i} 
     
  Input Parameters:
    <none>

  Output Parameters:
    <none>

  Input-Output Parameters:
    <none>
                
  History:
------------------------------------------------------------------------------*/

DEF VAR ph-locsrl-val AS HANDLE NO-UNDO.
RUN im/locsrl-val1.p PERSISTENT SET ph-locsrl-val.
THIS-PROCEDURE:ADD-SUPER-PROCEDURE (ph-locsrl-val).
ph-locsrl-val:PRIVATE-DATA = THIS-PROCEDURE:FILE-NAME + ",":U 
                           + STRING(THIS-PROCEDURE:HANDLE).
/*
 * Prototype include file: H:\8236\im\locsprto.i
 * Created from procedure: H:\8236\im\locsrl-val1.p at 09:44 on 06/23/03
 * by the PROGRESS PRO*Tools Prototype Include File Generator
 */

FUNCTION clear-pricing RETURNS LOGICAL IN SUPER.

FUNCTION destroy-pricing RETURNS LOGICAL IN SUPER.

FUNCTION get-bc-loc RETURNS CHARACTER IN SUPER.

FUNCTION get-cust-disc RETURNS DECIMAL IN SUPER.

FUNCTION get-date-last-price RETURNS DATE IN SUPER.

FUNCTION get-dual-price RETURNS LOGICAL
  (INPUT p-currency AS CHARACTER,
   INPUT p-group AS INTEGER) IN SUPER.

FUNCTION get-new-bc-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL) IN SUPER.

FUNCTION get-new-cust-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-custno AS CHARACTER,
   INPUT p-arsale AS LOGICAL) IN SUPER.

FUNCTION get-new-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL) IN SUPER.

FUNCTION get-price-type RETURNS CHARACTER IN SUPER.

FUNCTION destroy-locsrl-val RETURNS LOGICAL IN SUPER.

FUNCTION get-cost-at RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION get-current-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-current-retail RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-orig-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-orig-retail RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-retail-at RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION set-locsrl RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER,
   INPUT p-retail AS LOGICAL) IN SUPER.

FUNCTION GetQtyUsed RETURNS INTEGER 
  (INPUT pLoc AS CHARACTER,
   INPUT pSku AS INTEGER,
   INPUT pAtDate AS DATE,
   OUTPUT pCU AS DECIMAL ) IN SUPER.

FUNCTION get-min-sell-depr RETURNS DECIMAL 
  (INPUT pSku AS INTEGER,
   INPUT pDemo AS LOG,
   INPUT pDemoCat AS CHARACTER) IN SUPER.

FUNCTION destroy-locsrl-val RETURNS LOG():
  /* */
  IF VALID-HANDLE(ph-locsrl-val) 
    THEN RETURN SUPER ().
  RETURN NO.
END FUNCTION. 

/*------------------------------------------------------------------------
    File        : 
    Purpose     :

    Syntax      :

    Description :

    Author(s)   :
    Created     :
    Notes       :
  ----------------------------------------------------------------------*/
/*          This .I file was created with the Progress AppBuilder.      */
/*----------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */

&IF DEFINED(EXCLUDE-inventoryfunctions) = 0 &THEN

  &glob EXCLUDE-inventoryfunctions true

DEFINE VARIABLE myInventoryFunctions AS CLASS fn.InventoryFunctions NO-UNDO. 


  DEFINE VARIABLE a AS INTEGER INIT 5. 


  DEFINE VARIABLE mob_SessionObject AS Progress.Lang.Object NO-UNDO.
  DEFINE VARIABLE mch_ObjectName AS CHARACTER NO-UNDO.

  mob_SessionObject = SESSION:FIRST-OBJECT. 
  FIND-CONTEXT: DO WHILE VALID-OBJECT( mob_SessionObject ):
    mch_ObjectName = mob_SessionObject:getClass():TypeName.
    IF mch_ObjectName EQ "fn.InventoryFunctions":U
      THEN DO:
      myInventoryFunctions = CAST( mob_SessionObject, "fn.InventoryFunctions":U ).
      LEAVE FIND-CONTEXT.
    END.
    mob_SessionObject = mob_SessionObject:next-sibling.
  END.
  IF NOT VALID-OBJECT( myInventoryFunctions) THEN DO:
    myInventoryFunctions = NEW fn.InventoryFunctions().
  END.
/*myInventoryFunctions = NEW fn.InventoryFunctions().*/


/* ********************  Preprocessor Definitions  ******************** */

&Scoped-define PROCEDURE-TYPE Procedure
&Scoped-define DB-AWARE no


/* ************************  Function Prototypes ********************** */

FUNCTION AllocateOrder RETURNS LOGICAL
  (p-link AS CHAR, p-item AS INT)  FORWARD.

FUNCTION allow-zero RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION assign-locmas-qty RETURN LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC
  ,p-doc AS CHAR) FORWARD.

FUNCTION brand-allow RETURNS LOGICAL
  (p-brand AS CHAR,p-loc AS CHAR)  FORWARD.

FUNCTION cartage-revenue RETURNS LOGICAL
  (p-sku AS INT)  FORWARD.

FUNCTION MoveBinsToOnLayaway RETURNS LOG
  (p-link AS CHAR /* parameter-definitions */ )  FORWARD.

FUNCTION DESCRIPTION-REQUIRE RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION effect-inv RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION ext-warr-avail RETURNS LOGICAL
  (p-sku AS INT,p-used AS LOG)  FORWARD.

FUNCTION get-auto-order RETURNS LOG(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION get-cost RETURNS DEC(p-sku AS INT,p-physical AS LOG) FORWARD.

FUNCTION get-first-received RETURNS DATE(p-sku AS INT, p-loc AS CHAR) FORWARD.

FUNCTION get-halifax-qty RETURNS INT(p-sku AS INT) FORWARD.

FUNCTION get-hast-qty RETURNS INT(p-sku AS INT) FORWARD.

FUNCTION get-new-cost RETURNS DEC
  (p-sku AS INT,p-physical AS LOG,OUTPUT p-date AS DATE) FORWARD.

FUNCTION get-order-freq RETURNS DEC(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION get-qty-on-repair RETURNS INT(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION get-qty-onhand RETURNS INT(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION get-qty-used RETURNS INT(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION get-qty-demo RETURNS INT(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION get-rglr-warranty RETURNS INTEGER
  (p-sku AS INT,p-used AS LOG,p-serial AS CHAR,p-return AS LOG)  FORWARD.

FUNCTION get-rglr-warranty-rental RETURNS INTEGER
  (p-sku AS INT,p-new AS LOG,p-serial AS CHAR,p-dt-rented AS DATE)  FORWARD.

FUNCTION get-safety RETURNS DEC(p-sku AS INT) FORWARD.

FUNCTION get-section-description RETURNS CHAR (p-section-id AS INT) FORWARD.

FUNCTION get-sku-desc RETURNS CHAR (p-sku AS INT) FORWARD.

FUNCTION get-warranty-charge RETURNS DECIMAL
  (p-retail AS DEC,p-months AS INT,p-yorkville AS LOG,p-used AS LOG
  ,p-sku AS INT,p-qty AS INT)  FORWARD.

FUNCTION get-warranty-sku RETURNS INTEGER
  (p-sku AS INT)  FORWARD.

FUNCTION get-wh-qty RETURNS INTEGER
  (p-sku AS INT)  FORWARD.

FUNCTION GIFT RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION DiscountCard RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION id-labels RETURNS INT (p-option-code AS CHAR
  ,OUTPUT p-label1 AS CHAR
  ,OUTPUT p-label2 AS CHAR
  ,OUTPUT p-label3 AS CHAR
  ,OUTPUT p-label4 AS CHAR
  ,OUTPUT p-label5 AS CHAR
  ,OUTPUT p-label6 AS CHAR) FORWARD.

FUNCTION insurance RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION is-active RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION is-generic RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION is-gift-card-package RETURNS LOGICAL
  (p-sku AS INT)  FORWARD.

FUNCTION is-lessons RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION is-on-order RETURNS LOG(p-serial AS CHAR) FORWARD.

FUNCTION is-package RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION is-print-music RETURNS LOG (p-sku AS INT) FORWARD.

FUNCTION is-warehouse RETURNS LOGICAL
  (p-loc AS CHAR )  FORWARD.

FUNCTION is-warranty-sku RETURNS LOGICAL
  (p-sku AS INT)  FORWARD.

FUNCTION IsBinRequired RETURNS LOGICAL
  (p-loc AS CHAR )  FORWARD.

FUNCTION never-used RETURNS LOGICAL
  (p-sku AS INT)  FORWARD.

FUNCTION no-dash RETURNS CHAR(p-product AS CHAR) FORWARD.

FUNCTION no-oh RETURNS CHAR(p-serial-no AS CHAR) FORWARD.

FUNCTION obsolete-no-stock RETURNS LOGICAL(p-sku AS INT,p-loc AS CHAR) FORWARD.

FUNCTION on-order RETURNS CHAR() FORWARD.

FUNCTION on-transfer RETURNS CHAR() FORWARD.

FUNCTION QtyToShip RETURNS INT
  (p-link AS CHAR,p-item AS INT)  FORWARD.

FUNCTION rental-allowed RETURNS LOGICAL
  (p-sku AS INT )  FORWARD.

FUNCTION rented RETURNS LOGICAL
  (p-serial AS CHAR,p-sku AS INT)  FORWARD.

FUNCTION RETAIL-REQUIRE RETURNS LOGICAL(p-sku AS INT)  FORWARD.

FUNCTION serial-req RETURNS LOG (p-sku AS INT,p-used AS LOG) FORWARD.

FUNCTION short-id-labels RETURNS INT (p-option-code AS CHAR
  ,OUTPUT p-label1 AS CHAR
  ,OUTPUT p-label2 AS CHAR
  ,OUTPUT p-label3 AS CHAR
  ,OUTPUT p-label4 AS CHAR
  ,OUTPUT p-label5 AS CHAR
  ,OUTPUT p-label6 AS CHAR) FORWARD.

FUNCTION special-note RETURNS LOGICAL
  (p-sku AS INT /* parameter-definitions */ )  FORWARD.

FUNCTION to-follow RETURNS CHAR() FORWARD.

FUNCTION unknown-serial RETURNS CHAR() FORWARD.

FUNCTION upd-locmas-qty RETURN LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC
  ,p-doc AS CHAR) FORWARD.

FUNCTION upd-locmas-qty-bin RETURN LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC,p-bin AS CHAR
  ,p-doc AS CHAR) FORWARD.

FUNCTION upd-warranty-sale-i RETURNS LOGICAL
  (p-link AS CHAR,p-item AS INT) FORWARD.

FUNCTION update-onlywy RETURNS LOG
  (p-sku AS INT,p-loc AS CHAR,p-qty AS DEC,p-used AS LOG,p-serial AS CHAR
  ,p-reason AS CHAR,p-doc AS CHAR
  ,p-effect-onhand AS LOG) FORWARD.
  
FUNCTION update-onlywydemo RETURNS LOG   /*11329 */
  (p-sku AS INT,p-loc AS CHAR,p-qty AS DEC,p-demo AS LOG,p-serial AS CHAR
  ,p-reason AS CHAR,p-doc AS CHAR
  ,p-effect-onhand AS LOG) FORWARD.  

FUNCTION UpdateOnLayawayBin RETURNS LOG
  (p-link AS CHAR, p-item AS INT,p-qty AS DEC
  ,p-effect-onhand AS LOG
  ,p-bin AS CHAR) FORWARD.

FUNCTION valid-option-code RETURNS LOG (p-option-code AS CHAR) FORWARD.

FUNCTION yorkville-manufacture RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION yorkville-product RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION ysl-sub-std-avail RETURNS LOG(p-sku AS INT) FORWARD.

FUNCTION zero-price-only RETURNS LOGICAL
  (p-sku AS INT  /* parameter-definitions */ )  FORWARD.

/* *********************** Procedure Settings ************************ */



/* *************************  Create Window  ************************** */

/* DESIGN Window definition (used by the UIB) 
  CREATE WINDOW Procedure ASSIGN
         HEIGHT             = 29.76
         WIDTH              = 70.4.
/* END WINDOW DEFINITION */
                                                                        */


/* ***************************  Main Block  *************************** */



/* ************************  Function Implementations ***************** */
FUNCTION UpdatePhysicalCost RETURNS LOGICAL 
  (pSku AS INTEGER,pNewCost AS DECIMAL):  

  /*------------------------------------------------------------------------------
                  Purpose:                                                                                                                                            
                  Notes:                                                                                                                                            
  ------------------------------------------------------------------------------*/        
  myInventoryFunctions:UpdatePhysicalCost(pSku,pNewCost).
  RETURN FALSE.
END FUNCTION.

FUNCTION AllocateOrder RETURNS LOGICAL(p-link AS CHAR, p-item AS INT) :
  RETURN myInventoryFunctions:AllocateOrder(p-link,p-item). 
END FUNCTION.

FUNCTION allow-zero RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:allow-zero(p-sku). 
END FUNCTION.

FUNCTION assign-locmas-qty RETURN LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC
  ,p-doc AS CHAR):
  RETURN myInventoryFunctions:assign-locmas-qty(p-sku,p-loc,p-field,p-qty,p-doc). 
END FUNCTION.

FUNCTION brand-allow RETURNS LOGICAL  (p-brand AS CHAR,p-loc AS CHAR) :
  RETURN myInventoryFunctions:brand-allow(p-brand,p-loc).
END FUNCTION.

FUNCTION cartage-revenue RETURNS LOGICAL (p-sku AS INT) :
  RETURN myInventoryFunctions:cartage-revenue(p-sku).
END FUNCTION.

FUNCTION MoveBinsToOnLayaway RETURNS LOG(p-link AS CHAR ) :
  RETURN myInventoryFunctions:MoveBinsToOnLayaway(p-link).
END FUNCTION.

FUNCTION CancelLayawayBins RETURNS LOG(pLink AS CHAR ) :
  RETURN myInventoryFunctions:CancelLayawayBins(pLink). 
END FUNCTION.

FUNCTION DESCRIPTION-REQUIRE RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:description-require(p-sku).
END FUNCTION.

FUNCTION effect-inv RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:effect-inv(p-sku).
END FUNCTION.

FUNCTION ext-warr-avail RETURNS LOGICAL(p-sku AS INT,p-used AS LOG) :
  RETURN myInventoryFunctions:ext-warr-avail(p-sku,p-used).
END FUNCTION.

FUNCTION get-auto-order RETURNS LOG(p-sku AS INT,p-loc AS CHAR):
  RETURN myInventoryFunctions:get-auto-order(p-sku,p-loc).
END FUNCTION.

FUNCTION get-cost RETURNS DEC(p-sku AS INT,p-physical AS LOG):
  RETURN myInventoryFunctions:get-cost(p-sku,p-physical).
END FUNCTION.

FUNCTION get-first-received RETURNS DATE(p-sku AS INT, p-loc AS CHAR):
  RETURN myInventoryFunctions:get-first-received(p-sku,p-loc).
END FUNCTION.

FUNCTION get-halifax-qty RETURNS INT(p-sku AS INT):
  RETURN myInventoryFunctions:GetQtyAvail(p-sku,"LX54"). 
END FUNCTION.

FUNCTION get-hast-qty RETURNS INT(p-sku AS INT):
  RETURN myInventoryFunctions:get-qty-onhand(p-sku,"LW21").
END FUNCTION.

FUNCTION get-new-cost RETURNS DEC(p-sku AS INT,p-physical AS LOG,OUTPUT p-date AS DATE):
  RETURN myInventoryFunctions:GetCost((IF p-physical THEN "Physical" ELSE ""),
                                       p-sku,
                                       TODAY).
END FUNCTION.

FUNCTION get-new-cost-at RETURNS DEC(p-sku AS INT,INPUT p-date AS DATE):
  RETURN myInventoryFunctions:GetCost("", p-sku, p-date).
END FUNCTION.

FUNCTION get-new-cost-at-physical RETURNS DEC(p-sku AS INT,INPUT p-date AS DATE):
  RETURN myInventoryFunctions:GetCost("PHYSICAL", p-sku, p-date).
END FUNCTION.

FUNCTION get-order-freq RETURNS DEC(p-sku AS INT,p-loc AS CHAR):
  RETURN myInventoryFunctions:get-order-freq(p-sku,p-loc).
END FUNCTION.

FUNCTION get-qty-on-repair RETURNS INT(p-sku AS INT,p-loc AS CHAR):
  RETURN myInventoryFunctions:get-qty-on-repair(p-sku,p-loc).
END FUNCTION.

FUNCTION get-qty-onhand RETURNS INT(p-sku AS INT,p-loc AS CHAR):
  RETURN myInventoryFunctions:get-qty-onhand(p-sku,p-loc).
END FUNCTION.

FUNCTION get-qty-used RETURNS INT(p-sku AS INT,p-loc AS CHAR):
  RETURN myInventoryFunctions:get-qty-used(p-sku,p-loc).
END FUNCTION.

FUNCTION get-rglr-warranty RETURNS INTEGER
  (p-sku AS INT,p-used AS LOG,p-serial AS CHAR,p-return AS LOG) :
  RETURN myInventoryFunctions:get-rglr-warranty(p-sku,p-used,p-serial,p-return).
END FUNCTION.

FUNCTION get-rglr-warranty-rental RETURNS INTEGER
  (p-sku AS INT,p-new AS LOG,p-serial AS CHAR,p-dt-rented AS DATE) :
  RETURN myInventoryFunctions:get-rglr-warranty-rental(p-sku,p-new,p-serial,p-dt-rented).
END FUNCTION.

FUNCTION get-safety RETURNS DEC(p-sku AS INT):
  RETURN myInventoryFunctions:get-safety(p-sku).
END FUNCTION.

FUNCTION get-section-description RETURNS CHAR (p-section-id AS INT):
  RETURN myInventoryFunctions:get-section-description(p-section-id).
END FUNCTION.

FUNCTION get-sku-desc RETURNS CHAR (p-sku AS INT):
  RETURN myInventoryFunctions:get-sku-desc(p-sku).
END FUNCTION.

FUNCTION get-warranty-charge RETURNS DECIMAL
  (p-retail AS DEC,p-months AS INT,p-yorkville AS LOG,p-used AS LOG
  ,p-sku AS INT,p-qty AS INT) :
  RETURN myInventoryFunctions:get-warranty-charge(p-retail,p-months,p-yorkville,p-used,p-sku,p-qty).
END FUNCTION.

FUNCTION get-warranty-sku RETURNS INTEGER(p-sku AS INT) :
  RETURN myInventoryFunctions:get-warranty-sku(p-sku).
END FUNCTION.

FUNCTION get-wh-qty RETURNS INTEGER(p-sku AS INT) :
  RETURN myInventoryFunctions:get-wh-qty(p-sku).
END FUNCTION.

FUNCTION GIFT RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:gift(p-sku).
END FUNCTION.

FUNCTION DiscountCard RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:DiscountCard(p-sku).
END FUNCTION.
  
FUNCTION id-labels RETURNS INT (p-option-code AS CHAR
  ,OUTPUT p-label1 AS CHAR
  ,OUTPUT p-label2 AS CHAR
  ,OUTPUT p-label3 AS CHAR
  ,OUTPUT p-label4 AS CHAR
  ,OUTPUT p-label5 AS CHAR
  ,OUTPUT p-label6 AS CHAR):
  RETURN myInventoryFunctions:id-labels(p-option-code,p-label1,p-label2,p-label3,p-label4,p-label5,p-label6).
END FUNCTION.

FUNCTION insurance RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:insurance(p-sku).
END FUNCTION.

FUNCTION is-active RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:is-active(p-sku).
END FUNCTION.

FUNCTION is-generic RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:is-generic(p-sku).
END FUNCTION.

FUNCTION is-gift-card-package RETURNS LOGICAL(p-sku AS INT) :
  RETURN myInventoryFunctions:is-gift-card-package(p-sku).
END FUNCTION.

FUNCTION is-lessons RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:is-lessons(p-sku).
END FUNCTION.

FUNCTION is-on-order RETURNS LOG(p-serial AS CHAR):
  RETURN myInventoryFunctions:is-on-order(p-serial).
END FUNCTION.

FUNCTION is-package RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:is-package(p-sku).
END FUNCTION.

FUNCTION is-print-music RETURNS LOG (p-sku AS INT):
  RETURN myInventoryFunctions:is-print-music(p-sku).
END FUNCTION.

FUNCTION is-warehouse RETURNS LOGICAL(p-loc AS CHAR ) :
  RETURN myInventoryFunctions:is-warehouse(p-loc).
END FUNCTION.

FUNCTION is-warranty-sku RETURNS LOGICAL(p-sku AS INT) :
  RETURN myInventoryFunctions:is-warranty-sku(p-sku).
END FUNCTION.

FUNCTION IsBinRequired RETURNS LOGICAL(p-loc AS CHAR ) :
  RETURN myInventoryFunctions:IsBinRequired(p-loc).
END FUNCTION.

FUNCTION never-used RETURNS LOGICAL(p-sku AS INT) :
  RETURN myInventoryFunctions:never-used(p-sku).
END FUNCTION.

FUNCTION no-dash RETURNS CHAR(p-product AS CHAR):
  RETURN myInventoryFunctions:no-dash(p-product).
END FUNCTION.

FUNCTION no-oh RETURNS CHAR(p-serial-no AS CHAR):
  RETURN myInventoryFunctions:no-oh(p-serial-no).
END FUNCTION.

FUNCTION obsolete-no-stock RETURNS LOGICAL(p-sku AS INT,p-loc AS CHAR):
  RETURN myInventoryFunctions:obsolete-no-stock(p-sku,p-loc).
END FUNCTION.

FUNCTION on-order RETURNS CHAR():
  RETURN myInventoryFunctions:on-order().
END FUNCTION.

FUNCTION on-transfer RETURNS CHAR():
  RETURN myInventoryFunctions:on-transfer().
END FUNCTION.

FUNCTION QtyToShip RETURNS INT(p-link AS CHAR,p-item AS INT) :
  RETURN myInventoryFunctions:QtyToShip(p-link,p-item).
END FUNCTION.

FUNCTION rental-allowed RETURNS LOGICAL(p-sku AS INT ):
  RETURN myInventoryFunctions:rental-allowed(p-sku).
END FUNCTION.

FUNCTION rented RETURNS LOGICAL(p-serial AS CHAR,p-sku AS INT) :
  RETURN myInventoryFunctions:rented(p-serial,p-sku).
END FUNCTION.

FUNCTION RETAIL-REQUIRE RETURNS LOGICAL(p-sku AS INT) :
  RETURN myInventoryFunctions:RETAIL-REQUIRE(p-sku).
END FUNCTION.

FUNCTION serial-req RETURNS LOG (p-sku AS INT,p-used AS LOG):
  RETURN myInventoryFunctions:serial-req(p-sku,p-used).
END FUNCTION.

FUNCTION short-id-labels RETURNS INT (p-option-code AS CHAR
  ,OUTPUT p-l1 AS CHAR
  ,OUTPUT p-l2 AS CHAR
  ,OUTPUT p-l3 AS CHAR
  ,OUTPUT p-l4 AS CHAR
  ,OUTPUT p-l5 AS CHAR
  ,OUTPUT p-l6 AS CHAR):
  RETURN myInventoryFunctions:short-id-labels(p-option-code,p-l1,p-l2,p-l3,p-l4,p-l5,p-l6).
END FUNCTION.

FUNCTION special-note RETURNS LOGICAL(p-sku AS INT) :
  RETURN myInventoryFunctions:special-note(p-sku).
END FUNCTION.

FUNCTION to-follow RETURNS CHAR():
  RETURN myInventoryFunctions:to-follow().
END FUNCTION.

FUNCTION unknown-serial RETURNS CHAR():
  RETURN myInventoryFunctions:unknown-serial().
END FUNCTION.

FUNCTION upd-locmas-qty RETURN LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC
  ,p-doc AS CHAR):
  RETURN myInventoryFunctions:upd-locmas-qty(p-sku,p-loc,p-field,p-qty,p-doc). 
END FUNCTION.

FUNCTION UpdateInvLocBin RETURNS LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC,p-bin AS CHAR
  ,p-doc AS CHAR):
  RETURN myInventoryFunctions:UpdateInvLocBin(p-sku,p-loc,p-field,p-qty,p-bin,p-doc).     
END FUNCTION.

FUNCTION upd-locmas-qty-bin RETURN LOG
  (p-sku AS INT,p-loc AS CHAR,p-field AS CHAR,p-qty AS DEC,p-bin AS CHAR
  ,p-doc AS CHAR):
  RETURN myInventoryFunctions:upd-locmas-qty-bin(p-sku,p-loc,p-field,p-qty,p-bin,p-doc).     
END FUNCTION.

FUNCTION upd-warranty-sale-i RETURNS LOGICAL(p-link AS CHAR,p-item AS INT):
  RETURN myInventoryFunctions:upd-warranty-sale-i(p-link,p-item).    
END FUNCTION.

FUNCTION update-onlywy RETURNS LOG
  (p-sku AS INT,p-loc AS CHAR,p-qty AS DEC,p-used AS LOG,p-serial AS CHAR
  ,p-reason AS CHAR,p-doc AS CHAR
  ,p-effect-onhand AS LOG):
  RETURN myInventoryFunctions:update-onlywy(p-sku,p-loc,p-qty,p-used,p-serial,p-reason,p-doc,p-effect-onhand).  
END FUNCTION.

FUNCTION update-onlywydemo RETURNS LOG  /* 11329 */
  (p-sku AS INT,p-loc AS CHAR,p-qty AS DEC,p-demo AS LOG,p-serial AS CHAR
  ,p-reason AS CHAR,p-doc AS CHAR
  ,p-effect-onhand AS LOG):
  RETURN myInventoryFunctions:update-onlywydemo(p-sku,p-loc,p-qty,p-demo,p-serial,p-reason,p-doc,p-effect-onhand).  
END FUNCTION.

FUNCTION UpdateOnLayawayBin RETURNS LOG
  (p-link AS CHAR, p-item AS INT,p-qty AS DEC
  ,p-effect-onhand AS LOG
  ,p-bin AS CHAR):
  RETURN myInventoryFunctions:UpdateOnLayawayBin(p-link,p-item,p-qty,p-effect-onhand,p-bin).  
END FUNCTION.

FUNCTION valid-option-code RETURNS LOG (p-option-code AS CHAR):
  RETURN myInventoryFunctions:valid-option-code(p-option-code).  
END FUNCTION.

FUNCTION yorkville-manufacture RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:yorkville-manufacture(p-sku).  
END FUNCTION.

FUNCTION yorkville-product RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:yorkville-product(p-sku).  
END FUNCTION.

FUNCTION ysl-sub-std-avail RETURNS LOG(p-sku AS INT):
  RETURN myInventoryFunctions:ysl-sub-std-avail(p-sku).  
END FUNCTION.

FUNCTION zero-price-only RETURNS LOGICAL(p-sku AS INT) :
  RETURN myInventoryFunctions:zero-price-only(p-sku).  
END FUNCTION.

FUNCTION add-months RETURNS DATE(p-date AS DATE,p-months AS INT).
  RETURN myInventoryFunctions:add-months(p-date,p-months).  
END FUNCTION.

FUNCTION get-last-day-of-month RETURNS DATE(p-date AS DATE):
  RETURN myInventoryFunctions:get-last-day-of-month(p-date).  
END FUNCTION.

FUNCTION is-holiday RETURNS LOG(p-date AS DATE,p-loc AS CHAR):
  RETURN myInventoryFunctions:is-holiday(p-date,p-loc).  
END FUNCTION.

FUNCTION get-first-day-of-month RETURNS DATE(p-date AS DATE):
  RETURN myInventoryFunctions:get-first-day-of-month(p-date).  
END FUNCTION.

FUNCTION UpdateReserveBinQty RETURNS LOG(pLink AS CHAR,pItem AS INT
  ,pQty AS DECIMAL,pBin AS CHAR):
  myInventoryFunctions:UpdateReserveBinQty(pLink,pItem,pQty,pBin). 
  RETURN TRUE.
END FUNCTION.

FUNCTION QtyAvailable RETURNS INTEGER(pSku AS INT,pLoc AS CHAR):
  RETURN myInventoryFunctions:QtyAvailable(pSku,pLoc). 
END FUNCTION.

FUNCTION YorkvilleLocation RETURNS CHARACTER (  ):
  RETURN myInventoryFunctions:YorkvilleLocation(). 
END FUNCTION. 

FUNCTION GetBinQtyOnHand RETURNS INTEGER(pSku AS INT,pLoc AS CHAR,pBin AS CHAR):
  RETURN myInventoryFunctions:GetBinQtyOnHand(pSku,pLoc,pBin). 
END FUNCTION. 

FUNCTION IsWebProduct RETURNS LOGICAL(pSku AS INT): /* Task# 4860 */
  RETURN myInventoryFunctions:IsWebProduct(pSku). 
END FUNCTION. 

FUNCTION FamilyProduct RETURNS LOGICAL(pSku AS INT): /* Task# 5853 */
  RETURN myInventoryFunctions:FamilyProduct(pSku).
END FUNCTION.
&ENDIF
/*------------------------------------------------------------------------------
  File:
    im/pricing.i
    
  Description:
    It runs the pricing program as persistent and does all the pricing

    clear-pricing()     - clears the variables before a new call 

    destroy-pricing()   - call this when exiting your program to destroy 
                          the instants of im/pricing.p 

    get-cust-disc       - returns the customers discount which should 
                          be store in the sale-i.mkdn-amt field. 

    get-date-last-price - returns the effective date of the last price 
                          that you requested. 

    get-new-cust-price  - returns the customer price after the discount. To 
                          get the before price add the get-cust-disc() value.
                          PARAMETERS REQUIRED:
                          INPUT p-sku AS INTEGER
                          INPUT p-loc AS CHARACTER,
                          INPUT p-promo AS LOGICAL,
                          INPUT p-custno AS CHARACTER
           
    get-new-price       - gets the price for a sku. 
                          This is the a ame as im/get-price.p 
                          PARAMAETERS REQUIRED:
                          INPUT p-sku AS INTEGER
                          INPUT p-loc AS CHARACTER
                          INPUT p-promo AS LOGICAL
                   
    get-price-type      - returns the type of the last price. 
                          (eg. "S" for store and blank for regular) 

    get-dual-price      - returns a logical of whether this product should 
                          have a bar code price separate from the selling 
                          price. 

                          PARAMAETERS REQUIRED:
                          INPUT p-currency AS character
                          INPUT p-group    AS integer

    get-bc-loc          - returns the location code that is used for the 
                          bar code price record 

    get-new-price       - gets the new cost for a sku. 
                          This is the a ame as im/get-cost.p 
                          PARAMAETERS REQUIRED:
                          INPUT p-sku AS INTEGER
                          INPUT p-physical AS log 
    
  Syntax:
    {im/pricing.i} 
     
  Input Parameters:
    <none>

  Output Parameters:
    <none>

  Input-Output Parameters:
    <none>
                
  History:
------------------------------------------------------------------------------*/

DEF VAR ph-pricing AS HANDLE NO-UNDO.
RUN im/pricing.p PERSISTENT SET ph-pricing.
THIS-PROCEDURE:ADD-SUPER-PROCEDURE (ph-pricing).
ph-pricing:PRIVATE-DATA = THIS-PROCEDURE:FILE-NAME + ",":U 
                        + STRING(THIS-PROCEDURE:HANDLE).
/*
 * Prototype include file: H:\WorkSpaces\457\im\pricprto.i
 * Created from procedure: H:\WorkSpaces\457\im\pricing.p at 14:28 on 11/30/09
 * by the PROGRESS PRO*Tools Prototype Include File Generator
 */

FUNCTION AllocateOrder RETURNS LOGICAL
  (INPUT p-link AS CHARACTER,
   INPUT p-item AS INTEGER) IN SUPER.

FUNCTION allow-zero RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION assign-locmas-qty RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-field AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-doc AS CHARACTER) IN SUPER.

FUNCTION brand-allow RETURNS LOGICAL
  (INPUT p-brand AS CHARACTER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION cartage-revenue RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION MoveBinsToOnLayaway RETURNS LOGICAL
  (INPUT p-link AS CHARACTER) IN SUPER.

FUNCTION DESCRIPTION-REQUIRE RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION effect-inv RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION ext-warr-avail RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-used AS LOGICAL) IN SUPER.

FUNCTION get-auto-order RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-physical AS LOGICAL) IN SUPER.

FUNCTION get-first-received RETURNS DATE
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-halifax-qty RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-hast-qty RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-new-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-physical AS LOGICAL,
   OUTPUT p-date AS DATE) IN SUPER.

FUNCTION get-order-freq RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-qty-on-repair RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-qty-onhand RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-qty-used RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-rglr-warranty RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-used AS LOGICAL,
   INPUT p-serial AS CHARACTER,
   INPUT p-return AS LOGICAL) IN SUPER.

FUNCTION get-rglr-warranty-rental RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-new AS LOGICAL,
   INPUT p-serial AS CHARACTER,
   INPUT p-dt-rented AS DATE) IN SUPER.

FUNCTION get-safety RETURNS DECIMAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-section-description RETURNS CHARACTER
  (INPUT p-section-id AS INTEGER) IN SUPER.

FUNCTION get-sku-desc RETURNS CHARACTER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-warranty-charge RETURNS DECIMAL
  (INPUT p-retail AS DECIMAL,
   INPUT p-months AS INTEGER,
   INPUT p-yorkville AS LOGICAL,
   INPUT p-used AS LOGICAL,
   INPUT p-sku AS INTEGER,
   INPUT p-qty AS INTEGER) IN SUPER.

FUNCTION get-warranty-sku RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-wh-qty RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION GIFT RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION id-labels RETURNS INTEGER
  (INPUT p-option-code AS CHARACTER,
   OUTPUT p-label1 AS CHARACTER,
   OUTPUT p-label2 AS CHARACTER,
   OUTPUT p-label3 AS CHARACTER,
   OUTPUT p-label4 AS CHARACTER,
   OUTPUT p-label5 AS CHARACTER,
   OUTPUT p-label6 AS CHARACTER) IN SUPER.

FUNCTION insurance RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-active RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-generic RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-gift-card-package RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-lessons RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-on-order RETURNS LOGICAL
  (INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION is-package RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-print-music RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-warehouse RETURNS LOGICAL
  (INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION is-warranty-sku RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION IsBinRequired RETURNS LOGICAL
  (INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION never-used RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION no-dash RETURNS CHARACTER
  (INPUT p-product AS CHARACTER) IN SUPER.

FUNCTION no-oh RETURNS CHARACTER
  (INPUT p-serial-no AS CHARACTER) IN SUPER.

FUNCTION obsolete-no-stock RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION on-order RETURNS CHARACTER IN SUPER.

FUNCTION on-transfer RETURNS CHARACTER IN SUPER.

FUNCTION QtyToShip RETURNS INTEGER
  (INPUT p-link AS CHARACTER,
   INPUT p-item AS INTEGER) IN SUPER.

FUNCTION rental-allowed RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION rented RETURNS LOGICAL
  (INPUT p-serial AS CHARACTER,
   INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION RETAIL-REQUIRE RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION serial-req RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-used AS LOGICAL) IN SUPER.

FUNCTION short-id-labels RETURNS INTEGER
  (INPUT p-option-code AS CHARACTER,
   OUTPUT p-l1 AS CHARACTER,
   OUTPUT p-l2 AS CHARACTER,
   OUTPUT p-l3 AS CHARACTER,
   OUTPUT p-l4 AS CHARACTER,
   OUTPUT p-l5 AS CHARACTER,
   OUTPUT p-l6 AS CHARACTER) IN SUPER.

FUNCTION special-note RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION to-follow RETURNS CHARACTER IN SUPER.

FUNCTION unknown-serial RETURNS CHARACTER IN SUPER.

FUNCTION upd-locmas-qty RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-field AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-doc AS CHARACTER) IN SUPER.

FUNCTION upd-locmas-qty-bin RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-field AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-bin AS CHARACTER,
   INPUT p-doc AS CHARACTER) IN SUPER.

FUNCTION upd-warranty-sale-i RETURNS LOGICAL
  (INPUT p-link AS CHARACTER,
   INPUT p-item AS INTEGER) IN SUPER.

FUNCTION update-onlywy RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-used AS LOGICAL,
   INPUT p-serial AS CHARACTER,
   INPUT p-reason AS CHARACTER,
   INPUT p-doc AS CHARACTER,
   INPUT p-effect-onhand AS LOGICAL) IN SUPER.

FUNCTION UpdateOnLayawayBin RETURNS LOGICAL
  (INPUT p-link AS CHARACTER,
   INPUT p-item AS INTEGER,
   INPUT p-qty AS DECIMAL,
   INPUT p-effect-onhand AS LOGICAL,
   INPUT p-bin AS CHARACTER) IN SUPER.

FUNCTION valid-option-code RETURNS LOGICAL
  (INPUT p-option-code AS CHARACTER) IN SUPER.

FUNCTION yorkville-manufacture RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION yorkville-product RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION ysl-sub-std-avail RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION zero-price-only RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION UpdatePhysicalCost RETURNS LOGICAL
  (INPUT pSku AS INTEGER,
   INPUT pNewCost AS DECIMAL) IN SUPER.

FUNCTION CancelLayawayBins RETURNS LOGICAL
  (INPUT pLink AS CHARACTER) IN SUPER.

FUNCTION get-new-cost-at RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION get-new-cost-at-physical RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION UpdateInvLocBin RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-field AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-bin AS CHARACTER,
   INPUT p-doc AS CHARACTER) IN SUPER.

FUNCTION add-months RETURNS DATE
  (INPUT p-date AS DATE,
   INPUT p-months AS INTEGER) IN SUPER.

FUNCTION get-last-day-of-month RETURNS DATE
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION is-holiday RETURNS LOGICAL
  (INPUT p-date AS DATE,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-first-day-of-month RETURNS DATE
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION UpdateReserveBinQty RETURNS LOGICAL
  (INPUT pLink AS CHARACTER,
   INPUT pItem AS INTEGER,
   INPUT pQty AS DECIMAL,
   INPUT pBin AS CHARACTER) IN SUPER.

FUNCTION QtyAvailable RETURNS INTEGER
  (INPUT pSku AS INTEGER,
   INPUT pLoc AS CHARACTER) IN SUPER.

FUNCTION YorkvilleLocation RETURNS CHARACTER IN SUPER.

FUNCTION clear-pricing RETURNS LOGICAL IN SUPER.

FUNCTION dbl-rounding RETURNS LOGICAL
  (INPUT p-amount AS DECIMAL,
   INPUT p-rr-code AS CHARACTER,
   OUTPUT p-rounded AS DECIMAL) IN SUPER.

FUNCTION destroy-pricing RETURNS LOGICAL IN SUPER.

FUNCTION get-bc-loc RETURNS CHARACTER IN SUPER.

FUNCTION get-cust-disc RETURNS DECIMAL IN SUPER.

FUNCTION get-date-last-price RETURNS DATE IN SUPER.

FUNCTION get-disc-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-level AS INTEGER) IN SUPER.

FUNCTION get-dual-price RETURNS LOGICAL
  (INPUT p-currency AS CHARACTER,
   INPUT p-group AS INTEGER) IN SUPER.

FUNCTION get-new-bc-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL) IN SUPER.

FUNCTION get-new-cost1 RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-physical AS LOGICAL) IN SUPER.

FUNCTION get-new-cust-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-custno AS CHARACTER,
   INPUT p-arsale AS LOGICAL) IN SUPER.

FUNCTION get-new-cust-bc-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-custno AS CHARACTER,
   INPUT p-arsale AS LOGICAL) IN SUPER.

FUNCTION get-new-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL) IN SUPER.

FUNCTION get-new-price-as-of RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION get-price-region RETURNS INTEGER
  (INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-price-type RETURNS CHARACTER IN SUPER.

FUNCTION is-customer-a-employee RETURNS LOGICAL
  (INPUT p-custno AS CHARACTER) IN SUPER.

FUNCTION is-customer-a-school RETURNS LOGICAL
  (INPUT p-custno AS CHARACTER) IN SUPER.

FUNCTION is-on-promo RETURNS LOGICAL
  (INPUT p-sku# AS INTEGER,
   INPUT p-start-dt AS DATE,
   INPUT p-end-dt AS DATE) IN SUPER.

FUNCTION get-disc-bc-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-level AS INTEGER) IN SUPER.


FUNCTION destroy-pricing RETURNS LOG():
  /* */
  IF VALID-HANDLE(ph-pricing) THEN do:
    DELETE PROCEDURE ph-pricing.
    return yes.
    /* RETURN SUPER (). */
  end.
  RETURN NO.
END FUNCTION. 
FUNCTION get-contract RETURNS CHAR
  (p-serial AS CHAR,p-sku AS INT,OUTPUT p-loc AS CHAR):
  DEF BUFFER bf-ord-s FOR order-s.
  DEF BUFFER bf-ord-i FOR order-i.
  DEF BUFFER bf-order FOR order.

  FOR EACH bf-ord-s NO-LOCK
    WHERE bf-ord-s.serial-no = p-serial,
    EACH bf-ord-i OF bf-ord-s  NO-LOCK
    WHERE bf-ord-i.sku-no = p-sku
    AND bf-ord-i.dt-return = ?
    AND NOT bf-ord-i.void,
    EACH bf-order OF bf-ord-i NO-LOCK
    WHERE (bf-order.sale-type = "rn":u OR bf-order.sale-type = "rh":u)
    AND bf-order.int-status <> "PICKED UP":u:
    p-loc = bf-order.loc-code.
    RETURN bf-order.order-no.
  END.
  RETURN "".
END FUNCTION.

FUNCTION rental-mult RETURNS DEC(p-yearly AS LOG):
  RETURN IF p-yearly THEN 1.0 ELSE 1.0.  /* changed from 5.0 */
END FUNCTION.

FUNCTION get-location-for-tax RETURNS CHAR(p-order-no AS CHAR):
  DEFINE VARIABLE p-ShipDirect   AS LOGICAL NO-UNDO.
  DEFINE VARIABLE p-prov AS CHAR NO-UNDO.
  FIND FIRST order WHERE order.order-no = p-order-no NO-LOCK NO-ERROR.
  IF NOT AVAIL order THEN RETURN "".
  PUBLISH "IsShipDirect" (OUTPUT p-shipDirect, OUTPUT p-prov).
  IF p-shipDirect OR order.shipDirect = YES THEN DO:
    IF p-prov <> "" THEN
      find first location no-lock where location.prov = p-prov
        AND location.active no-error.
    ELSE IF order.shipDirect = YES THEN DO:
      find first ord-lywy of order no-lock no-error.
      if avail ord-lywy then
        find first location no-lock where location.prov = ord-lywy.prov
          AND location.active no-error.
    END.
  END.
  ELSE FIND location NO-LOCK WHERE location.loc-code = order.loc-code.
  IF AVAIL location THEN RETURN location.loc-code.
  ELSE RETURN "".
END FUNCTION.

FUNCTION is-rto RETURNS LOG(p-link-order AS CHAR):
  DEF BUFFER b-order FOR order. 
  FIND b-order WHERE b-order.link-order = p-link-order NO-LOCK NO-ERROR. 
  IF AVAIL b-order AND b-order.rent-code = "rentown":u THEN RETURN YES.
  ELSE RETURN NO.
END FUNCTION. 

FUNCTION is-loan RETURNS LOG(p-link-sale AS CHAR):
  DEF BUFFER b-sale-i FOR sale-i.
  IF CAN-FIND(b-sale-i WHERE b-sale-i.link-sale = p-link-sale
              AND b-sale-i.sku-no = 9999999 
              AND b-sale-i.product-no BEGINS "loan":U AND b-sale-i.retail = 0
              USE-INDEX link-sale)
    THEN RETURN YES.
  RETURN NO.
END FUNCTION. 

FUNCTION is-a-loan RETURNS LOG (INPUT p-linkorder AS CHAR):
  DEF VAR t-loan-flag   AS LOG NO-UNDO.

  DEF BUFFER b-o    FOR order.
  DEF BUFFER b-oi   FOR order-i.

  FIND b-o NO-LOCK
    WHERE b-o.link-order = p-linkorder NO-ERROR.
  IF NOT AVAILABLE b-o THEN ASSIGN t-loan-flag = NO.
  ELSE IF b-o.sale-type = "RN":u
    AND (b-o.order-no BEGINS "RN":u OR b-o.order-no BEGINS "N":u)
    AND b-o.int-status <> "picked up":u THEN DO:
    IF CAN-FIND(FIRST b-oi OF b-o
                WHERE b-oi.void = NO
                AND b-oi.item-type = "ri":u
                AND b-oi.extended <> 0
                AND b-oi.dt-loan <> ?) THEN ASSIGN t-loan-flag = NO.
    ELSE IF CAN-FIND(FIRST b-oi OF b-o
                  WHERE b-oi.void = NO
                  AND b-oi.item-type = "ri":U
                  AND b-oi.dt-loan <> ?
                  AND b-oi.extended = 0) THEN ASSIGN t-loan-flag = YES.
    ELSE ASSIGN t-loan-flag = NO.
  END.
  RETURN t-loan-flag.
END FUNCTION.

FUNCTION is-leaveout RETURNS LOG(p-link-sale AS CHAR):
  DEF BUFFER b-sale-i FOR sale-i.
  IF CAN-FIND(b-sale-i WHERE b-sale-i.link-sale = p-link-sale
              AND b-sale-i.sku-no = 9999999 
              AND INDEX(sale-i.description,"LEAVE-OUT":u) <> 0
              AND b-sale-i.retail = 0
              USE-INDEX link-sale)
    THEN RETURN YES.
  RETURN NO.
END FUNCTION. 

FUNCTION is-initial-rental-create RETURNS LOG (p-ls AS CHAR):
/* Determines if this is the initial creation of the contract. */
  DEF VAR t-is-irc AS LOG NO-UNDO INIT YES.
  DEF VAR t-lo AS CHAR NO-UNDO.
  DEF VAR t-dt AS DATE NO-UNDO INIT TODAY.
  DEF VAR t-tm AS INT NO-UNDO.

  DEF BUFFER b-s FOR sale.

  FIND b-s NO-LOCK
    WHERE b-s.link-sale = p-ls NO-ERROR.
  IF AVAILABLE b-s THEN DO:
    ASSIGN
      t-lo = b-s.link-order
      t-dt = b-s.dt-trans
      t-tm = b-s.tm-trans.

    IF CAN-FIND(FIRST b-s USE-INDEX LO-DT-TT
                WHERE b-s.link-order = t-lo
                AND b-s.dt-trans < t-dt)
      THEN ASSIGN t-is-irc = NO.
      ELSE IF CAN-FIND(FIRST b-s USE-INDEX LO-DT-TT
                       WHERE b-s.link-order = t-lo
                       AND b-s.dt-trans = t-dt
                       AND b-s.tm-trans < t-tm)
      THEN ASSIGN t-is-irc = NO.
      ELSE ASSIGN t-is-irc = YES.
    /*
    IF CAN-FIND(FIRST b-s USE-INDEX LO-DT-TT
                WHERE b-s.link-order = t-lo
                AND (b-s.dt-trans < t-dt
                     OR (b-s.dt-trans = t-dt AND b-s.tm-trans < t-tm)))
      THEN ASSIGN t-is-irc = NO.
      ELSE ASSIGN t-is-irc = YES.
    */
  END.
  ELSE ASSIGN t-is-irc = YES.
  RETURN t-is-irc.
END FUNCTION.

FUNCTION movement RETURNS LOG(p-link-sale AS CHAR):
  DEF BUFFER b-sale-i FOR sale-i.
  DEF BUFFER b-sale-s FOR sale-s.

  FOR EACH b-sale-i NO-LOCK
    WHERE b-sale-i.link-sale = p-link-sale
    AND NOT b-sale-i.void 
    AND CAN-FIND(FIRST b-sale-s OF b-sale-i):
    IF CAN-FIND(inv-master OF b-sale-i
                WHERE inv-master.rec-type = "4":U) THEN NEXT.
    RETURN YES.
  END.
  RETURN NO.
END FUNCTION.

FUNCTION rental-out-movement RETURNS LOG(p-link-sale AS CHAR):
  DEF BUFFER b-sale-i FOR sale-i.
  DEF BUFFER b-sale-s FOR sale-s.

  FOR EACH b-sale-i WHERE b-sale-i.link-sale = p-link-sale
    AND NOT b-sale-i.void 
    AND b-sale-i.item-type = "rp":U
    AND CAN-FIND(FIRST b-sale-s OF b-sale-i):
    RETURN YES.
  END.
  RETURN NO.
END FUNCTION.

/*Deposit Cash refunds below Regular Rental below $20?*/
FUNCTION rental-deposit-refund20-cash RETURNS LOG(p-link-sale AS CHAR):
  DEF BUFFER b-sale-i FOR sale-i.
  DEF BUFFER b-saletend FOR saletend.
  DEF BUFFER b-sale FOR sale.

  FOR EACH b-sale-i WHERE b-sale-i.link-sale = p-link-sale
    AND NOT b-sale-i.void 
    AND b-sale-i.SKU-NO = 0
    AND b-sale-i.item-type = "PD":U
    AND b-sale-i.retail < 0 AND b-sale-i.retail >= -20
    AND CAN-FIND(FIRST b-saletend WHERE b-saletend.link-sale = p-link-sale
                   AND b-saletend.tend-no = 1
                   AND NOT b-saletend.VOID 
                   AND b-saletend.tend-amt < 0)
    AND CAN-FIND(FIRST b-sale WHERE b-sale-i.link-sale = p-link-sale
                   AND b-sale.sale-type = "RN"):
    RETURN YES.
  END.
  RETURN NO.
END FUNCTION.

FUNCTION get-rental-msg RETURNS CHAR(p-linksale AS CHAR):
  DEF BUFFER B-SALE FOR SALE.
  DEF BUFFER B-order FOR order.
  
  FIND b-sale WHERE b-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF AVAIL b-sale THEN DO:
    FIND b-order OF b-sale NO-LOCK NO-ERROR. 
    IF AVAILABLE b-order THEN DO:
      FIND LAST b-sale OF order NO-LOCK NO-ERROR.
      IF b-sale.link-sale = p-linksale
        AND b-order.int-status = "picked up":U THEN DO:
        /* put unformatted  fill("*", 38) at 1 SKIP. */
        IF is-loan(p-linksale) 
          THEN RETURN "***    THIS LOAN IS NOW CLOSED     ***".
        ELSE IF is-leaveout(p-linksale) 
          THEN RETURN "***   THIS CONTRACT IS A LEAVE OUT ***".
        ELSE RETURN "***   THIS RENTAL IS NOW CLOSED    ***".
      END.
    END.
  END.
  RETURN "".
END FUNCTION. 

FUNCTION order-created RETURNS LOG(p-linksale AS CHAR):
  DEF BUFFER B-SALE FOR SALE.
  DEF BUFFER B-order FOR order.
  
  FIND b-sale WHERE b-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF AVAIL b-sale THEN DO:
    FIND b-order OF b-sale NO-LOCK NO-ERROR. 
    FIND FIRST b-sale OF b-order NO-LOCK
      USE-INDEX LO-DT-TT NO-ERROR.
    IF AVAILABLE b-sale 
      AND b-sale.link-sale = p-linksale 
      THEN RETURN YES. 
  END.
  RETURN NO. 
END FUNCTION.

FUNCTION has-rent-buy RETURNS LOG(p-linksale AS CHAR):
  DEF BUFFER B-SALE FOR SALE.
  DEF BUFFER B-SALE-i FOR SALE-i.
  
  FIND b-sale WHERE b-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF AVAIL b-sale THEN DO:
    FOR EACH b-sale-i OF b-sale NO-LOCK
      WHERE NOT b-sale-i.void AND b-sale-i.item-type = "RB":U:
      RETURN YES. 
    END.
  END.
  RETURN NO. 
END FUNCTION. 

FUNCTION has-rent-add RETURNS LOG(p-linksale AS CHAR):
  DEF BUFFER B-SALE FOR SALE.
  DEF BUFFER B-SALE-i FOR SALE-i.
  
  FIND b-sale WHERE b-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF AVAIL b-sale THEN DO:
    FOR EACH b-sale-i OF b-sale NO-LOCK
    WHERE NOT b-sale-i.void AND b-sale-i.item-type = "RP":U
    AND b-sale-i.sku-no < 9999990:
      IF CAN-find(sale-s of b-sale no-lock 
      where sale-s.item-no = b-sale-i.item-no) 
      THEN
        RETURN YES.                                                
    END.
  END.
  RETURN NO. 
END FUNCTION. 

FUNCTION invoice-receipt RETURNS CHAR():
  RETURN "Invoice".
END FUNCTION. 

FUNCTION wide-receipt RETURNS CHAR():
  RETURN "Wide Format".
END FUNCTION. 

FUNCTION long-receipt RETURNS CHAR():
  RETURN "Regular Receipt".
END FUNCTION. 

FUNCTION short-receipt RETURNS CHAR():
  RETURN "Short & Narrow".
END FUNCTION. 

FUNCTION packing-slip RETURNS CHAR():
  RETURN "Packing Slip".
END FUNCTION.

FUNCTION wide-printer RETURNS LOG():
  DEF VAR t-device AS CHAR NO-UNDO.
  DEF VAR t-model  AS CHAR NO-UNDO. 

  RUN login-info.p("rental-printer":u,OUTPUT t-device).
  IF t-device = "terminal":u THEN RETURN YES.
  IF t-device BEGINS "aux":u THEN DO:
    RUN login-info.p(t-device,OUTPUT t-model).
    FIND sysprnt NO-LOCK WHERE sysprnt.model = t-model NO-ERROR.
  END.
  ELSE DO:
    FIND sysdev WHERE sysdev.device-name = t-device NO-LOCK NO-ERROR.
    IF AVAIL sysdev THEN FIND sysprnt OF sysdev NO-LOCK NO-ERROR. 
  END.
  IF AVAIL sysprnt THEN RETURN sysprnt.line-length >= 80.
  RETURN NO.
END FUNCTION.

FUNCTION get-rto-int-rate RETURNS DECIMAL(p-used AS LOG):
  DEF BUFFER b-syscust FOR syscust. 

  FIND b-syscust WHERE b-syscust.TYPE = "rto":U NO-LOCK. 
  RETURN IF p-used THEN b-syscust.dec-flag[2] ELSE b-syscust.dec-flag[1].
END FUNCTION.

FUNCTION get-rto-price RETURNS DECIMAL(p-price AS DEC,p-rate AS DEC
   ,p-used AS LOG
   ,OUTPUT p-num-months AS INT):
  DEF VAR t-int-rate AS DEC NO-UNDO. 
  DEF VAR num-payments-per-year AS INT INIT 12. 
  DEF VAR t-num-months AS DEC NO-UNDO. 
  
  t-int-rate = get-rto-int-rate(p-used) / 100. 
  p-price = p-price - p-rate.  
  t-num-months = -(LOG(1 - (p-price / p-rate) 
    * (t-int-rate / num-payments-per-year))) 
    / log(1 + (t-int-rate / num-payments-per-year)).
  p-num-months = ROUND(t-num-months,0) + 1. 
  RETURN p-rate * p-num-months + p-rate. 
END FUNCTION. 

FUNCTION get-rental-rate RETURNS DEC(p-link-order AS CHAR):
  DEF VAR t-rental-rate AS DEC NO-UNDO.

  ASSIGN t-rental-rate = 0.
  FIND order NO-LOCK
    WHERE order.link-orde = p-link-order NO-ERROR.
  IF AVAILABLE order THEN DO:
    FOR EACH order-i OF order NO-LOCK
      WHERE order-i.item-type = "ri":U
      AND order-i.void = NO:
      ASSIGN t-rental-rate = t-rental-rate + order-i.rent-rate * order-i.qty.
    END.
  END.
  RETURN t-rental-rate.
END FUNCTION.

FUNCTION get-rent-type RETURNS CHAR(p-link-order AS CHAR):
  DEF VAR t-rent-type AS CHAR NO-UNDO.
  DEF VAR t-prefix AS CHAR NO-UNDO.

  ASSIGN t-rent-type ="".
  FIND order NO-LOCK
    WHERE order.link-orde = p-link-order NO-ERROR.
  IF AVAILABLE order THEN DO:
    ASSIGN t-prefix = SUBSTRING(order.order-no,1,2).
    CASE t-prefix:
      WHEN "RN":u THEN ASSIGN t-rent-type = "REGULAR RENT".
      WHEN "RO":U THEN ASSIGN t-rent-type = "RENT TO OWN".
      OTHERWISE DO:
        /* PREFIX = "RS" */
        CASE order.rent-code:
          WHEN "BILLING":U THEN ASSIGN t-rent-type = "SCHOOL MONTHLY".
          WHEN "SCHOOL":U THEN ASSIGN t-rent-type = "SCHOOL YEARLY".
          OTHERWISE ASSIGN t-rent-type = "SEMESTER".
        END CASE.
      END.
    END CASE.
    IF SUBSTRING(order.order-no,1,1) = "N":U THEN t-rent-type = "REGULAR RENT".
  END.
  RETURN t-rent-type.
END FUNCTION.

FUNCTION get-last-unapplied-invoice RETURNS CHAR
  (p-linksale AS CHAR,p-linkorder AS CHAR,OUTPUT p-ls AS CHAR):
  DEF VAR t-invoice# AS CHAR NO-UNDO.

  DEF BUFFER b-sl FOR sale.

  ASSIGN t-invoice# = "".
  FOR EACH b-sl NO-LOCK
    USE-INDEX lo-dt-tt
    WHERE b-sl.link-order = p-linkorder
    AND b-sl.closed = NO
    AND b-sl.link-sale <> p-linksale
    AND b-sl.void = NO
    BY dt-trans DESC
    BY tm-trans DESC:
    IF CAN-FIND(FIRST saletend OF b-sl WHERE saletend.void = NO
                /*
                AND CAN-DO("24,21,22,99",STRING(saletend.tend-no,"99")))
                */
                AND saletend.tend-no = 99)
      THEN DO:
      ASSIGN
        p-ls = b-sl.link-sale
        t-invoice# = TRIM(b-sl.reg-no) + STRING(b-sl.trans-no,"999999":U).
      LEAVE.
    END.
  END.
  RETURN t-invoice#.
END FUNCTION.

  
/* @(#) sale-fnt.i 1.125 11/09/22 @(#) */


FUNCTION SaleHasOnlyReturns RETURNS LOGICAL 
	(INPUT pcLinkSale AS CHARACTER) FORWARD.




/* ************************  Function Implementations ***************** */


FUNCTION SaleHasOnlyReturns RETURNS LOGICAL 
	  (INPUT pcLinkSale AS CHARACTER):

/*----------------------------------------------------------------------------
        Purpose:  Checks if the sale has only returns.
        Notes: Task# 4905
----------------------------------------------------------------------------*/	
  DEFINE VARIABLE lHasOnlyReturns AS LOGICAL INIT TRUE NO-UNDO.
  DEFINE VARIABLE oInv AS CLASS fn.InventoryFunctions NO-UNDO.
  DEFINE BUFFER sale-i FOR sale-i.

  oInv = NEW fn.InventoryFunctions().
  FOR EACH sale-i NO-LOCK 
    WHERE sale-i.link-sale = pcLinkSale
      AND sale-i.item-type <> "RT"
      AND sale-i.qty > 0:
    IF oInv:ShippingSku(sale-i.sku) THEN NEXT.
    lHasOnlyReturns = FALSE.
    LEAVE.
  END.
  DELETE OBJECT oInv.
  RETURN lHasOnlyReturns.
		
END FUNCTION.


FUNCTION writeoff-pay RETURNS LOG(p-linksale AS CHARACTER):
  /* */        
  DEFINE BUFFER bf-sale FOR sale.
  FIND bf-sale WHERE bf-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF NOT AVAILABLE bf-sale THEN RETURN NO. 
  RETURN CAN-FIND(FIRST sale-i OF bf-sale WHERE sale-i.item-type = "pw":U).
END FUNCTION. 

FUNCTION allow-tax-exempt RETURNS LOG(p-linksale AS CHARACTER):
  /* */        
  RETURN NOT writeoff-pay(p-linksale).
END FUNCTION. 

FUNCTION layaway-pickup RETURN LOG(p-linksale AS CHARACTER):
  /* */        

  DEFINE BUFFER bf-sale FOR sale.

  FIND bf-sale WHERE bf-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF NOT AVAILABLE bf-sale THEN RETURN NO. 
  RETURN bf-sale.related-sale = "":U 
    AND CAN-FIND(FIRST sale-i OF bf-sale WHERE sale-i.item-type = "pc":U).
END FUNCTION. 

FUNCTION lywy-deposit RETURN LOG(p-related-sale AS CHARACTER,p-saletype AS CHARACTER):
  /* */        
  RETURN p-saletype = "07":U 
    AND CAN-FIND(FIRST sale-i WHERE sale-i.link-sale = p-related-sale
    AND sale-i.item-type = "PM":U
    AND sale-i.retail <> 0).
END FUNCTION. 

FUNCTION lywy-from-stock RETURNS LOG
  (p-linksale AS CHARACTER,p-linkorder AS CHARACTER,p-st AS CHARACTER):
  DEFINE VARIABLE t-from-stock AS LOG NO-UNDO INIT NO.

  ASSIGN 
    t-from-stock = NO.
  FOR EACH sale-i NO-LOCK
    WHERE sale-i.link-sale = p-linksale:
    /* Check for at least one product from stock on the layaway order */
    IF CAN-FIND(FIRST order-i WHERE order-i.link-order = p-linkorder
      AND order-i.item-no = sale-i.item-no) THEN 
    DO:
      IF NOT CAN-FIND(FIRST sale-order WHERE sale-order.link-sale = p-linksale
        AND sale-order.item-no = sale-i.item-no)
        THEN 
      DO:
        /* got a product with no sale-order, so product must be from stock */
        ASSIGN 
          t-from-stock = YES.
        LEAVE.
      END.
    END.
  END.
  /* LAYAWAY CREATE AND AT LEAST ONE FROM-STOCK PRODUCT */
  RETURN p-st = "07":U AND t-from-stock = YES.
END FUNCTION.

FUNCTION employee-advance RETURNS LOG(p-linksale AS CHARACTER):
  DEFINE BUFFER fb-sale FOR sale.

  FIND fb-sale NO-LOCK
    WHERE fb-sale.link-sale = p-linksale NO-ERROR.
  IF AVAILABLE fb-sale THEN RETURN fb-sale.authorized = "advance":U.
  ELSE RETURN FALSE.
END FUNCTION.

FUNCTION police-info-req RETURNS LOG(p-loc AS CHARACTER):
  /* */    
  /* RETURN CAN-DO("!l070,!l013,!l006,l0*,lp40":U,p-loc). */
  /* 4679: Have cops-info pickup from location table */
  RETURN CAN-FIND(FIRST location WHERE location.loc-code = p-loc
                    AND location.cops-info = YES).
END FUNCTION. 

FUNCTION interest-rebate RETURNS LOG(p-linksale AS CHARACTER):
  /* */        
  DEFINE BUFFER b-sale-i FOR sale-i.
  
  DEFINE VARIABLE t-interest AS LOG NO-UNDO. 
  DEFINE VARIABLE t-other    AS LOG NO-UNDO. 

  FOR EACH b-sale-i NO-LOCK WHERE b-sale-i.link-sale = p-linksale
    AND NOT b-sale-i.void.
    IF b-sale-i.sku-no = 5  THEN t-interest = YES. 
    ELSE t-other = YES. 
  END.
  RETURN (t-other = NO AND t-interest = YES).
END FUNCTION. 

FUNCTION refinance RETURNS LOG(p-link-sale AS CHARACTER):
  /* */        
  DEFINE BUFFER b-sale FOR sale. 
  DEFINE BUFFER bSI    FOR sale-i.

  DEFINE VARIABLE ip-total     AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tSpecialNote AS LOG     NO-UNDO.
  
  FIND b-sale WHERE b-sale.link-sale = p-link-sale 
    NO-LOCK NO-ERROR.

  IF AVAILABLE b-sale THEN 
  DO:
    RUN ps/get-sale-tot.p("total":U,buffer b-sale,OUTPUT ip-total).
    IF ip-total = 0
      AND NOT (b-sale.sale-type BEGINS "0":U OR b-sale.sale-type = "ly":U)
      /* 
      AND NOT CAN-FIND(bSI OF b-sale WHERE sku-no <> 65 
       AND sku-no <> 309557) 
      THEN RETURN YES.
      */ 
    THEN DO: 
      /* IF A SALE-I EXISTS WITH SKU-NO <> 65 NOR 309557 THEN NOT REFINANCE */
      IF CAN-FIND(FIRST bSI OF b-sale WHERE bSI.sku-no <> 65 
        AND bSI.sku-no <> 309557) 
        THEN RETURN NO. 
        ELSE RETURN YES. 
    END. 
  END.
  RETURN NO.
END FUNCTION.

FUNCTION get-ar-tender-list RETURNS CHARACTER(p-deferred AS LOG):
  /* */        
  IF p-deferred THEN RETURN "21,22,24,23,99":U.
  ELSE RETURN "21,22,24,99":U.
END FUNCTION. 

FUNCTION get-next-sale-item RETURNS INTEGER(p-linksale AS CHARACTER):
  /* */        
  DEFINE BUFFER b-sale-i FOR sale-i.
  
  FIND LAST b-sale-i WHERE b-sale-i.link-sale = p-linksale NO-LOCK NO-ERROR.
  RETURN IF AVAILABLE b-sale-i THEN b-sale-i.item-no + 1 ELSE 1.
END FUNCTION. 

FUNCTION get-void RETURNS LOG(BUFFER pb-sale FOR sale):
  /* */        
  IF pb-sale.void THEN 
  DO:
    IF pb-sale.trans-no = pb-sale.void-by THEN RETURN ?.
    ELSE RETURN YES.
  END.
  RETURN NO.
END FUNCTION.

FUNCTION get-ar-return-allow RETURNS LOG(p-custno AS CHARACTER,p-amount AS DECIMAL):
  /* */        
  DEFINE BUFFER b-cust-r FOR customer-r. 
  DEFINE BUFFER b-due    FOR saledue.
  
  FIND b-cust-r WHERE b-cust-r.cust-no = p-custno 
    AND b-cust-r.ar-no = 1 NO-LOCK NO-ERROR. 
  IF AVAILABLE b-cust-r AND b-cust-r.billing-type = "balance forward":U
    THEN RETURN YES.
        
  FOR EACH b-due NO-LOCK
    WHERE b-due.cust-no  = p-custno
    AND b-due.ar-no = 1
    AND b-due.int-status = 'o':U
    AND NOT b-due.void
    AND b-due.balance = p-amount * -1
    /* USE-INDEX cust-ar-dt */:
    RETURN YES.
  END.
  RETURN NO.
END FUNCTION.

FUNCTION cash-refund RETURNS LOG(p-linksale AS CHARACTER):
  DEFINE VARIABLE t-total AS DECIMAL NO-UNDO.
  DEFINE BUFFER bf-sale FOR sale. 
  
  FIND bf-sale WHERE bf-sale.link-sale = p-linksale NO-LOCK NO-ERROR. 
  IF NOT AVAILABLE bf-sale THEN RETURN NO.
/*  IF bf-sale.sale-type = "ly":U THEN RETURN NO. */
  RUN ps/get-sale-tot.p("total":U,buffer bf-sale,OUTPUT t-total).
  RETURN t-total < 0
    AND CAN-FIND(FIRST saletend WHERE saletend.link-sale = p-linksale
    AND NOT saletend.void AND saletend.tend-no = 1).
END FUNCTION.

FUNCTION get-credit-card-sign RETURNS LOG(p-link-sale AS CHARACTER):
  DEFINE BUFFER bf-saletend FOR saletend.
  DEFINE BUFFER bf-sale     FOR sale.
  DEFINE BUFFER bf-tender   FOR tender.
    

  DEFINE VARIABLE t-tot AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-max AS DECIMAL NO-UNDO.
  FIND bf-sale WHERE bf-sale.link-sale = p-link-sale NO-LOCK NO-ERROR. 
  IF AVAILABLE bf-sale THEN 
  DO:
    FOR EACH bf-saletend WHERE bf-saletend.link-sale = p-link-sale
      AND NOT bf-saletend.void
      AND bf-saletend.type <> ".cd":U
      AND bf-saletend.tend-amt > 0:
      FIND bf-tender NO-LOCK
        WHERE bf-tender.tend-no = bf-saletend.tend-no
        AND bf-tender.loc-code = bf-sale.loc-code
        AND bf-tender.credit-card NO-ERROR.
      IF AVAILABLE bf-tender 
        THEN DO:
          /* Task 4207# SignatureRequired values are 
              0 = Signature not required
              1 = Signature required
              2 = Pin Verified, Signature Required
              
            These values are returned by tender retail software */
          IF bf-saletend.SignatureRequired = "0" THEN NEXT. 
          t-tot = t-tot + bf-saletend.tend-amt.
        END.  
    END.
  END.

  RETURN t-tot >= 50.
END FUNCTION.

FUNCTION trade-in-for-loc-sign RETURNS LOG(p-link-sale AS CHARACTER):
  DEFINE BUFFER bf-sale     FOR sale.
 
  FIND bf-sale WHERE bf-sale.link-sale = p-link-sale NO-LOCK NO-ERROR. 
  IF AVAILABLE bf-sale THEN 
  DO:
    /*Only consider pickups or sales*/
    IF (layaway-pickup(p-link-sale) OR bf-sale.sale-type = "SL") AND
    /*Only consider if location's trade-in flag is set to Yes*/
    CAN-FIND(FIRST location OF bf-sale WHERE location.TradeInReceipt) AND
    /*Only consider if item on the transaction is trade-in/inventory purchase*/  
    CAN-FIND(FIRST sale-i OF bf-sale WHERE NOT sale-i.void AND CAN-DO("9,10,11,13",sale-i.reason-code)) THEN
      RETURN TRUE.
  END.
  RETURN FALSE.
END FUNCTION.

FUNCTION signature-required RETURNS LOG
  (p-linksale AS CHARACTER,p-saletype AS CHARACTER,p-loc AS CHARACTER):
  DEFINE BUFFER bf-saletend FOR saletend. 
  DEFINE BUFFER bf-tender   FOR tender. 
  DEFINE BUFFER bf-sale     FOR sale. 
  
  DEFINE VARIABLE t-total     AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-payment   AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE t-signature AS LOG     NO-UNDO.  

  IF p-saletype = 'po':U THEN RETURN NO.
  t-signature = cash-refund(p-linksale) 
    OR get-credit-card-sign(p-linksale)
	/*5904: Check if flag on location is Yes as well as type of sale (Trade-in/Inv Pur)*/
    OR trade-in-for-loc-sign(p-linksale).
  /*
                 or can-find(first sale-pickup 
                             WHERE sale-pickup.link-sale = p-linksale). */
  
  
  IF t-signature = NO THEN 
  DO:
    FOR EACH bf-saletend WHERE bf-saletend.link-sale = p-linksale
      AND bf-saletend.void = NO AND bf-saletend.type <> "cd":U:
      FIND bf-tender NO-LOCK
        WHERE bf-tender.tend-no = bf-saletend.tend-no
        AND bf-tender.loc-code = p-loc NO-ERROR.
      IF AVAILABLE bf-tender AND bf-tender.credit-card = NO
        AND (bf-tender.signature = YES OR bf-tender.signature = ?)
        THEN t-signature = YES.
    END.
  END.
  /*
    IF t-signature THEN DO:
      FIND bf-sale WHERE bf-sale.link-sale = p-linksale NO-LOCK. 
      run ps/get-sale-tot.p("total",buffer bf-sale,output t-total).
      run ps/get-sale-tot.p("payment",buffer bf-sale,output t-payment).
  
      IF (t-total + t-payment) < 0
        AND (t-total + t-payment) > -99.99
        AND (p-saletype = 'cu' OR p-saletype = 'ly')
        THEN ASSIGN t-signature = no.
    END.*/
  RETURN t-signature. 
END FUNCTION.

FUNCTION get-tender-value RETURNS DECIMAL
  (p-link-sale AS CHARACTER,p-value AS DECIMAL,p-tendno AS INTEGER):
  DEFINE BUFFER b-saletend FOR saletend. 
  
  FOR EACH b-saletend FIELDS (b-saletend.tend-amt) 
    WHERE b-saletend.link-sale = p-link-sale 
    AND NOT b-saletend.void
    AND b-saletend.tend-no = p-tendno.
    p-value = p-value + b-saletend.tend-amt.
  END.
  RETURN p-value.
END FUNCTION.
                    
FUNCTION get-cash-in-till RETURNS DECIMAL
  (p-loc AS CHARACTER,p-reg AS CHARACTER,OUTPUT p-float AS DECIMAL):
  DEFINE BUFFER b-sale     FOR sale.
  DEFINE BUFFER b-journal  FOR journal. 
  DEFINE BUFFER b-saletend FOR saletend. 
  
  DEFINE VARIABLE t-cash AS DECIMAL NO-UNDO. 
  
  FIND LAST b-sale WHERE b-sale.loc-code = p-loc
    AND b-sale.reg-no = p-reg NO-LOCK NO-ERROR. 
    
  FIND b-journal OF b-sale NO-LOCK NO-ERROR.
  FOR EACH b-sale OF b-journal NO-LOCK WHERE NOT b-sale.void.
    IF b-sale.sale-type =  "01":U 
      THEN p-float = get-tender-value(b-sale.link-sale,p-float,1).
    ELSE IF b-sale.sale-type = "02":U 
        THEN t-cash = get-tender-value(b-sale.link-sale,t-cash,1).
      ELSE IF NOT b-sale.sale-type BEGINS "0":U 
          THEN t-cash = get-tender-value(b-sale.link-sale,t-cash,1).
  END.
  RETURN t-cash. 
END FUNCTION. 

FUNCTION is-mec-payout-allowed RETURNS LOG(p-pay-no AS INTEGER,p-loc AS CHARACTER):
  RETURN IF CAN-FIND (location WHERE location.loc-code = p-loc
    AND location.gl-sub-acct-mec <> "":U)
    AND CAN-FIND (pay-codes WHERE pay-codes.pay-no = p-pay-no
    AND pay-codes.sub-acct-req = YES
    AND pay-codes.mec-expense-allowed = YES)
    THEN YES ELSE NO.
END FUNCTION.

FUNCTION get-date-store-open RETURNS DATE(p-loc AS CHARACTER):
  DEFINE BUFFER bf-location FOR location. 
  FIND bf-location WHERE bf-location.loc-code = p-loc NO-LOCK NO-ERROR.
  RETURN IF AVAILABLE bf-location THEN bf-location.dt-opened 
  ELSE TODAY.
END FUNCTION.

FUNCTION get-margin RETURNS DECIMAL(p-cost AS DECIMAL,p-retail AS DECIMAL):
  DEFINE VARIABLE t-margin AS DECIMAL NO-UNDO.
  t-margin = (p-retail - p-cost) / p-retail * 100.
  IF t-margin = ? THEN t-margin = 0.
  IF t-margin > 999.99  THEN t-margin = 999.99.
  IF t-margin < -99.99  THEN t-margin = -99.99.
  RETURN t-margin.
END FUNCTION.

FUNCTION sale-invoice-req RETURNS LOG(p-linksale AS CHARACTER):
  DEFINE BUFFER bf-sale FOR sale.         

  FIND bf-sale WHERE bf-sale.link-sale = p-linksale NO-LOCK NO-ERROR. 

  RETURN CAN-FIND(customer-r WHERE customer-r.cust-no = bf-sale.cust-no
    AND customer-r.billing-type = "balance forward":U) 
    AND CAN-FIND(FIRST customer OF bf-sale
    WHERE CAN-DO("corporate,school":U,customer.charge-type) = YES)
    AND (CAN-FIND(FIRST saletend OF bf-sale WHERE NOT saletend.void
    /*Task 2254: Ship To window to appear regardless of the tender type for Rentals*/
    /* AND saletend.tend-no = 99) */
    AND saletend.tend-no = 99) OR bf-sale.sale-type = "rn")
    AND NOT interest-rebate(p-linksale).
END FUNCTION.

FUNCTION duplicate-card RETURNS LOG(p-linksale AS CHARACTER
  ,p-card# AS CHARACTER,p-id# AS INTEGER
  ,p-tendno AS INTEGER):
  DEFINE BUFFER bf-saletend FOR saletend.
  DEFINE BUFFER bfSale      FOR sale.
  DEFINE BUFFER bfTender    FOR tender.

  IF p-linksale = "":u THEN RETURN NO.
  /* Check for Duplicate Credit Cards only (DO NOT INCLUDE DEBIT CARDS) */
  FIND bfSale NO-LOCK
    WHERE bfSale.link-sale = p-linksale.
  FIND bfTender NO-LOCK
    WHERE bfTender.loc-code = bfSale.loc-code
    AND bfTender.tend-no = p-tendno NO-ERROR.
  IF NOT AVAILABLE bfTender
    OR (AVAILABLE bfTender AND bfTender.credit-card = NO)
    THEN RETURN NO.

  p-card# = REPLACE(p-card#,"-":U,"":U).
  p-card# = REPLACE(p-card#," ":U,"":U).
  FOR EACH  bf-saletend NO-LOCK
    WHERE bf-saletend.link-sale = p-linksale
    AND bf-saletend.void = NO
    AND bf-saletend.tend-no = p-tendno :
    IF REPLACE(REPLACE(bf-saletend.tend-id[p-id#],"-":U,"":U)," ":U,"":U) = p-card#
      THEN RETURN YES.
  END.
  RETURN NO.
END FUNCTION.

FUNCTION isCardSale RETURNS LOGICAL (pLinkSale AS CHARACTER,
  INPUT-OUTPUT pLineNo AS INTEGER):
  DEFINE VARIABLE tCardSale AS LOGICAL NO-UNDO.

  DEFINE BUFFER bST FOR saletend.

  ASSIGN 
    tCardSale = NO.
  FOR EACH bST NO-LOCK
    WHERE bST.link-sale = pLinkSale
    AND bST.void = NO:
    IF CAN-DO("3,4,5,39,40":U,STRING(bST.tend-no)) THEN
    DO:
      ASSIGN
        tCardSale = YES
        pLineNo   = bST.line-no.
      LEAVE.
    END.
  END.
  RETURN tCardSale.
END FUNCTION.

FUNCTION isNonRefundShip RETURNS LOGICAL (pSku AS INTEGER):
  DEFINE BUFFER bSC FOR syscust.
  
  FIND bSC NO-LOCK
    WHERE bSC.type = "ORD":U.
  RETURN bSC.int-flag[01] = pSku.
END FUNCTION.

FUNCTION GetNonRefundShipSku RETURNS INTEGER (OUTPUT pRate AS DECIMAL):
  DEFINE BUFFER fbSC FOR syscust.

  FIND fbSC NO-LOCK
    WHERE fbSC.type = "ORD":U.
  ASSIGN 
    pRate = fbSC.dec-flag[01].
  RETURN fbSC.int-flag[01].
END FUNCTION.

FUNCTION HstTaxCode RETURNS LOG(pCode AS CHARACTER,pDate AS DATE) : 
  DEF VAR cTaxCodes AS CHAR NO-UNDO.
  /* As of 04/01/2013, BC will discontinue HST and follow PST. PEI will now 
     be part of HST as of 04/01/2013 */
  IF pDate >= 7/1/2010 THEN
  DO: 
      cTaxCodes = IF pDate >= 04/01/2013 
                    THEN "east,on,ns,pei"
                    ELSE "east,on,bc,ns".
      RETURN CAN-DO(cTaxCodes, pCode).    
      /*RETURN CAN-DO("east,on,bc,ns":U,pcode).*/
  END.
  ELSE RETURN pCode = "east,ns":U. 
END FUNCTION. 

/*4493*/
FUNCTION IsShipOrderSale RETURNS LOGICAL
  (pLinkSale AS CHARACTER):
  DEFINE BUFFER bSale FOR sale.
  FIND bsale WHERE bSale.link-sale = pLinkSale NO-LOCK NO-ERROR.
  
  IF AVAIL bsale THEN RETURN CAN-FIND(FIRST order OF bsale WHERE order.sale-type = "ST").
END FUNCTION.

FUNCTION is-hst RETURNS LOG(pLinkSale AS CHARACTER) : 
  DEFINE BUFFER bSale-i FOR sale-i. 
  DEFINE BUFFER bSale FOR sale. 
  DEFINE BUFFER bLocation FOR location. 
    
  DEFINE VARIABLE tHst AS LOG NO-UNDO.   
  DEFINE VARIABLE x AS INT NO-UNDO.
   
  /*4493*/
  FIND bsale WHERE bSale.link-sale = pLinkSale NO-LOCK NO-ERROR. 
  IF AVAIL bsale AND NOT IsShipOrderSale(pLinkSale) THEN DO: 
    FIND bLocation OF bSale NO-LOCK.
    DO x = 1 TO NUM-ENTRIES(blocation.TAX-COLLECT,"/"): 
      IF HstTaxCode(ENTRY(x,blocation.TAX-COLLECT,"/"),bsale.DT-TRANS) 
        THEN RETURN YES.
    END.
  END. 
  
  FOR EACH bSale-i WHERE bSale-i.link-sale = pLinkSale 
    AND bsale-i.ITEM-TYPE = "tx":U NO-LOCK: 

    IF HstTaxCode(bSale-i.reason-code,bsale-i.DT-TRANS) THEN RETURN YES. 
  END.
  RETURN NO. 
   
END FUNCTION. 

FUNCTION GenGiftPassword RETURNS CHARACTER():
  DEFINE VARIABLE x       AS INTEGER   NO-UNDO.
  DEFINE VARIABLE tChar   AS CHARACTER 
    INIT "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890".
  DEFINE VARIABLE tPass   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE tlength AS INTEGER   NO-UNDO.

  DO x = 1 TO 5:
    tlength = LENGTH(tchar).
    tPass = tPass + substring(tChar,RANDOM(1,tlength),1).
  END.
  RETURN tPass.
END FUNCTION. 

FUNCTION isARSale RETURNS LOGICAL (pLinkSale AS CHARACTER): 
  RETURN CAN-FIND(FIRST sale WHERE sale.link-sale = pLinkSale 
                  AND sale.ar-no = 1 
                  AND sale.void = NO). 
END FUNCTION. 

FUNCTION GetDepositMessage RETURNS LOGICAL 
  (BUFFER pS FOR sale, OUTPUT pPrtMess AS CHARACTER): 
  DEFINE VARIABLE tMsgLoc AS CHARACTER NO-UNDO. 

  DEFINE BUFFER fbS FOR sale. 
  DEFINE BUFFER fbSI FOR sale-i. 
  DEFINE BUFFER fbL FOR location. 

  IF AVAILABLE pS 
    AND pS.School <> YES 
    AND pS.sale-type = "LY" 
    AND NOT CAN-FIND(FIRST fbSI OF pS WHERE fbSI.CanRefundDeposit = YES) THEN 
  DO: 
    FIND fbS NO-LOCK
      WHERE fbS.link-sale = pS.related-sale NO-ERROR. 
    IF AVAILABLE fbS THEN 
    DO: 
      IF fbS.sale-type = "07" THEN 
      DO: 
        FIND fbL OF fbS NO-LOCK NO-ERROR. 
        ASSIGN tMsgLoc = IF AVAILABLE fbL AND fbL.LanguageCode = "FRENCH" 
          THEN "lz99" ELSE "". 
        FIND messages NO-LOCK 
          WHERE messages.msg-name = "SODeposit" 
          AND messages.loc-code = tMsgLoc NO-ERROR. 
        ASSIGN 
          pPrtMess = IF AVAILABLE messages THEN messages.msg-text ELSE "". 
      END. 
    END. 
  END. 
  RETURN FALSE. /* FUNCTION RETURN VALUE */ 
END FUNCTION. 

FUNCTION GetReturnsCharge RETURNS LOGICAL 
  (INPUT  pOrigSaleLink   AS CHARACTER,    // original sale link
   INPUT  pOrigSaleItem   AS INTEGER,      // original sale link
   INPUT  pPricePaid      AS DECIMAL,      // original price
   INPUT  pDate6MthsAfter AS DATE,         // 6 months after the original transaction date
   INPUT  pHoldRetail     AS DECIMAL,      // hold retail
   INPUT  pProdCategory   AS INTEGER,      // product category   
   INPUT  pRetNo          AS INTEGER,      // return reason number
   OUTPUT pReturnCharge   AS DECIMAL, 
   OUTPUT pNRPercent      AS INTEGER ): 
   
  //MESSAGE  pOrigSaleLink pOrigSaleItem pPricePaid pDate6MthsAfter pHoldRetail pProdCategory pRetNo VIEW-AS ALERT-BOX.
  // LX72-158110048 1 129 08/07/22 0 0 3
  
  DEFINE VARIABLE tDaysSold       AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tWeeksSold      AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tMonth          AS INTEGER NO-UNDO. 
  DEFINE VARIABLE tRestockPercent AS DECIMAL NO-UNDO.
  DEFINE VARIABLE lGracePeriod    AS LOG     NO-UNDO.
  DEFINE VARIABLE iGraceDays      AS INTEGER NO-UNDO.
  DEFINE VARIABLE dMinPercent     AS DECIMAL NO-UNDO.
 
  DEFINE BUFFER fbS FOR sale.
  DEFINE BUFFER fbsi FOR sale-i.

  /**
  RETURN charge is calculated based on the number of days the customer 
  retained the product/item.

  If the item was originally sold as used or demo, or is being exchanged
  then use a different return percentage

  We are using variable tRestockPercent to calculate and setting 
  to either 1% or 0.5% depending on the criteria below

  Time Period         Return charges                     Return Charges (used/demo/exch)
  -----------         --------------                     -------------------------------
 
  Less than 35 days   No return charges                  No return charges

    *** if the customer has a frequent returns setting then the 35 days
         can be overridden to a lower number of days ***

  36 - 45 days        starting at 6% to 15%              starting at 5.5% to 10%
                      1% of retail value/day             0.5% of retail value/day
                          No return charges for new returns under 50$ (syscust)
  
  45 days - 1 year    1% of retail value/week            1% of retail value/week

  1 year and above    1% of retail value/month           1% of retail value/month
 
  **/
  
  /* find original sale */
  FIND fbS NO-LOCK WHERE fbS.link-sale = pOrigSaleLink. 
  FIND fbsi NO-LOCK OF fbS WHERE fbsi.item-no = pOrigSaleItem NO-ERROR.
  ASSIGN 
    tDaysSold = TODAY - fbS.dt-trans.
    
  /* originally purchased as used or demo or customer is exchanging */
  /* if the sale was on ar then use the lower rate as well */ 
  IF LOOKUP(fbsi.used-flag,"u,d") > 0 
  OR LOOKUP(STRING(pRetNo),"18,19,23") > 0
  OR isARSale(pOrigSaleLink)
  THEN
    tRestockPercent = 0.5.
  ELSE
    tRestockPercent = 1.

  //MESSAGE "original sale settings" fbsi.retrn-chrg-str VIEW-AS ALERT-BOX.

/* when sold to AR default the grace period to 3 days instead of 35 */
  iGraceDays = IF isARSale(pOrigSaleLink) THEN 3 ELSE 35.
  dMinPercent = 0.

  /* if the employee has set a specific return charge for the product */
  IF fbsi.retrn-chrg-str <> "" THEN DO:
    /* each item can have the grace period set to YES or NO                      */
    /* if yes, then there are no special return settings                         */
    /* if no, the employee will set the minimum restocking fee % for the item    */
    lGracePeriod = LOGICAL(REPLACE(ENTRY(2,fbsi.retrn-chrg-str),"graceperiod=","")) NO-ERROR.
    
    /* if the grace period is YES or NO then set the grace days to 35 (yes) or 0 (no) */
    iGraceDays   = IF lGracePeriod THEN 35 ELSE 0.
    
    /* dMinPercent is checked after the calculation and is used if calculated is less */
    /* if the grace period is no then the min percent should default to 0 */
    IF lGracePeriod = NO THEN
      dMinPercent  = INTEGER(REPLACE(ENTRY(3,fbsi.retrn-chrg-str),"minpercent=","")) NO-ERROR.
    
    
    /* when financed                                                               */
    /* if the employee has set the grace period to YES then 3 grace days           */
    /* if the employee has set the grace period is NO then 0 grace days            */
    iGraceDays = IF isARSale(pOrigSaleLink) AND lGracePeriod THEN 3 ELSE 0. 
 
    /* if financed and no grace period and no min % set */
    /* the min% is set to 2% otherwise the min% is 0 per the ar return chart */
    IF isARSale(pOrigSaleLink) 
    AND lGracePeriod = NO 
    AND dMinPercent = 0 THEN
    dMinPercent = 2.
    
    /* if exchanged adjust the min percent */
    IF LOOKUP(STRING(pRetNo),"18,19,23") > 0 THEN 
    dMinPercent = 2.
  END.
  
  /* iGraceDays dMinPercent */
  //iGraceDays = 20. /* number of days grace for returns */ 
  //dMinPercent = 0. //50. /* minimum return percent */

  /*** manual override for testing ***/
  // pPricePaid = 100.
  // tDaysSold = 35.
  // pDate6MthsAfter = TODAY + tDaysSold + 6 * 30.
  // tRestockPercent = 0.5 . /* 1 or 0.5 */

  //MESSAGE "days sold=" tDaysSold "restocking=" tRestockPercent "grace days=" iGraceDays "min%=" dMinPercent "ar sale=" isARSale(pOrigSaleLink) VIEW-AS ALERT-BOX.

  /* if number of days is <= 35 check if the customer has a grace period */
  /* the grace period can be from 0 to 35 days where 0 days is no grace  */
  /* and 35 days is default grace period */
  IF tDaysSold <= 35 THEN DO:
  
    /* sold for longer than the grace period */ 
    IF tDaysSold >= iGraceDays THEN DO:       
      /* originally sold as new */
      /* if sold as new then the restocking is 5% for 0 to 35 days */
      IF tRestockPercent = 1 THEN
        ASSIGN
          pReturnCharge = ((pPricePaid * 5) / 100).
      /* sold as used/demo or is exchanging 1 to 7 days */
      ELSE IF tDaysSold < 8 THEN
        ASSIGN
          pReturnCharge = ((pPricePaid * 2) / 100).
      /* sold as used/demo or is exchanging 8 to 14 days */
      ELSE IF tDaysSold < 15 THEN
        ASSIGN
          pReturnCharge = ((pPricePaid * 3) / 100).
      /* sold as used/demo or is exchanging 15 to 21 days */
      ELSE IF tDaysSold < 22 THEN
        ASSIGN
          pReturnCharge = ((pPricePaid * 4) / 100).
      /* sold as used/demo or is exchanging 22 to 35 days */
      ELSE
        ASSIGN
          pReturnCharge = ((pPricePaid * 4) / 100).   
   
    END.
    ELSE
    /* either tDaysSold = 0 or less than grace days */
    /* as grace days start at 1 day */
      ASSIGN
        pReturnCharge = 0.          
  END.
  ELSE DO: 
    /* 35 - 45 Days, the return charge is 1% or 0.5% per day 
                     (where tRestockPercent = 1 or 0.5)
           Example:  Retail value: $100
                     Days sold: 42 days
                     Minimum charge: 100 * 5/100 = 5
                     Return charge: 100 * ((42 - 35) / 100) 
                                    = 100 * .7 
                                    = 5 + 7
                                    = 12

                     If originally sold as used/demo or is being exchanged
                     tRestockPercent = 0.5 the total return charge would be 8.5%
                     minimum 5% + 7 days * 0.5 per day = 5% + 3.5% = 8.5%
    
    */
    IF tDaysSold <= 45 THEN DO:
      
      // for any days after 35 days, there is a minimum 5% restocking fee
      pReturnCharge = ((pPricePaid * 5) / 100).
              
      /*8276: Return New under 50$(syscust) NO Restocking under 45 days*/
      IF pRetNo = 3 THEN DO:
      
        // IF < 45 days and returning to new and the original price paid IS <= 50 then dont charge restocking
        FIND FIRST syscust WHERE syscust.type = "pos" AND DEC-LABEL[4] <> "" NO-LOCK NO-ERROR.
        IF pPricePaid <= (IF AVAIL syscust THEN syscust.DEC-FLAG[4] ELSE 50) THEN
          pReturnCharge = 0.
        ELSE 
          pReturnCharge = pReturnCharge + ((pPricePaid * tRestockPercent) / 100) * (tDaysSold - 35).
      END.
      ELSE 
        ASSIGN 
          pReturnCharge = pReturnCharge + ((pPricePaid * tRestockPercent) / 100) * (tDaysSold - 35).

    END.
    ELSE DO: 
      /* Up to 45 days, the return charge is 1% / day or 0.5% / day. 
       After we cross 45 days, we have to first account for the initial 15 day period */

      // for any days after 35 days, there is a minimum 5% restocking fee
      pReturnCharge = ((pPricePaid * 5) / 100). 

      IF tDaysSold <= 365 THEN DO:  
        ASSIGN 
        pReturnCharge = pReturnCharge + ((pPricePaid * tRestockPercent) / 100) * (45 - 35).            
        /* After the return charge for 10 days is calculated, 
           we find the return charge for the remaining weeks */                    

        tWeeksSold = TRUNCATE((tDaysSold - 45) / 7 , 0).
                
        /* The weeks need to be rounded up when it is a decimal value 
           indicating extra days. 
           Example : tWeeksSold = 16.42 will become tWeeksold = 17*/

       /* IF ((tDaysSold - 45) / 7) - tWeeksSold <> 0 THEN 
        ASSIGN 
          tWeeksSold = tWeeksSold + 1.*/
           
          /* Return charge is calculated by adding the return charge for
             15 days (30-45 days-1%/day or 5%/day ) with the return charge for the 
             remaining weeks ( 1%/week) */
                         
          ASSIGN 
            pReturnCharge = pReturnCharge + (((pPricePaid * 1) / 100) * tWeeksSold).

      END. /* IF tDaysSold <= 365 */    
    END. /* IF tDaysSold <= 45 */
  END. /* tDaysSold > 30 */ 
 
 
  // MESSAGE "calculated return charges" pReturnCharge VIEW-AS ALERT-BOX. 

  /*7868 -Return rate charge for 1 year and above - 1% of retail value /month*/     
  IF tDaysSold > 365 THEN DO: 
  
    /* up to one year the restocking fee is 60% if purchased as new     */
    /* or 55% if purchased as used/demo or the customer is exchanging   */
    /* use the restocking percentage to determine which                 */
    IF tRestockPercent = 1.0 THEN     
      pReturnCharge = (pPricePaid * 60) / 100.
    ELSE 
      pReturnCharge = (pPricePaid * 55) / 100.
  
    /* find the number of days after one year */
    tDaysSold = tDaysSold - 365.
    
    IF tDaysSold >= 30 THEN DO :                
      tMonth = TRUNCATE( tDaysSold / 30,0). 
   
      /* Return rate charge for months, 1%/month */       
      IF tMonth > 0 THEN 
        ASSIGN 
          pReturnCharge = pReturnCharge + (((pPricePaid * 1) / 100) * tMonth). 
    END.  
  END.
  
  /* check the minimum restocking amount assigned to the customer at time of sale */
  /* if this minimum amount is greater than calculated use the minium amount */    
    
 
  
  IF (pPricePaid * dMinPercent) / 100 > pReturnCharge THEN
  pReturnCharge = (pPricePaid * dMinPercent) / 100 .
  //pNRPercent = ?? /* dont think we need TO SET this */
  
  /* ONLY WHEN NON REFUNDABLE DEPOSIT IS GREATER */  
  // example pHoldRetail = 25.5 and pReturnCharge = 58.65
  // the hold retail is 10% of the selling @ 255.50 = 25.50
  // and the non-refundable charge calculates to 58.65 based on number of days etc
  // the customer charge would be the greater of the two or 58.65
  //MESSAGE "pHoldRetail" pHoldRetail "pReturnCharge" pReturnCharge VIEW-AS ALERT-BOX.
  IF pHoldRetail > pReturnCharge THEN 
  /* pNRPercent = non refundable deposit percentage */
  ASSIGN
    pReturnCharge = pHoldRetail
    pNRPercent = IF pProdCategory = 2 THEN 10       // hardcoded
                 ELSE IF pProdCategory = 3 THEN 25  // hardcoded
                 ELSE 0.
                 
  // if the calculated pHoldRetail is greater then the returned pNRPercent = 0
  // as it did not apply in this case
  //MESSAGE "766 FINAL" pHoldRetail pReturnCharge pNRPercent VIEW-AS ALERT-BOX.      
  RETURN FALSE. /* FUNCTION RETURN VALUE */ 
END FUNCTION. 


FUNCTION GetRCMessage RETURNS LOGICAL 
  (INPUT pCustomerReturnCharge AS CHARACTER,    // customer return penalty setting
   INPUT pSaleDate AS DATE,                     // original transaction date
   INPUT pU AS DECIMAL,                         // original price
   INPUT pOrigSaleLink AS CHARACTER,            // original sale link
   INPUT pOrigSaleItem AS INTEGER,              // original sale item
   INPUT pDate6MthsAfter AS DATE,               // 6 months AFTER the original transaction date
   INPUT pHoldRetail AS DECIMAL,                // hold retail 
   INPUT pProdCategory AS INTEGER,              // product category
   INPUT pCurrentSaleLink AS CHAR,              // current sale link
   OUTPUT pCustomerReturnChargeAmount AS DECIMAL,
   INPUT-OUTPUT pCustomerReturnChargeMess AS CHARACTER, 
   INPUT-OUTPUT pNREFCharge AS DECIMAL,
   INPUT pRetNo AS INTEGER):   
   
  DEFINE VARIABLE tDaysOD AS INTEGER NO-UNDO. 
  DEFINE VARIABLE tDaysOver30 AS INTEGER NO-UNDO. 
  DEFINE VARIABLE t30DR AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tO30DR AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tNumWeeks AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tODCharge AS DECIMAL NO-UNDO. 
  DEFINE VARIABLE tNRPercent AS INTEGER NO-UNDO.
  DEFINE VARIABLE tEndDate AS DATE NO-UNDO. 
   
  ASSIGN 
    // limit the return period TO 6 months from original purchase date
    tEndDate = IF pDate6MthsAfter > TODAY THEN TODAY ELSE pDate6MthsAfter
    pCustomerReturnChargeAmount = 0 
    // number of days between sale date and the end date
    tDaysOD = tEndDate - pSaleDate
    // number of days over 30
    tDaysOver30 = tDaysOD - 30
    // number of weeks over 30 days
    tNumWeeks = TRUNCATE(tDaysOver30 / 7,0)
    tODCharge = 0 
    pCustomerReturnChargeMess = "". 

  /*   
    ex. 
    original date 
    6 month date = 1/10/2022
    tEndDate = today as 6 month date is greater
    82 days between sale date and today - this would limit to 6 months
    52 days over 30
    tnumweeks = 7
    MESSAGE tEndDate tDaysOD tDaysOver30 tNumWeeks VIEW-AS ALERT-BOX. 
  */

  /* ADD A WEEK FOR ANY EXTRA DAYS */
  IF (tDaysOver30 / 7) - tNumWeeks <> 0 THEN ASSIGN tNumWeeks = tNumWeeks + 1. 
 
 /*
  CASE pCustomerReturnCharge: 
    WHEN "A" THEN 
      ASSIGN pCustomerReturnChargeMess = "10% MINIMUM CHARGE FOR 30 DAYS " + 
                       "PLUS 2% PER WEEK AFTER THAT." 
      t30DR = 10 
      tO30DR = 2. 
    WHEN "B" THEN 
      ASSIGN pCustomerReturnChargeMess = "15% MINIMUM CHARGE FOR 30 DAYS " + 
                       "PLUS 3% PER WEEK AFTER THAT." 
      t30DR = 15 
      tO30DR = 3. 
    WHEN "D" THEN 
      ASSIGN pCustomerReturnChargeMess = "PLEASE CONTACT MANAGER TO DISCUSS " + 
                       "FREQUENT RETURNS WITH CUSTOMER" 
      t30DR = 0 
      tO30DR = 0.
    OTHERWISE
      ASSIGN 
      pCustomerReturnChargeMess = "" 
      t30DR = 0
      tO30DR = 0. 
  END CASE. 

  IF pCustomerReturnCharge = "D" OR pCustomerReturnChargeMess = "" THEN
    // there are no special return charges for the customer
    // so calculate the standard return charges
         GetReturnsCharge(pOrigSaleLink,       // original sale link
                          pOrigSaleItem,       // original sale item
                          pU,                  // original price
                          pDate6MthsAfter,     // 6 months AFTER the original transaction date
                          pHoldRetail,         // hold retail based on product category
                          pProdCategory,       // product category
                          pRetNo,              // return reason number
                          OUTPUT tODCharge,
                          OUTPUT tNRPercent). 
  ELSE 
  DO:    
    // there is a charge for all returns and no grace period

    // calculate the fee for the first 30 days 
    ASSIGN
      tODCharge = ROUND((pU * t30DR) / 100,2).
    
    // IF more than 30 days
    IF tDaysOver30 > 0 THEN 
    DO: 
      // IF the extra TIME IS less than a week, APPLY one week
      IF tDaysOver30 < 7 THEN 
        ASSIGN 
          tODCharge = tODCharge + ROUND((pU * tO30DR) / 100,2). 
      // if the extra time is more than a week, calculate for the number of weeks    
      ELSE 
        ASSIGN 
          tODCharge = tODCharge + ROUND(((pU * tO30DR) / 100) * tNumWeeks,2). 
    END.    
  END.
  */
  
   GetReturnsCharge(pOrigSaleLink,       // original sale link
                  pOrigSaleItem,       // original sale item
                  pU,                  // original price
                  pDate6MthsAfter,     // 6 months AFTER the original transaction date
                  pHoldRetail,         // hold retail based on product category
                  pProdCategory,       // product category
                  pRetNo,              // return reason number
                  OUTPUT tODCharge,
                  OUTPUT tNRPercent). 

  // tODCharge is the calculated return charge
  IF tODCharge <> 0 THEN DO:
    ASSIGN 
    pCustomerReturnChargeAmount = tODCharge.  
     
    IF pHoldRetail >= tODCharge THEN
      ASSIGN 
        pNREFCharge = pHoldRetail
        pCustomerReturnChargeAmount = pHoldRetail
        pCustomerReturnChargeMess = IF tNRPercent <> 0 THEN
            "RE-STOCKING FEE OF " + TRIM(STRING(tNRPercent)) + "% PLUS TAX APPLIES TO THIS RETURN."
          ELSE
            "RE-STOCKING FEE OF $" + TRIM(STRING(pCustomerReturnChargeAmount,"->>,>>9.99")) + " PLUS TAX APPLIES TO THIS RETURN.".
    ELSE IF pHoldRetail < tODCharge THEN
      ASSIGN 
        pNREFCharge = tODCharge
        pCustomerReturnChargeAmount = tODCharge
        pCustomerReturnChargeMess = 
            "RE-STOCKING FEE OF $" + TRIM(STRING(pCustomerReturnChargeAmount,"->>,>>9.99")) + " PLUS TAX APPLIES TO THIS RETURN.".
  END.    
  
  RETURN FALSE. /* FUNCTION RETURN VALUE */ 
END FUNCTION.

FUNCTION isPersonal RETURNS LOGICAL(pCust# AS CHARACTER):
  DEFINE VARIABLE tPersonal AS LOGICAL NO-UNDO. 

  DEFINE BUFFER fbCust FOR customer. 

  FIND fbCust NO-LOCK 
    WHERE fbCust.cust-no = pCust# NO-ERROR.
  ASSIGN tPersonal = IF AVAILABLE fbCust AND fbCust.charge-type = "personal" 
/*    AND fbCust.discount-level <> 1 */ 
/* discount level 1 should be school only */
    THEN YES ELSE NO.
  RETURN tPersonal. /* FUNCTION RETURN VALUE */ 
END FUNCTION. 

FUNCTION manual-card-manager-prompt RETURNS LOG(p-linksale AS CHARACTER):
       
  DEFINE BUFFER bf-sale FOR sale.
  DEFINE BUFFER bf-customer FOR customer.
  DEFINE BUFFER syscust FOR syscust.
  DEFINE VAR tTotal AS DECIMAL NO-UNDO.
  DEFINE VAR tDate AS DATE NO-UNDO.
  DEFINE VARIABLE oDF AS CLASS fn.date-fnt.
  DEFINE VARIABLE oWeb AS CLASS web.WebFunctions NO-UNDO.
  DEFINE VARIABLE lIsWebLoc AS LOGICAL NO-UNDO.
  
  /* INT-FLAG[2] = MANUAL CARDS MANAGER PROMPT MIN AMOUNT          100
     INT-FLAG[3] = MANUAL CARDS FIRST TRANSACTION MONTHS             6 */
  FIND FIRST syscust 
    WHERE syscust.type = "cus1" 
      AND syscust.INT-FLAG[2] > 0 
      AND syscust.INT-FLAG[3] > 0 NO-LOCK NO-ERROR.
  
  FIND bf-sale WHERE bf-sale.link-sale = p-linksale NO-LOCK NO-ERROR.
  IF NOT AVAILABLE bf-sale THEN RETURN NO. /* Proceed without prompt if no sale*/
  
  RUN ps/get-sale-tot.p ("TOTAL", BUFFER bf-sale, OUTPUT tTotal).
 
  oDF = NEW fn.date-fnt(). 
  FIND FIRST bf-customer OF bf-sale NO-LOCK NO-ERROR.
  IF AVAIL bf-customer 
    THEN tDate = oDF:add-months(bf-customer.fst-dt,
        (IF AVAIL syscust THEN syscust.INT-FLAG[3] ELSE 6)).
  IF VALID-OBJECT(oDF) THEN DELETE OBJECT oDF.
  
  oWeb = NEW web.WebFunctions().
  lIsWebLoc = oWeb:WebLocation(bf-sale.loc-code).
  IF VALID-OBJECT(oWeb) THEN DELETE OBJECT oWeb.
  
  
  RETURN (((bf-sale.sale-type = "LY" AND NOT lIsWebLoc)
          /*5684: Include lessons payments i.e "pl"*/
          OR (bf-sale.sale-type = "SL" AND 
          NOT CAN-FIND(FIRST sale-i OF bf-sale 
            WHERE LOOKUP(sale-i.item-type,"pm,pl") <> 0 )))
          AND tTotal > (IF AVAIL syscust THEN syscust.INT-FLAG[2] ELSE 100)
          AND (tDate > TODAY OR tDate = ?)). /*tDate = ? New Customer AS WELL AS Regular Sale*/
END FUNCTION. 




/*------------------------------------------------------------------------------
  File:
    im/pricing.i
    
  Description:
    It runs the pricing program as persistent and does all the pricing

    clear-pricing()     - clears the variables before a new call 

    destroy-pricing()   - call this when exiting your program to destroy 
                          the instants of im/pricing.p 

    get-cust-disc       - returns the customers discount which should 
                          be store in the sale-i.mkdn-amt field. 

    get-date-last-price - returns the effective date of the last price 
                          that you requested. 

    get-new-cust-price  - returns the customer price after the discount. To 
                          get the before price add the get-cust-disc() value.
                          PARAMETERS REQUIRED:
                          INPUT p-sku AS INTEGER
                          INPUT p-loc AS CHARACTER,
                          INPUT p-promo AS LOGICAL,
                          INPUT p-custno AS CHARACTER
           
    get-new-price       - gets the price for a sku. 
                          This is the a ame as im/get-price.p 
                          PARAMAETERS REQUIRED:
                          INPUT p-sku AS INTEGER
                          INPUT p-loc AS CHARACTER
                          INPUT p-promo AS LOGICAL
                   
    get-price-type      - returns the type of the last price. 
                          (eg. "S" for store and blank for regular) 

    get-dual-price      - returns a logical of whether this product should 
                          have a bar code price separate from the selling 
                          price. 

                          PARAMAETERS REQUIRED:
                          INPUT p-currency AS character
                          INPUT p-group    AS integer

    get-bc-loc          - returns the location code that is used for the 
                          bar code price record 
    
  Syntax:
    {im/pricing.i} 
     
  Input Parameters:
    <none>

  Output Parameters:
    <none>

  Input-Output Parameters:
    <none>
                
  History:
------------------------------------------------------------------------------*/

DEF VAR ph-rental-fnt AS HANDLE NO-UNDO.
RUN fn/rental1.p PERSISTENT SET ph-rental-fnt.
THIS-PROCEDURE:ADD-SUPER-PROCEDURE (ph-rental-fnt).
ph-rental-fnt:PRIVATE-DATA = THIS-PROCEDURE:FILE-NAME + ",":U
                           + STRING(THIS-PROCEDURE:HANDLE).
                        
/*
 * Prototype include file: H:\dw039\fn\rentprto.i
 * Created from procedure: H:\dw039\fn\rental1.p at 13:08 on 09/11/06
 * by the PROGRESS PRO*Tools Prototype Include File Generator
 */

PROCEDURE destroy IN SUPER:
END PROCEDURE.

FUNCTION get-contract RETURNS CHARACTER
  (INPUT p-serial AS CHARACTER,
   INPUT p-sku AS INTEGER,
   OUTPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION rental-mult RETURNS DECIMAL
  (INPUT p-yearly AS LOGICAL) IN SUPER.

FUNCTION is-rto RETURNS LOGICAL
  (INPUT p-link-order AS CHARACTER) IN SUPER.

FUNCTION is-loan RETURNS LOGICAL
  (INPUT p-link-sale AS CHARACTER) IN SUPER.

FUNCTION is-a-loan RETURNS LOGICAL
  (INPUT p-linkorder AS CHARACTER) IN SUPER.

FUNCTION is-leaveout RETURNS LOGICAL
  (INPUT p-link-sale AS CHARACTER) IN SUPER.

FUNCTION movement RETURNS LOGICAL
  (INPUT p-link-sale AS CHARACTER) IN SUPER.

FUNCTION rental-out-movement RETURNS LOGICAL
  (INPUT p-link-sale AS CHARACTER) IN SUPER.

FUNCTION get-rental-msg RETURNS CHARACTER
  (INPUT p-linksale AS CHARACTER) IN SUPER.

FUNCTION order-created RETURNS LOGICAL
  (INPUT p-linksale AS CHARACTER) IN SUPER.

FUNCTION has-rent-buy RETURNS LOGICAL
  (INPUT p-linksale AS CHARACTER) IN SUPER.

FUNCTION invoice-receipt RETURNS CHARACTER IN SUPER.

FUNCTION wide-receipt RETURNS CHARACTER IN SUPER.

FUNCTION long-receipt RETURNS CHARACTER IN SUPER.

FUNCTION short-receipt RETURNS CHARACTER IN SUPER.

FUNCTION wide-printer RETURNS LOGICAL IN SUPER.

FUNCTION get-rto-int-rate RETURNS DECIMAL
  (INPUT p-used AS LOGICAL) IN SUPER.

FUNCTION get-rto-price RETURNS DECIMAL
  (INPUT p-price AS DECIMAL,
   INPUT p-rate AS DECIMAL,
   INPUT p-used AS LOGICAL,
   OUTPUT p-num-months AS INTEGER) IN SUPER.

FUNCTION get-rental-rate RETURNS DECIMAL
  (INPUT p-link-order AS CHARACTER) IN SUPER.

FUNCTION get-rent-type RETURNS CHARACTER
  (INPUT p-link-order AS CHARACTER) IN SUPER.

FUNCTION is-holiday RETURNS LOGICAL
  (INPUT p-date AS DATE,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-first-day-of-year RETURNS DATE
  (INPUT p-year AS INTEGER) IN SUPER.

FUNCTION get-last-day-of-month RETURNS DATE
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-first-day-of-month RETURNS DATE
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-week-start RETURNS DATE
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-first-day-of-month1 RETURNS DATE
  (INPUT p-year AS INTEGER,
   INPUT p-month AS INTEGER) IN SUPER.

FUNCTION get-num-bus-days RETURNS INTEGER
  (INPUT p-from-date AS DATE,
   INPUT p-to-date AS DATE,
   INPUT p-loc-code AS CHARACTER) IN SUPER.

FUNCTION get-num-days-in-month RETURNS INTEGER
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-long-str-month RETURNS CHARACTER
  (INPUT p-month AS INTEGER) IN SUPER.

FUNCTION get-short-str-month RETURNS CHARACTER
  (INPUT p-month AS INTEGER) IN SUPER.

FUNCTION get-long-str-day RETURNS CHARACTER
  (INPUT p-weekday AS INTEGER) IN SUPER.

FUNCTION get-long-str-date RETURNS CHARACTER
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-long-str-date-weekday RETURNS CHARACTER
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-short-str-date RETURNS CHARACTER
  (INPUT p-date AS DATE) IN SUPER.

FUNCTION get-short-str-day RETURNS CHARACTER
  (INPUT p-weekday AS INTEGER) IN SUPER.

FUNCTION conv-hour-to-sec RETURNS INTEGER
  (INPUT p-time AS DECIMAL) IN SUPER.

FUNCTION conv-sec-to-hour RETURNS DECIMAL
  (INPUT p-time AS INTEGER) IN SUPER.

FUNCTION add-months RETURNS DATE
  (INPUT p-date AS DATE,
   INPUT p-months AS INTEGER) IN SUPER.

FUNCTION months-between-dates RETURNS LOGICAL
  (INPUT p-from-date AS DATE,
   INPUT p-to-date AS DATE,
   INPUT p-round AS CHARACTER,
   INPUT-OUTPUT p-months AS INTEGER) IN SUPER.

FUNCTION allow-zero RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION assign-locmas-qty RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-field AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-doc AS CHARACTER) IN SUPER.

FUNCTION cartage-revenue RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION DESCRIPTION-REQUIRE RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION effect-inv RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION ext-warr-avail RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-used AS LOGICAL) IN SUPER.

FUNCTION get-auto-order RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-physical AS LOGICAL) IN SUPER.

FUNCTION get-first-received RETURNS DATE
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-hast-qty RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-last-cust-price RETURNS DECIMAL
  (INPUT p-cust-no AS CHARACTER,
   INPUT p-serial# AS CHARACTER) IN SUPER.

FUNCTION get-new-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-physical AS LOGICAL,
   OUTPUT p-date AS DATE) IN SUPER.

FUNCTION get-order-freq RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-qty-on-repair RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-qty-onhand RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER) IN SUPER.

FUNCTION get-rglr-warranty RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-used AS LOGICAL,
   INPUT p-serial AS CHARACTER,
   INPUT p-return AS LOGICAL) IN SUPER.

FUNCTION get-safety RETURNS DECIMAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-section-description RETURNS CHARACTER
  (INPUT p-section-id AS INTEGER) IN SUPER.

FUNCTION get-sku-desc RETURNS CHARACTER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-warranty-charge RETURNS DECIMAL
  (INPUT p-retail AS DECIMAL,
   INPUT p-months AS INTEGER,
   INPUT p-yorkville AS LOGICAL,
   INPUT p-used AS LOGICAL,
   INPUT p-sku AS INTEGER,
   INPUT p-qty AS INTEGER) IN SUPER.

FUNCTION get-warranty-sku RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION GIFT RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION id-labels RETURNS INTEGER
  (INPUT p-option-code AS CHARACTER,
   OUTPUT p-label1 AS CHARACTER,
   OUTPUT p-label2 AS CHARACTER,
   OUTPUT p-label3 AS CHARACTER,
   OUTPUT p-label4 AS CHARACTER,
   OUTPUT p-label5 AS CHARACTER,
   OUTPUT p-label6 AS CHARACTER) IN SUPER.

FUNCTION insurance RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-active RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-generic RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-gift-card-package RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-lessons RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-on-order RETURNS LOGICAL
  (INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION is-package RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION is-print-music RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION no-dash RETURNS CHARACTER
  (INPUT p-product AS CHARACTER) IN SUPER.

FUNCTION no-oh RETURNS CHARACTER
  (INPUT p-serial-no AS CHARACTER) IN SUPER.

FUNCTION on-order RETURNS CHARACTER IN SUPER.

FUNCTION on-transfer RETURNS CHARACTER IN SUPER.

FUNCTION RETAIL-REQUIRE RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION serial-req RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-used AS LOGICAL) IN SUPER.

FUNCTION short-id-labels RETURNS INTEGER
  (INPUT p-option-code AS CHARACTER,
   OUTPUT p-label1 AS CHARACTER,
   OUTPUT p-label2 AS CHARACTER,
   OUTPUT p-label3 AS CHARACTER,
   OUTPUT p-label4 AS CHARACTER,
   OUTPUT p-label5 AS CHARACTER,
   OUTPUT p-label6 AS CHARACTER) IN SUPER.

FUNCTION special-note RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION to-follow RETURNS CHARACTER IN SUPER.

FUNCTION unknown-serial RETURNS CHARACTER IN SUPER.

FUNCTION upd-locmas-qty RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-field AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-doc AS CHARACTER) IN SUPER.

FUNCTION upd-warranty-sale-i RETURNS LOGICAL
  (INPUT p-link AS CHARACTER,
   INPUT p-item AS INTEGER) IN SUPER.

FUNCTION update-onlywy RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-qty AS DECIMAL,
   INPUT p-used AS LOGICAL,
   INPUT p-serial AS CHARACTER,
   INPUT p-reason AS CHARACTER,
   INPUT p-doc AS CHARACTER,
   INPUT p-effect-onhand AS LOGICAL) IN SUPER.

FUNCTION valid-option-code RETURNS LOGICAL
  (INPUT p-option-code AS CHARACTER) IN SUPER.

FUNCTION yorkville-manufacture RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION yorkville-product RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION ysl-sub-std-avail RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION clear-pricing RETURNS LOGICAL IN SUPER.

FUNCTION destroy-pricing RETURNS LOGICAL IN SUPER.

FUNCTION get-bc-loc RETURNS CHARACTER IN SUPER.

FUNCTION get-cust-disc RETURNS DECIMAL IN SUPER.

FUNCTION get-date-last-price RETURNS DATE IN SUPER.

FUNCTION get-dual-price RETURNS LOGICAL
  (INPUT p-currency AS CHARACTER,
   INPUT p-group AS INTEGER) IN SUPER.

FUNCTION get-new-bc-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL) IN SUPER.

FUNCTION get-new-cost1 RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-physical AS LOGICAL) IN SUPER.

FUNCTION get-new-cust-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL,
   INPUT p-custno AS CHARACTER,
   INPUT p-arsale AS LOGICAL) IN SUPER.

FUNCTION get-new-price RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-promo AS LOGICAL) IN SUPER.

FUNCTION get-price-type RETURNS CHARACTER IN SUPER.

FUNCTION is-customer-a-employee RETURNS LOGICAL
  (INPUT p-custno AS CHARACTER) IN SUPER.

FUNCTION is-customer-a-school RETURNS LOGICAL
  (INPUT p-custno AS CHARACTER) IN SUPER.

FUNCTION is-on-promo RETURNS LOGICAL
  (INPUT p-sku# AS INTEGER,
   INPUT p-start-dt AS DATE,
   INPUT p-end-dt AS DATE) IN SUPER.

FUNCTION get-rglr-warranty-rental RETURNS INTEGER
  (INPUT p-sku AS INTEGER,
   INPUT p-new AS LOGICAL,
   INPUT p-serial AS CHARACTER,
   INPUT p-dt-rented AS DATE) IN SUPER.

FUNCTION is-warranty-sku RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION rental-allowed RETURNS LOGICAL
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION destroy-locsrl-val RETURNS LOGICAL IN SUPER.

FUNCTION get-cost-at RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION get-current-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-current-retail RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-orig-cost RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-orig-retail RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER) IN SUPER.

FUNCTION get-retail-at RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER,
   INPUT p-date AS DATE) IN SUPER.

FUNCTION set-locsrl RETURNS LOGICAL
  (INPUT p-sku AS INTEGER,
   INPUT p-serial AS CHARACTER,
   INPUT p-retail AS LOGICAL) IN SUPER.

FUNCTION get-min-sell-depr RETURNS DECIMAL 
  (INPUT pSku AS INTEGER,
   INPUT pDemo AS LOG,
   INPUT pDemoCat AS CHARACTER) IN SUPER.

FUNCTION get-recovery-months RETURNS INTEGER
  (INPUT p-sku AS INTEGER) IN SUPER.

FUNCTION get-rent-rate-30 RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-serial-no AS CHARACTER) IN SUPER.

FUNCTION get-rent-rate-days RETURNS DECIMAL
  (INPUT p-sku AS INTEGER,
   INPUT p-loc AS CHARACTER,
   INPUT p-serial-no AS CHARACTER,
   INPUT p-days AS INTEGER) IN SUPER.

FUNCTION get-rental-rates-inv-rent RETURNS LOGICAL
  (INPUT p-sku# AS INT, 
   INPUT p-loc AS char, 
   OUTPUT p-rn-rate AS DEC,
   OUTPUT p-rs-rate AS DEC, 
   OUTPUT p-ro-rate AS DEC) IN SUPER.

FUNCTION destroy-rental-fnt RETURNS LOGICAL IN SUPER.


FUNCTION destroy-rental-fnt RETURNS LOG():
  /* destory */
  IF VALID-HANDLE(ph-rental-fnt) 
    THEN RETURN SUPER ().
  RETURN NO.
END FUNCTION. 
{ps/tbl-ord-lywy.i new}
/* @(#) string.i 1.11 12/29/21 @(#) */
FUNCTION is-num RETURNS LOG(p-string AS CHAR):
  /* */
  def var i as int no-undo.
  do i = 1 to length(p-string,"character":U):
    if index("0123456789().":U,substring(p-string,i,1,"character":U)) = 0
      then RETURN NO.
  end.
  RETURN YES.
end function.

FUNCTION is-special-char RETURNS LOG(p-string AS CHAR):
  /* */
  DEF VAR t-x   AS INT NO-UNDO.

  DO t-x = 01 TO LENGTH(p-string,"character":U):

    IF INDEX("0123456789":U,SUBSTRING(p-string,t-x,1,"character":U)) = 0
      AND INDEX("ABCDEFGHIJKLMNOPQRSTUVWXYZ":U,SUBSTRING(p-string,t-x,1,"character":U)) = 0
      THEN RETURN NO.
  END.
  RETURN YES.
END FUNCTION.

FUNCTION str2dec RETURNS dec(p-string AS CHAR):
  /* */
  IF NOT is-num(p-string) THEN DO:
    MESSAGE p-string "IS NOT a number.":T
      VIEW-AS ALERT-BOX ERROR.
    RETURN 0.0.
  END.
  RETURN DECIMAL(p-string).
end function.

FUNCTION add-list RETURNS LOG
  (p-delimiter as CHAR
  ,INPUT-OUTPUT p-list AS CHAR
  ,p-item AS CHAR):
  /* */
  if p-delimiter = "" then p-delimiter = ",":U.
  p-list = p-list + (IF p-list = "" THEN "" ELSE p-delimiter) + p-item.
END FUNCTION.

FUNCTION str-just RETURNS CHAR (p-just AS CHAR,p-length AS INT,p-str AS CHAR):
  /* ss/strjust.p - this is a string justification program
    p-just   - right,left or center
    p-length - is the length of the field
    p-str    - is the variable to justify
    */
  p-str = trim(p-str).
  
  if p-just = "right":U then p-str = fill(" ":U,p-length - length(p-str,"character":U)) + p-str.
  if p-just = "left":U then p-str = trim(p-str).
  /*
  if p-just = "center":U then p-str = fill(" ":U,int((p-length - length(p-str,"character":U)) / 2))
                                  + p-str.
  */
  /*IF ODD NUMBER OF BLANK SPACES, GIVE EXTRA SPACE TO THE RIGHT SIDE, INSTEAD OF LEFT */
  IF p-just = "center":U THEN
  DO:
    IF (p-length - length(p-str)) MODULO 2 = 0 then 
      p-str = fill(" ":U,int((p-length - length(p-str,"character":U)) / 2)) + p-str.
    ELSE 
      p-str = fill(" ":U,int((p-length - length(p-str,"character":U)) / 2) - 1) + p-str.    
  END.
  RETURN p-str.
END FUNCTION.

function wrap RETURNS handle(p-length AS INT,p-warp AS CHAR,p-flags AS CHAR):
  /* */
  DEF VAR t-handle AS HANDLE NO-UNDO.
  run ss/wraper.p PERSISTENT set t-handle(p-length,p-warp,p-flags).
  RETURN t-handle.
end function.

DEF VAR t-wrap-handle AS HANDLE NO-UNDO. 

FUNCTION get-next-line-wrap RETURNS 
   /* */
 CHAR(OUTPUT p-more AS LOG,OUTPUT p-new-line AS LOG) IN t-wrap-handle.
FUNCTION DESTROY RETURNS LOG() IN t-wrap-handle.
  

FUNCTION get-next-line RETURNS CHAR
  (p-handle AS HANDLE,OUTPUT p-more as LOG,OUTPUT p-new-line AS LOG):
  /* */
  t-wrap-handle = p-handle.
  RETURN get-next-line-wrap(p-more,p-new-line).
END function.

FUNCTION object-destroy RETURNS log(p-handle AS HANDLE):
  /* */
  t-wrap-handle = p-handle.
  RETURN destroy().
END FUNCTION.

FUNCTION time-to-str RETURNS CHAR(p-time AS int,p-loc AS CHAR):
  /* p-loc is for future use. This will allow us to show times in different 
     time zones */ 
  RETURN STRING(p-time,"HH:MM:SS am":U).
END FUNCTION.


/* {custProtect.i} */

FUNCTION hasProtect RETURNS log(pOrder as CHAR,pCust as CHAR) FORWARD.
        /*** Validate this Contract has an Open Protection Record **/
FUNCTION hadProtect RETURNS log(pOrder as CHAR,pCust as CHAR) FORWARD.
        /*** find last closed Protection Record **/
Function startDateProtect Returns date(pOrder as CHAR, pCust as CHAR) FORWARD.
        
Function getProtect Returns recid(pOrder as CHAR, pCust as CHAR) FORWARD.
   /*** Return recid for valid cust-protect record if it exists ****/

Function validAmt Returns log(input pAmt as Dec) FORWARD.
     /* The amount is rounded to a dollar */
Function setProtectAmt RETURNS DEC(pOrder as CHAR,pCust as CHAR,pDate as Date) FORWARD. 

Function gstProtect Returns dec(pLoc as Char, pAmt as DEC) FORWARD. 
Function pstProtect Returns dec(pLoc as Char, pAmt as DEC) FORWARD.  
  
  /* Creates or updates existing record **/
Function assignProtect RETURNS log
   (pOrder as CHAR,pCust as CHAR, pAmt as dec) FORWARD.

Function calcProtectAmt Returns DEC(pStart as DATE, pEnd as Date) FORWARD.
Function setEndDtProtect RETURNS Date(pStart as Date,pAmt as DEC) FORWARD.

Function closeProtect RETURNS log(pOrder as CHAR,pCust as CHAR) FORWARD.

/* ------------------------------------------------------------------- */
 
form
  cust-protect.dt-start form "99/99/9999" space(03)
  cust-protect.dt-end   form "99/99/9999" space(03)
  cust-protect.dt-close form "99/99/9999" skip(01)
  cust-protect.current-amt form "->>>>.99"  space(03)
  cust-protect.flag-protect                 space(03)
  cust-protect.order-no  form "x(08)"       space(03)
  cust-protect.cust-no   form "x(08)"       space(03)
  tReviewed  as char format "x(01)"
  with frame fr-custProtect no-labels no-attr-space row 11 width 40 col 10 
  title "Current Protection" overlay.
      
procedure displayProtect:
  define input parameter pOrder like order.order-no.
  def input parameter pCust like order.cust-no. 
  find last cust-protect no-lock where cust-protect.order-no = pOrder
    and cust-protect.cust-no = pCust 
    and cust-protect.flag-protect = yes no-error.
  display cust-protect.dt-start cust-protect.dt-end cust-protect.dt-close
  cust-protect.current-amt cust-protect.flag-protect cust-protect.order-no
  cust-protect.cust-no tReviewed with frame fr-custProtect. 
  enable tReviewed with frame fr-custProtect. 
  apply "entry" to tReviewed in frame fr-custProtect. 
  pause 0 no-message. 
  wait-for any-key of tReviewed in frame fr-custProtect. 
  disable all with frame  fr-custProtect.
  hide frame fr-custProtect no-pause. 
  return. 
END Procedure. 


FUNCTION hasProtect RETURNS log(pOrder as CHAR,pCust as CHAR):
  /* found a number of cases where customer merge did not update cust-protect*/
  if can-find(last cust-protect where cust-protect.flag-protect = yes
    and cust-protect.cust-no = pCust
    and cust-protect.order-no = pOrder) then return yes. 
  else return no. 
End. 
FUNCTION hadProtect RETURNS log(pOrder as CHAR,pCust as CHAR):
  /* found a number of cases where customer merge did not update cust-protect*/
  if can-find(last cust-protect where cust-protect.flag-protect = no
    and cust-protect.cust-no = pCust
    and cust-protect.order-no = pOrder) then return yes.
    else return no.
  End.
Function startDateProtect Returns date(pOrder as CHAR, pCust as CHAR):
  def var startDate as Date init ? no-undo. 
  Find last cust-protect no-lock where cust-protect.flag-protect = yes
    and cust-protect.cust-no = pCust
    and cust-protect.order-no = pOrder no-error.
  if avail cust-protect then startDate = cust-protect.dt-start. 
  return startDate.                 
END. 

Function closeDateProtect Returns date(pOrder as CHAR, pCust as CHAR):
  def var closeDate as date init ? no-undo. 
  if not hasProtect(pOrder,pCust) then 
  Find last cust-protect no-lock where cust-protect.flag-protect = no
    and cust-protect.cust-no = pCust
    and cust-protect.order-no = pOrder no-error.
  if avail cust-protect then return cust-protect.dt-close.
  else return closeDate.
end.
Function endDateProtect Returns date(pOrder as CHAR, pCust as CHAR):
  def var endDate as date init ? no-undo. 
  if hasProtect(pOrder,pCust) then 
    Find last cust-protect no-lock where cust-protect.flag-protect = yes
      and cust-protect.cust-no = pCust
      and cust-protect.order-no = pOrder no-error.
  if avail cust-protect then return cust-protect.dt-end.
  else return endDate.
end.


Function getProtect Returns recid(pOrder as CHAR, pCust as CHAR):
  /*** Return recid for valid cust-protect record if it exists ****/
  def var t-rec as recid init ? no-undo. 
  if hasProtect(pOrder,pCust) then do: 
    Find last cust-protect no-lock where cust-protect.flag-protect = yes
      and cust-protect.cust-no = pCust
      and cust-protect.order-no = pOrder no-error.
      if avail cust-protect then t-rec = recid(cust-protect). 
  end. 
  RETURN t-rec.
end.

Function validAmt Returns log(input pAmt as Dec):
  if pAmt < 0 then RETURN NO. 
  if (pAmt * 100) mod 100 <> 0 then RETURN NO.
  RETURN YES. 
end. 

Function getChgAmt Returns int(pStart as DATE):
  DEFINE VAR chgAmt as dec no-undo. 
  if pStart < 12/01/2007 then RETURN 3.
  RETURN 4.
END. 
Function gstProtect Returns dec(pLoc as Char, pAmt as DEC):
  /* ploc must be order.loc-code or location.loc-code or customer.loc-code */  
  def var p1Tax as dec no-undo. 
  find first inv-tax no-lock where inv-tax.sku-no = 23
    and inv-tax.tax-code = "gst" no-error.
  if avail inv-tax then return 0.  
  FIND tax NO-LOCK WHERE tax.tax-code = "gst" no-error.
   if avail tax then do:
     p1Tax = round(tax.rate / 100,2).
     return round(pAmt * p1Tax,2). 
  end.
  return 0.
END.
Function pstProtect Returns dec(pLoc as CHAR, pAmt as DEC):
  /* ploc must be order.loc-code or location.loc-code or customer.loc-code */
  def var tList as char no-undo. 
  def var p2Tax as dec no-undo. 
  DEF VAR end-char AS INT NO-UNDO.
  def var taxcode as char no-undo.
  find location no-lock where location.loc-code = pLoc no-error. 
  find inv-tax no-lock where inv-tax.sku-no = 23 
    and inv-tax.tax-code = location.loc-code no-error. 
  if avail inv-tax then return 0.   
  run ps/charge-tax.p
  (pLoc
    ,""
    ,""
    ,output tList).
    end-char = INDEX(tList, "/").
    if end-char = 0 then return 0.
    taxcode = SUBSTR(tList, end-char + 1).
    FIND tax NO-LOCK WHERE tax.tax-code = taxcode no-error.
    if avail tax then do: 
      p2Tax = round(tax.rate / 100,2).
      return round(pAmt * p2Tax,2).  
    end. 
   return 0.
end. 

Function calcProtectAmt Returns DEC(pStart as DATE, pEnd as Date):
  DEF var pAmt as dec init 0 no-undo. 
  DEFINE VAR tDiv as int no-undo.
  DEF var tDays as int no-undo. 
  def var z as int no-undo. 
  tDiv = getChgAmt(pStart).
  run effectdays.p(pStart, pEnd, output tDays).
  if tDays >= 0 then do:
       /* FOR THIS TO BE CORRECT pStart must be protection record start */
    if tDays <= 30 then return tDiv.  /* first month */
    z = tDays.
    loopxa: repeat on error undo loopxa, leave loopxa:
      tDays = tDays - 1.
      if tDays mod 30 = 0 then
        leave loopxa.
    end. 
    pAmt = (tDays / 30) * tDiv. /* gets the months */
    z = z - tDays.      /* remaining days */
    if tDiv = 4 then do:
        if z <= 7 then pAmt = pAmt + 1.
        else if z <= 14 then pAmt = pAmt + 2.
        else if z <= 21 then pAmt = pAmt + 3.
        else pAmt = pAmt + tDiv. 
    end.
    else if tDiv = 3 then do: /* < 12/01/2007 only by month */
       pAmt = pAmt + 3.
    end.
  end. 
  return pAmt.
End Function. 

Function setProtectAmt RETURNS DEC(pOrder as CHAR,pCust as CHAR,pDate as Date):
      /* TOTALS THE AMOUNT COLLECTED FOR THIS RECORD FROM SALES HISTORY **/
      /* sales start with last valid record for contract. pDate could be
      the start of the contract or startdate of protection record  */
  def buffer bsale for sale.
  DEF var tAmt as dec init 0 no-undo. 
  IF hasProtect(pOrder,pCust) then do:
    find order no-lock where order.order-no = pOrder 
      and order.cust-no = pCust no-error. 
    if pDate = ? then pDate = startDateProtect(pOrder,pCust).
    
    if avail order then do:   
      for each bsale of order no-lock where not bsale.void 
        AND bsale.dt-trans >= pDate,
        each sale-i of bsale no-lock where sale-i.item-type = "rb" 
        and not sale-i.void and (sale-i.sku-no = 28 or sale-i.sku-no = 23):
        tAmt = tAmt + sale-i.retail.
      end.
    end. 
  end. 
  return tAmt. 
end.

Function setEndDtProtect RETURNS Date(pStart as Date,pAmt as DEC):
  DEFINE VAR pNewDue as date no-undo.
  DEFINE VAR tDiv as int no-undo. 
  DEFINE VAR X AS INT NO-UNDO. 
  DEFINE VAR numWeeks as int no-undo. 
  pNewDue = pStart. 
  
  if pAmt = 0 then return pNewDue. /* nothing has been collected */
  tDiv = getChgAmt(pStart).  /* tDiv is either 3 or 4, depends on start date */
  if pAmt < tDiv then numWeeks = int(pAmt). 
  else do:
   DO X = 0 TO (tDiv - 1):
     if int(pAmt - X) mod tDiv = 0 then do:
       run loopFindNextDueDate.p(pStart,(pAmt / tDiv), output pNewDue).
       numWeeks = X. 
     end. 
   END.
   if tDiv = 4 then 
     pNewDue = pNewDue + (7 * numWeeks).
   else pNewDue = pNewDue + (10 * numWeeks).
  end.  
  return pNewDue. 
END. 

FUNCTION rollBackProtect Returns log(pSale as recid):
/*
  DEFINE BUFFER pbSale for sale. 
  find pbSale no-lock where recid(pbSale) = pSale no-error.
  if avail pbSale then 
    find order of pbSale no-lock no-error.
  if avail order then 
    find customer of order no-lock no-error. 
  if avail customer and hasProtect(order.order-no, order.cust-no) 
   then do:
      if validOrder(order.order-no, order.cust-no).
   end. 
  */
End.

Function updateProtect RETURNS log(pOrder as Char, pCust as Char,
     pAmt as DEC, EndDate as DATE):
      /* Internal procedure only. valid current amount and date IS SET */
  Find cust-protect exclusive-lock
    where cust-protect.order-no = pOrder and cust-protect.cust-no = pCust
    and cust-protect.flag-protect = yes no-wait no-error.
  if avail cust-protect then do: 
    ASSIGN 
      cust-protect.current-amt = pAmt
      cust-protect.dt-end = EndDate.
    release cust-protect. 
    return yes. 
  end.
  return NO. 
End Function. 

Function assignProtect RETURNS log(pOrder as CHAR,pCust as CHAR, pAmt as dec):
  /* Creates or updates existing record **/
  def var currAmt as dec no-undo. 
  def var endDate as date no-undo. 
  DEFINE VAR pDate as date no-undo. 
  if not validAmt(pAmt) then return NO. 
  
  if not hasProtect(pOrder,pCust) then do:
    create cust-protect.
    ASSIGN 
    cust-protect.dt-start = today
    cust-protect.dt-end   = today
    cust-protect.flag-protect = yes 
    cust-protect.cust-no  = pCust
    cust-protect.order-no = pOrder
    cust-protect.current-amt = pAmt .
    endDate = setEndDtProtect(cust-protect.dt-start,pAmt).
    IF updateProtect(pOrder,pCust,pAmt,endDate) then return yes.
    else return no.
  end.
  else do:
    Find cust-protect no-lock 
      where cust-protect.order-no = pOrder and cust-protect.cust-no = pCust
      and cust-protect.flag-protect = yes no-error. 
    if avail cust-protect then do:  
      assign
        pDate   = cust-protect.dt-start
        currAmt = setProtectAmt(pOrder,pCust,pDate)
        pAmt = pAmt + currAmt
        endDate = setEndDtProtect(cust-protect.dt-start,pAmt).
      IF updateProtect(pOrder,pCust,pAmt,endDate) then return yes.
      else return no. 
    end. 
  end.
  return NO. 
end.


Function closeProtect RETURNS log(pOrder as CHAR,pCust as CHAR):
  DEFINE VAR custRec as recid no-undo. 
  if hasProtect(pOrder,pCust) then DO:
    custRec = getProtect(pOrder,pCust).
    Find cust-protect exclusive-lock
       where recid(cust-protect) = custRec no-error.
    if avail cust-protect then do:
      assign 
        cust-protect.dt-close = today 
        cust-protect.flag-protect = no. 
      release cust-protect. 
      return yes. 
    end.
  END. 
  return no. 
end.
{vlocsrl.i new}
{ttInvLocsrl.i new}
DEFINE VARIABLE oiSrl AS CLASS server.services.beLocSrl. 

FUNCTION serial-on-transfer RETURNS LOG(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE lSuccess AS LOGICAL NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial). 
  lSuccess = oiSrl:OnTransfer().
  DELETE OBJECT oiSrl.
  RETURN lSuccess. 
END FUNCTION. 

FUNCTION on-layaway RETURNS LOG(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE lSuccess AS LOGICAL NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial). 
  lSuccess = oiSrl:OnLayaway().
  DELETE OBJECT oiSrl.
  RETURN lSuccess. 
END FUNCTION. 

FUNCTION on-rent RETURNS LOG(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE lSuccess AS LOGICAL NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  lSuccess = oiSrl:OnRent().
  DELETE OBJECT oiSrl.
  RETURN lSuccess. 
END FUNCTION.

FUNCTION on-hold RETURNS LOG(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE lSuccess AS LOGICAL NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  lSuccess = oiSrl:OnHold().
  DELETE OBJECT oiSrl.
  RETURN lSuccess. 
END FUNCTION.
        
FUNCTION on-repair RETURNS LOG
  (pSerial AS CHAR,pSku AS INT,pOrderNo AS CHAR):
  DEFINE VARIABLE lSuccess AS LOGICAL NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  lSuccess = oiSrl:OnRepair(pOrderNo).
  DELETE OBJECT oiSrl.
  RETURN lSuccess. 
END FUNCTION. 

FUNCTION get-status RETURNS CHAR(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE cStatus AS CHARACTER NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  cStatus = oiSrl:GetStatus().
  DELETE OBJECT oiSrl.
  RETURN cStatus. 
END FUNCTION.
                                
FUNCTION get-dt-first-rented RETURN DATE(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE tDate AS DATE NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  tDate = oiSrl:DateFirstRented().
  DELETE OBJECT oiSrl.
  RETURN tDate. 
END FUNCTION.

FUNCTION get-last-purchase RETURN DATE(pSerial AS CHAR,pSku AS INT):
  DEFINE VARIABLE tDate AS DATE NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  tDate = oiSrl:LastPurchase().
  DELETE OBJECT oiSrl.
  RETURN tDate. 
END FUNCTION.

FUNCTION get-default-date-code RETURN CHAR
  (pSerial AS CHAR,pSku AS INT,pLocSrlCheck AS LOG):
  DEFINE VARIABLE cDateCode AS CHARACTER NO-UNDO.
  oiSrl = NEW server.services.beLocSrl(pSku,pSerial).  
  cDateCode = oiSrl:DefaultDateCode(pLocSrlCheck).
  DELETE OBJECT oiSrl.
  RETURN cDateCode.  
END FUNCTION.

FUNCTION get-date-code6 RETURNS CHAR(pIn AS CHAR):
  DEFINE VARIABLE cDate AS CHARACTER NO-UNDO.
  DEFINE VARIABLE oDate AS CLASS shared.fn.DateFunctions NO-UNDO.
  oDate = NEW shared.fn.DateFunctions(). 
  cDate = oDate:GetLongDateCode(pIn).
  DELETE OBJECT oDate.
  RETURN cDate.
END FUNCTION.

FUNCTION get-datecode RETURNS CHAR(pIn AS DATE):
  DEFINE VARIABLE cDateCode AS CHARACTER NO-UNDO.
  DEFINE VARIABLE oDate AS CLASS shared.fn.DateFunctions NO-UNDO.
  oDate = NEW shared.fn.DateFunctions(). 
  cDateCode = oDate:DateToDateCode(pIn).
  DELETE OBJECT oDate.
  
  RETURN cDateCode. 
END FUNCTION.

FUNCTION get-date-for-datecode RETURNS DATE(pIn AS CHAR):
  DEFINE VARIABLE tDate AS DATE NO-UNDO.
  DEFINE VARIABLE oDate AS CLASS shared.fn.DateFunctions NO-UNDO.
  oDate = NEW shared.fn.DateFunctions(). 
  tDate = oDate:DateCodeToDate(pIn).
  DELETE OBJECT oDate.
  
  RETURN tDate. 
END FUNCTION. 
/*-----------------------------------------------------------------------------
  File:
    fn/InvNotes.i

  Description:
    FUNCTIONS FOR TABLE inv-notes.

  Syntax:
    {fn/InvNotes.i}

  Input Parameters:
    <none>

  Output Parameters:
    <none>

  Input-Output Parameters:
    <none>

  History:
-----------------------------------------------------------------------------*/
CREATE WIDGET-POOL.

FUNCTION GetInvNotes RETURNS CHAR (pSku AS INT,pType AS CHAR):
  FOR EACH inv-notes NO-LOCK
    USE-INDEX Key1
    WHERE inv-notes.sku-no = pSku
    AND inv-notes.type = pType
    AND inv-notes.DtStart <= TODAY
    AND inv-notes.DtEnd >= TODAY
    BY inv-notes.DtStart DESC BY inv-notes.DtEnd:
    LEAVE.
  END.
  RETURN IF AVAILABLE inv-notes THEN inv-notes.notes ELSE "".
END FUNCTION.

DEFINE VARIABLE oMsg   AS CLASS ss.MessageButtons     NO-UNDO.
DEFINE VARIABLE myCalc AS CLASS fn.FinancialFunctions NO-UNDO.
DEFINE VARIABLE myrent AS CLASS fn.RentalFunctions    NO-UNDO.

oMsg = NEW ss.MessageButtons().
myCalc = NEW fn.FinancialFunctions().
myrent = NEW  fn.RentalFunctions().

/* ************************** Variable Declarations ************************* */

/* @(#) rndefines-1.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rndefines-1.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

DEFINE VARIABLE t-totint       AS DECIMAL. /* need rent-owed calc A/R saletend */
DEFINE VARIABLE test-rs-regtot AS LOG     NO-UNDO. /* used for programmer testing. */
DEFINE INPUT PARAMETER s-link-order LIKE order.link-order.
DEFINE INPUT PARAMETER t-funct-name AS CHARACTER.
DEFINE OUTPUT PARAMETER t-made-rental AS LOG NO-UNDO.

DEFINE            VARIABLE t-hold          AS LOG       NO-UNDO.
DEFINE            VARIABLE t-holdit        AS LOG       INIT NO NO-UNDO.
DEFINE            VARIABLE is-unravel      AS LOG       NO-UNDO.
DEFINE            VARIABLE t-order-no      LIKE order.order-no NO-UNDO.
DEFINE            VARIABLE t-allprotect    AS LOG       NO-UNDO.  /* close protection record */
DEFINE            VARIABLE tz-endkey       AS LOG       NO-UNDO.  /* rto error key */

DEFINE            VARIABLE p-auth          AS CHARACTER NO-UNDO.
DEFINE            VARIABLE gwkreg          AS CHARACTER FORMAT "x(4)" .
DEFINE            VARIABLE t-tot2          AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE t-total         AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE t-month         AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE p-newdate       AS DATE      NO-UNDO.
DEFINE            VARIABLE s-deposit       AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE s-dt-return     AS DATE      FORMAT "99/99/9999" NO-UNDO.
DEFINE            VARIABLE t-loc-code      LIKE location.loc-code.
DEFINE            VARIABLE t-empl-id       LIKE employee.empl-no.
DEFINE            VARIABLE t-holdEmpl      LIKE employee.empl-no.
DEFINE            VARIABLE s-link-rent     LIKE order-i.link-rent NO-UNDO.
DEFINE            VARIABLE t-reply         AS LOG       NO-UNDO.
DEFINE            VARIABLE s-amtdue        AS DECIMAL   NO-UNDO. /* may no longer require */
DEFINE            VARIABLE s-total         AS DECIMAL   NO-UNDO.  /* may no longer require */
DEFINE            VARIABLE s-security      AS LOG       NO-UNDO.
DEFINE            VARIABLE s-item-no       AS INTEGER   NO-UNDO.
DEFINE            VARIABLE s-orderid       AS RECID     NO-UNDO.
DEFINE            VARIABLE g-empl-no       LIKE sale.empl-no NO-UNDO.
DEFINE            VARIABLE s-realdeposit   AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE s-discount      AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE s-subtotal      AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE p-backtrack     AS LOG       NO-UNDO.
DEFINE            VARIABLE recallsuspend   AS LOG       INIT NO.
DEFINE            VARIABLE recallhold      AS LOG       INIT NO.
DEFINE            VARIABLE t-leaveout      AS LOG       INIT NO.
/* these next variables included here to handle loc-number in use problem */
DEFINE            VARIABLE commit-sale     AS LOG       INIT NO. /* override endkey errors */
DEFINE            VARIABLE is-loan         AS LOG       INIT NO.     /* flag to determine if a loan item */
DEFINE            VARIABLE is-quote        AS LOG       INIT NO.
DEFINE            VARIABLE chargeit        AS DECIMAL.
DEFINE            VARIABLE discreason      AS CHARACTER FORMAT "x(35)".
DEFINE            VARIABLE t-disc-type     AS CHARACTER FORMAT "x(2)".   /* send with hold/request */
DEFINE            VARIABLE a-reply         AS LOG       INIT NO.
DEFINE            VARIABLE dontbackout     AS LOG       INIT NO.
DEFINE            VARIABLE arno            LIKE customer-r.ar-no.
DEFINE            VARIABLE t-transno       AS INTEGER.
DEFINE            VARIABLE f5active        AS LOG       INIT NO.
DEFINE            VARIABLE f9active        AS LOG       INIT NO.
DEFINE            VARIABLE is_short        AS LOG       INIT YES.    /* print long or short version */
/* required for program charge.w */
DEFINE            VARIABLE p-dt-created    LIKE order.dt-created.
DEFINE            VARIABLE v_cust-no       AS CHARACTER NO-UNDO.
DEFINE NEW SHARED VARIABLE s-dt            AS DATE.
DEFINE            VARIABLE p-list          AS CHARACTER NO-UNDO.
DEFINE            VARIABLE F3BANDATTENDER  AS LOG       NO-UNDO.
/** needed for calling customer find routines **/
/*def var evaluescan as char no-undo. */
DEFINE            VARIABLE t-disc-reason   AS CHARACTER NO-UNDO. /* used to keep discount.disc-no */
DEFINE            VARIABLE t-visa          AS LOG.
DEFINE            VARIABLE anystring       AS CHARACTER.
DEFINE            VARIABLE t-reminder      AS LOG.             /* set the notice reminder flag */
DEFINE            VARIABLE t-renew         AS INTEGER   NO-UNDO.        /* renewal flag for terms */
DEFINE            VARIABLE t-mincharge     AS DECIMAL.            /* minimum charge for a rental */
DEFINE            VARIABLE is_suspend      AS LOG       INIT NO.           /* detect if suspended sale */
DEFINE            VARIABLE lastrow         AS INTEGER.   /* store highest row value in query.  */
DEFINE            VARIABLE t-orig-rate     AS DECIMAL   NO-UNDO.  /* rent to own */
DEFINE            VARIABLE t-saletend-amt  AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE t-discount-note AS CHARACTER NO-UNDO.
DEFINE            VARIABLE tx-msg          AS LOG       NO-UNDO.
DEFINE            VARIABLE p-id1           AS CHARACTER NO-UNDO.    /* tax override parameters to pass */
DEFINE            VARIABLE p-id2           AS CHARACTER NO-UNDO.
DEFINE            VARIABLE p-id3           AS CHARACTER NO-UNDO.
DEFINE            VARIABLE p-id4           AS CHARACTER NO-UNDO.
DEFINE            VARIABLE sch-back        AS LOG       INIT NO.  /* allows create bkoffice of school amts */
DEFINE            VARIABLE t-frame-list    AS CHARACTER NO-UNDO.
DEFINE            VARIABLE t-ph            AS HANDLE    NO-UNDO.  /* handle for ps/disp-total.p */
DEFINE            VARIABLE t-taxcollect    AS CHARACTER NO-UNDO.  /* holds which taxes are overridden */
DEFINE            VARIABLE dum-date        LIKE order.dt-due.
DEFINE            VARIABLE r-ins           AS DECIMAL.
DEFINE            VARIABLE discount        AS DECIMAL. /* holds accumulated amount from reg rents discount */
DEFINE NEW SHARED VARIABLE salrec          AS RECID.
DEFINE            VARIABLE balfrwd         AS LOG       INIT NO.
DEFINE            VARIABLE is_charge       AS LOG       NO-UNDO INIT NO. /* detect charge/discount in reg */
DEFINE            VARIABLE tloc-receive    AS INTEGER   NO-UNDO.
DEFINE            VARIABLE correcton       AS LOG       INIT NO. /* override all amounts and set output to 0 */
DEFINE            VARIABLE s-chargex       AS LOG.
DEFINE            VARIABLE p-orderid       AS RECID.
DEFINE            VARIABLE neworderec      AS RECID.
DEFINE            VARIABLE newordercreated AS LOG       INIT NO.
DEFINE            VARIABLE is-cancel       AS LOG.
DEFINE            VARIABLE is-school       AS LOG. /* task 7263*/
DEFINE            VARIABLE is_overdue      AS LOG.   /* need to use this for sku 999999 not yet done*/
DEFINE            VARIABLE msg-create      AS LOG.        /* was a special note created */
DEFINE            VARIABLE year-end        AS DATE.
DEFINE            VARIABLE p-tax-amts1     AS DECIMAL.
DEFINE            VARIABLE p-tax-amts2     AS DECIMAL.
DEFINE            VARIABLE fed-tax-desc    AS CHARACTER FORMAT "X(13)".
DEFINE            VARIABLE prov-tax-desc   AS CHARACTER FORMAT "X(13)".
DEFINE            VARIABLE t-scanin        AS LOG       INIT NO.
DEFINE            VARIABLE duplicate-ran   AS LOG       INIT NO.
DEFINE            VARIABLE t-fund          AS LOG       INIT NO.    /* fund raising */
DEFINE            VARIABLE t-fund-chg      AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE t-date-due      AS dat       NO-UNDO.  /* used by regular rent */
DEFINE            VARIABLE not-owing       AS LOG       INIT NO.  /* assume all items are in state of owing */
DEFINE            VARIABLE p-status        AS CHARACTER.
DEFINE            VARIABLE t-found         AS LOG       INIT NO. /* used as a return by dlgser.w */
DEFINE            VARIABLE cust-agree-dt   LIKE customer.ren-agree-dt.

DEFINE            VARIABLE loanreason      AS CHARACTER FORMAT "x(10)" NO-UNDO.
DEFINE            VARIABLE loantype        AS CHARACTER NO-UNDO.
DEFINE            VARIABLE t-old-value     AS DECIMAL.  /* used in rto for f8 starting value */
DEFINE            VARIABLE t-latecharge    AS DECIMAL   NO-UNDO. /* added to owing amount on prntslip. */

DEFINE            VARIABLE t-screenvalue   AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE t-screenrate    AS DECIMAL   NO-UNDO.
DEFINE            VARIABLE emplDisc        AS LOG       NO-UNDO.
/*  sel-cust.w *************/
DEFINE NEW SHARED VARIABLE v_charge-cust   AS LOG       NO-UNDO.
DEFINE            VARIABLE cust_created    AS LOG       NO-UNDO.  /* need */

DEFINE NEW SHARED VARIABLE v_Changes       AS LOG       NO-UNDO.

DEFINE            VARIABLE sch-cust        AS RECID     NO-UNDO.  /* for school yearly version */
DEFINE            VARIABLE sch_created     AS LOG       NO-UNDO.

/**********************************************************/

DEFINE BUFFER b-inv      FOR inv-locsrl.
DEFINE BUFFER bmast      FOR inv-master.
DEFINE BUFFER hold-order FOR order.   /* copy of hold contract */
DEFINE            VARIABLE t-hold-link     LIKE order.link-order.
DEFINE NEW SHARED VARIABLE t-linkno        AS CHARACTER FORMAT "x(16)" NO-UNDO.
DEFINE NEW SHARED VARIABLE tmtrans         AS INTEGER   NO-UNDO.
DEFINE NEW SHARED VARIABLE s-due           AS DECIMAL   NO-UNDO.

DEFINE            VARIABLE chg-code        LIKE order.charge-code NO-UNDO.
DEFINE            VARIABLE rentratemessage AS LOG.
DEFINE            VARIABLE rwpos           AS INTEGER.
DEFINE            VARIABLE midexch         AS LOG.     /* procedure usenonserial */
DEFINE            VARIABLE t-buys          AS DECIMAL. /* output from rentiby p */
DEFINE            VARIABLE t-disc          AS DECIMAL. /* output from rentiby p */
DEFINE            VARIABLE totalbuy        AS DECIMAL.
DEFINE            VARIABLE s-by-amt        AS DECIMAL.
DEFINE            VARIABLE s-billing       AS LOG.
DEFINE            VARIABLE s-extend        AS DECIMAL.

DEFINE NEW SHARED VARIABLE salerec         LIKE sale.link-sale NO-UNDO.
DEFINE            VARIABLE s-issue         AS DATE.
DEFINE            VARIABLE t-purchase      AS DECIMAL.
DEFINE            VARIABLE s-renttot       AS DECIMAL.
DEFINE            VARIABLE exchrec         AS RECID.
DEFINE            VARIABLE newexchrec      AS RECID.
DEFINE            VARIABLE buyrec          AS RECID.
DEFINE            VARIABLE itemnum         AS INTEGER .
DEFINE            VARIABLE status-ok       AS LOG.
DEFINE            VARIABLE bl-row          AS INTEGER.
DEFINE            VARIABLE offset          AS INTEGER   INIT 4.
DEFINE            VARIABLE i               AS INTEGER.
DEFINE            VARIABLE meth            AS LOG.
DEFINE            VARIABLE p-rent-code     LIKE order.rent-code.
DEFINE            VARIABLE lnk             LIKE order.link-order.

/* section used by calrent_tots.    */
DEFINE            VARIABLE t-balance       AS DECIMAL .
DEFINE            VARIABLE s-co-complete   AS LOG.
DEFINE            VARIABLE t-monthly       AS DECIMAL.
DEFINE            VARIABLE t-paid          AS DECIMAL.
DEFINE            VARIABLE t-deposit       AS DECIMAL.
DEFINE            VARIABLE prepayday       AS INTEGER. /* rto setting a prepayment date */
DEFINE            VARIABLE t-pay-enter     AS DECIMAL.
DEFINE            VARIABLE t-dt-enter      AS DATE      FORMAT "99/99/9999".
DEFINE            VARIABLE d-due           AS DECIMAL.
DEFINE            VARIABLE pickUpBy        LIKE order.invoice-comment[1].
DEFINE BUFFER b-order   FOR order .
DEFINE BUFFER bord-lywy FOR ord-lywy.
DEFINE BUFFER borderi   FOR order-i.  /* use to find order-i of hold-order */
DEFINE BUFFER bsale     FOR sale .
DEFINE BUFFER bsale-i   FOR sale-i .
DEFINE VARIABLE v_rec              AS RECID.
DEFINE VARIABLE s-rec              AS RECID.
DEFINE VARIABLE r-cust             AS RECID.
DEFINE VARIABLE recm               AS RECID.
DEFINE VARIABLE s_ser              LIKE order-s.serial-no.
DEFINE VARIABLE is_exch            AS LOG.

DEFINE VARIABLE ite                LIKE order-i.item-no NO-UNDO.
DEFINE VARIABLE nrecs              AS INTEGER   INIT 0.
DEFINE VARIABLE oldpos             AS LOG       NO-UNDO INIT FALSE.
DEFINE VARIABLE s-ordnum           LIKE order.order-no VIEW-AS FILL-IN.
DEFINE VARIABLE t-visacode         AS INTEGER   NO-UNDO.

DEFINE VARIABLE tPartialDisc       AS DECIMAL.
DEFINE VARIABLE tPartialRefund     AS DECIMAL.
DEFINE VARIABLE CouponDiff         AS DECIMAL.
DEFINE VARIABLE parseCoupon        AS LOG       NO-UNDO.

DEFINE VARIABLE tRental            AS CHARACTER NO-UNDO. /* 10639 */
DEFINE VARIABLE tTeacher           AS CHARACTER NO-UNDO. /* information stored on sku 9999993 */
DEFINE VARIABLE tStudent           AS CHARACTER NO-UNDO. /* and must have on every re-entry */
DEFINE VARIABLE tSchoolAcct        LIKE customer.cust-no. /* as well as F3 key. */
DEFINE VARIABLE tSchCostShare      AS LOG       NO-UNDO.
DEFINE VARIABLE tSchCostShareValue AS DECIMAL   NO-UNDO.
DEFINE VARIABLE tAcceptPass        AS LOG       NO-UNDO.
DEFINE VARIABLE tYears             AS INTEGER   INIT 1 NO-UNDO. /* number of years to update */

DEFINE VARIABLE tShipDirect        AS LOGICAL   NO-UNDO.

DEFINE VARIABLE pBuyOnly           AS LOG       NO-UNDO. /* rto accessory flag */
DEFINE VARIABLE pChoice            AS LOG       NO-UNDO. /* rto accessory flag */
DEFINE VARIABLE custInStore        AS LOG       INIT YES. /* flag for 46/48 */
/* -------------------------------------------------------------------------- */

DEFINE VARIABLE t-length           AS CHARACTER INIT "             ".


FORM
  t-tot2                FORM "->>,>>9.99"
  t-length
  t-total               FORM "->>,>>9.99"      SPACE(4)
  WITH FRAME fr-total2 NO-LABELS NO-ATTR-SPACE ROW 15 COL 46
  TITLE "       TOTAL            ".


FORM s-ordnum FORM "x(8)"
  WITH FRAME fr-ord NO-LABELS NO-ATTR-SPACE ROW 4 COL 1 TITLE "NUMBER".

DEFINE VARIABLE retitle AS CHARACTER NO-UNDO.
IF p-rent-code = "BILLING" THEN retitle =
    "  SERIAL#          MODEL            QTY      NET VALUE    Mo.RATE       PAID  "
    .
ELSE IF p-rent-code = "SCHOOL" THEN retitle =
      "  SERIAL#          MODEL            QTY      NET VALUE    Yr.RATE       PAID  "
      .
  ELSE IF p-rent-code = "REGULAR" THEN retitle =
        "  SERIAL#          MODEL            QTY      NET VALUE     RATE(EA)    TOTAL  "
        .
    ELSE IF p-rent-code = "RENTOWN" THEN retitle =
          "  SERIAL#          MODEL            QTY      NET VALUE     RATE(EA)    PAID   "
          .


DEFINE BUFFER b-sale-i FOR sale-i.

{v-trans.i new}
{item-scr.i new}
DEFINE NEW SHARED TEMP-TABLE tsale LIKE sale.
DEFINE NEW SHARED TEMP-TABLE tsalei LIKE sale-i.

/* -------------- this query for serial num search ----------- */
DEFINE QUERY cust-qry FOR v-trans SCROLLING.
DEFINE BROWSE cust-browse QUERY cust-qry NO-LOCK NO-WAIT
  DISPLAY v-trans.serial-no
  v-trans.product-no
  v-trans.qty
  v-trans.orig-value
  v-trans.rent-rate
  v-trans.extended
  v-trans.estat
       with no-box size 78 by 6 down no-labels at row 1 col 1.
DEFINE NEW SHARED FRAME brws-frame cust-browse AT ROW 1 COL 1
  NO-ATTR-SPACE WITH ROW 7 COL 1.
DEFINE VARIABLE e AS CHARACTER VIEW-AS EDITOR SIZE 16 BY 1 .
FORM e WITH FRAME f ROW 7 COL 1.

DEFINE BUFFER b-trans FOR v-trans.
DEFINE VARIABLE prot-flag  AS LOG       NO-UNDO.
DEFINE VARIABLE t-rtolab   AS CHARACTER FORMAT "x(05)" INIT "Mths " NO-UNDO.
DEFINE VARIABLE t-rtolab1  AS CHARACTER FORMAT "x(07)" INIT " Value " NO-UNDO.
DEFINE VARIABLE t-rto-mth  AS INTEGER   FORMAT ">>>" NO-UNDO.
DEFINE VARIABLE t-rto-tot  AS DECIMAL   FORMAT ">>>>>.99" NO-UNDO.
DEFINE VARIABLE t-rto-mess AS CHARACTER FORMAT "x(43)" NO-UNDO.
FORM
  v-trans.description  FORMAT "x(43)"  SKIP
  v-trans.line-desc[2] FORMAT "x(43)"
  SKIP
  t-rto-mess
  WITH FRAME fr-descrip NO-LABELS NO-ATTR-SPACE  ROW 15  COL 1
  TITLE "Description" .

SUBSCRIBE TO "IsShipDirect" ANYWHERE.

DEFINE VARIABLE t-rental-notes AS CHARACTER NO-UNDO.

/* ************************ Function Implementations *********************** */
/* @(#) rnfunc-NeverUsed.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-NeverUsed.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION NeverUsed RETURNS LOG(pSku AS INTEGER):
  DEFINE BUFFER BMAST FOR INV-MASTER.
  FIND BMAST NO-LOCK WHERE BMAST.SKU-NO = pSku NO-ERROR.
  IF AVAILABLE BMAST THEN RETURN BMAST.NEVER-USED.
  RETURN NO.
END FUNCTION.

/* @(#) rnfunc-Is-archarge.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-Is-archarge.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION is-archarge RETURNS LOG(p-linksale AS CHARACTER):
  DEFINE VARIABLE t-return AS LOG NO-UNDO INIT NO.

  ASSIGN
    t-return = NO.
  FOR EACH saletend NO-LOCK
    WHERE saletend.link-sale = p-linksale
    AND saletend.void = NO:
    IF saletend.tend-no = 99 THEN
    DO:
      ASSIGN
        t-return = YES.
      LEAVE.
    END.
  END.
  RETURN t-return.
END FUNCTION.

/* @(#) rnfunc-schoolRental.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-schoolRental.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION schoolRental RETURNS LOG(pSku AS INTEGER):
  IF CAN-FIND(inv-master WHERE inv-master.sku-no = pSku AND
    inv-master.schoolRental = YES) THEN RETURN YES.
  RETURN NO.
END FUNCTION.

/* @(#) rnfunc-purchaseOnly.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-purchaseOnly.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION purchaseOnly RETURNS LOG(pSku AS INTEGER):

  IF CAN-FIND(inv-master WHERE inv-master.sku-no = pSku AND
    inv-master.never-used = YES) THEN RETURN YES.
  RETURN NO.
END FUNCTION.

/* @(#) rnfunc-rentPackage.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-rentPackage.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION rentPackage RETURNS LOG(pSku AS INTEGER):
  IF CAN-FIND(FIRST rent-package WHERE rent-package.master-sku = pSku) THEN
    RETURN YES.
  RETURN NO.
END FUNCTION.

/* @(#) rnfunc-chkContract.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-chkContract.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION chkContract RETURNS CHARACTER
  (p-sku AS INTEGER,p-serial AS CHARACTER, OUTPUT p-loc AS CHARACTER):
  DEFINE BUFFER bf-ord-s FOR order-s.
  DEFINE BUFFER bf-ord-i FOR order-i.
  DEFINE BUFFER bf-order FOR order.
  DEFINE BUFFER bsale    FOR sale.

  FOR EACH bf-ord-s NO-LOCK
    WHERE bf-ord-s.serial-no = p-serial,
    EACH bf-ord-i OF bf-ord-s  NO-LOCK
    WHERE bf-ord-i.sku-no = p-sku
    AND bf-ord-i.dt-return = ?
    AND NOT bf-ord-i.void,
    EACH bf-order OF bf-ord-i NO-LOCK
    WHERE (bf-order.sale-type = "rn":u OR bf-order.sale-type = "rh":u)
    AND bf-order.int-status <> "PICKED UP":u:
    FIND FIRST bsale OF bf-order NO-LOCK WHERE NOT bsale.void NO-ERROR.
    IF AVAILABLE bsale THEN
    DO:
      p-loc = bf-order.loc-code.
      RETURN bf-order.order-no.
    END.
  END.
  RETURN "".
END FUNCTION.

/* @(#) rnfunc-get-retail.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-get-retail.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION get-retail RETURNS DECIMAL
  (p-sku AS INTEGER,p-serial AS CHARACTER,p-used AS CHARACTER,p-include-disc AS LOG):
  DEFINE VARIABLE t-retail AS DECIMAL NO-UNDO.

  /* clear-pricing().*/
  IF p-used = "u":U THEN
  DO:
    t-retail = get-current-retail(p-sku,p-serial).
    IF AVAILABLE customer AND customer.discount-level = 3 THEN
      t-retail = t-retail * 0.90.   /* task 2135 */
    RETURN t-retail.
  END.
  t-retail = get-new-cust-price(p-sku,t-loc-code
    ,YES,customer.cust-no,NO).
  IF NOT p-include-disc
    THEN t-retail = t-retail - get-cust-disc(). /* add discount back */
  RETURN t-retail.
END FUNCTION.

/* ************************ Trigger Implementations ************************ */
/* @(#) rntrig-010.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-010.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f3 OF FRAME brws-frame ANYWHERE
  DO:
    IF p-rent-code <> "billing" THEN
      APPLY "f3" TO e IN FRAME f.
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-020.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-020.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ENTRY OF FRAME brws-frame ANYWHERE
  DO:
    RUN disp-msg("display").
  END.

/* ---------------------- THIS SECTION EDIT-1 OVERLAY ---------------------- */
/* @(#) rntrig-030.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-030.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ENTRY OF e IN FRAME f
  DO:
    STATUS INPUT "Enter Serial No# / or Return to Select Model / F12 to Complete.".
  END.

/* @(#) rntrig-040.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-040.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ANY-PRINTABLE OF e IN FRAME f
  DO:
    APPLY LASTKEY.
    ASSIGN
      v-trans.serial-no = e:screen-value.

    MESSAGE "Press Return to Accept Serial#  or  F5 to Add to Used Inventory".
    IF is_exch THEN s-rec = ? .
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-050.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-050.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ANY-KEY OF e IN FRAME f
  DO:
    DEFINE VARIABLE t-create AS LOG INIT NO NO-UNDO. /* to decide if ord-lywy created*/

    IF KEYLABEL(LASTKEY) BEGINS "esc" THEN
    DO:
      APPLY LASTKEY TO DEFAULT-WINDOW.
      RETURN NO-APPLY.
    END.

    CASE LASTKEY:

      WHEN KEYCODE("esc-t") THEN
        DO:
          DEFINE VARIABLE t-trans AS LOG NO-UNDO.
          RUN ss/is-trans.p(OUTPUT t-trans).
          MESSAGE
            "TRANSACTION BLOCK:" t-trans
            VIEW-AS ALERT-BOX ERROR.
        END.
      WHEN KEYCODE("end") THEN
        DO:
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("Del") OR
      WHEN keycode("backspace") THEN
        DO:
          IF e:cursor-offset = 1 THEN. /* at start so do nothing */
          ELSE
          DO:
            e:cursor-offset = e:cursor-offset - 1.
            meth = e:Delete-char().
            ASSIGN
              v-trans.serial-no = e:screen-value.
          END.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("cursor-up") THEN
        DO:
          IF e:screen-value <> "" THEN
          DO:
            ASSIGN
              e                 = ""
              v-trans.serial-no = "".
          END.
          IF i = 1 THEN RETURN.   /* seems to solve initial loss problem */
          APPLY "entry" TO cust-browse IN FRAME brws-frame.
          APPLY "cursor-up" TO cust-browse IN FRAME brws-frame.
          IF v-trans.description <> "" THEN
            IF p-rent-code = "rentown" THEN
            DO:
              /* THIS IS NOW A BUG 2360 BECAUSE exchanges get prev amt deducted. */
              IF v-trans.rent-rate <> 0 THEN ASSIGN
                  t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
                  /*t-rto-tot = v-trans.orig-value * v-trans.qty */
                  t-rto-mth = t-rto-tot  / v-trans.rent-rate.
              ASSIGN
                t-rto-mess = t-rtolab + string(t-rto-mth) +  t-rtolab1
            + string(t-rto-tot).
            END.
            ELSE t-rto-mess = ""  .
          DISPLAY v-trans.description v-trans.line-desc[2]
            t-rto-mess
            WITH FRAME fr-descrip ROW 15 COL 1.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("cursor-down") THEN
        DO:
          IF e:screen-value <> "" THEN
          DO:
            ASSIGN
              v-trans.serial-no = e:screen-value.

            IF v-trans.description <> "" AND (order.order-no BEGINS "ro"
              OR order.order-no BEGINS "o")
              AND NOT v-trans.serial-no BEGINS "sku#" THEN
            DO:
              IF v-trans.rent-rate <> 0 THEN ASSIGN
                  t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
                  /* t-rto-mth = t-rto-tot / v-trans.rent-rate. task 4968*/
                  t-rto-mth = (t-rto-tot - v-trans.deposit%) / v-trans.rent-rate.
              ASSIGN
                t-rto-mess = t-rtolab + string(t-rto-mth) +  t-rtolab1
             + string(t-rto-tot).
              DISPLAY v-trans.description v-trans.line-desc[2]
                t-rto-mess
                WITH FRAME fr-descrip ROW 15 COL 1.
              RETURN NO-APPLY.
            END.

            ELSE IF v-trans.description <> "" THEN
              DO:
                t-rto-mess = "".
                DISPLAY v-trans.description v-trans.line-desc[2]
                  t-rto-mess
                  WITH FRAME fr-descrip ROW 15 COL 1.
                RETURN NO-APPLY.
              END.
          END.
        END.
      WHEN KEYCODE("page-up") THEN
        DO:
          APPLY "entry" TO cust-browse IN FRAME brws-frame.
          DEFINE VARIABLE x AS INTEGER.

          DO x = 1 TO cust-browse:down IN FRAME brws-frame.
            IF cust-browse:is-row-selected(x) THEN LEAVE.
          END.
          rwpos = x.
          REPOSITION cust-qry TO ROW(rwpos).
          IF p-rent-code = "rentown" THEN
          DO:
            IF v-trans.rent-rate <> 0 THEN ASSIGN
                t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
                /*t-rto-tot = v-trans.orig-value * v-trans.qty*/
                /* t-rto-mth = t-rto-tot / v-trans.rent-rate. task 4968 */
                t-rto-mth = (t-rto-tot - v-trans.deposit%) / v-trans.rent-rate.
            t-rto-mess = t-rtolab + string(t-rto-mth) +  t-rtolab1
              + string(t-rto-tot).
          END.

          ELSE t-rto-mess = "".

          IF v-trans.description <> "" THEN
            DISPLAY v-trans.description v-trans.line-desc[2]
              t-rto-mess
              WITH FRAME fr-descrip ROW 15 COL 1.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("f2") THEN
        DO:
          IF AVAILABLE v-trans AND RECID(v-trans) = v_rec AND v-trans.sku-no = 0 THEN
            ASSIGN v-trans.serial-no = "" e                 = "".

          APPLY LASTKEY TO cust-browse IN FRAME brws-frame.
          PAUSE 0 NO-MESSAGE.     /* problems with hit spacebar to continue */
          VIEW FRAME brws-frame.
          PAUSE 0 NO-MESSAGE.
          VIEW FRAME f.
          PAUSE 0 NO-MESSAGE.
          APPLY "entry" TO SELF.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("f3") THEN
        DO:
          lpp: REPEAT ON ERROR UNDO lpp, LEAVE lpp
            ON ENDKEY UNDO lpp, LEAVE lpp:

            IF p-rent-code BEGINS "RE" THEN
            DO:
              FIND order NO-LOCK WHERE order.link-order = s-link-order.
              s-issue = order.dt-created.
              s-deposit = 0.
              /* dummy var in case it gets reassigned. we dont want to use */
              IF NOT t-hold THEN
                dum-date = order.dt-due.
              ELSE
                dum-date = t-dt-enter.
              /* patch to get deposit box to open up. */
              DEFINE VARIABLE tmpRentCode AS CHARACTER NO-UNDO.

              tmpRentCode = p-rent-code.
              IF order.int-status = "create" AND p-rent-code = "regular"
                THEN p-rent-code = "regul".
              IF t-funct-name = "loan.create" THEN t-reminder = NO.
              oMsg:msg-hide().

              RUN totdeposits.
              IF t-deposit <> 0 OR order.int-status = "create" THEN
                IF t-hold THEN p-rent-code = "HOLD".
              RUN date_ret.w(p-rent-code, INPUT-OUTPUT s-issue,
                INPUT-OUTPUT dum-date, s-link-order, INPUT-OUTPUT chg-code,
                OUTPUT f9active, OUTPUT s-deposit, OUTPUT msg-create,
                INPUT-OUTPUT t-reminder, INPUT t-deposit /*, output prepayDay*/ ).
              oMsg:msg-refresh().

              IF order.int-status = "create" THEN p-rent-code =  tmpRentCode.
              ELSE IF order.order-no BEGINS "ro" OR order.order-no BEGINS "o"
                  THEN p-rent-code = "rentown".
              /*** update t-dt-enter as of Feb26-2016 */
              IF NOT order.order-no BEGINS "ro" AND dum-date <> ?
                AND dum-date <> t-dt-enter THEN ASSIGN
                  t-dt-enter  = dum-date
                  s-dt-return = dum-date.
              RUN reopenquery.
              APPLY "entry" TO e IN FRAME f.
              RETURN NO-APPLY.
            END.
            ELSE
            DO:
              RETURN NO-APPLY.
            END.
          END.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("shift-f3") THEN
        DO:
          IF order.order-no BEGINS "rs" OR order.order-no BEGINS "s" THEN
            RUN ss/pagefile.p("help/rn-newp2sch-hlp.txt","ADDING AN ITEM").
          ELSE IF order.order-no BEGINS "rn" OR order.order-no BEGINS "n" THEN
              RUN ss/pagefile.p("help/rn-newp2reg-hlp.txt","ADDING AN ITEM").
            ELSE IF order.order-no BEGINS "ro" OR order.order-no BEGINS "o" THEN
                RUN ss/pagefile.p("help/rn-newp2rto-hlp.txt","ADDING AN ITEM").
          ENABLE e WITH FRAME f.
          APPLY "entry" TO e IN FRAME f.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("f4") THEN
        DO:
          HIDE FRAME f NO-PAUSE.
          APPLY "f4" TO cust-browse IN FRAME brws-frame.
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("f5") THEN
        DO:
          HIDE MESSAGE NO-PAUSE.
          RUN setf5.
          RUN setupframef(YES, YES).
          RETURN NO-APPLY.
        END.

      WHEN KEYCODE("f7") THEN
        DO:
          HIDE MESSAGE NO-PAUSE.
          IF (v-trans.estat = "") AND NOT is_exch THEN
          DO:
            DEFINE VARIABLE can-tax AS LOG.
            RUN rn-taxcodes.p(order.loc-code, t-loc-code, OUTPUT can-tax).
            IF can-tax THEN
            DO:
              ASSIGN
                v-trans.estat = "P"
                buyrec        = RECID(v-trans).
              status-ok = cust-browse:refresh() IN FRAME brws-frame.
              MESSAGE
                "Enter Serial Number of Product to purchase, or <Return> to select Model.".
            END.

            ELSE
            DO:
              MESSAGE " ITEMS CANNOT BE ADDED TO THIS STORES CONTRACT FOR PURCHASE"
                SKIP
                "DUE TO TAX CONSIDERATIONS AND OTHER PROBLEMS. USE CUSTOMER SALE."
                VIEW-AS ALERT-BOX .
              RETURN NO-APPLY.
            END.

          END.
          ELSE
          DO:
            APPLY "f7" TO cust-browse IN FRAME brws-frame .
            RETURN NO-APPLY.
          END.
        END.
      WHEN KEYCODE("f9") THEN
        APPLY LASTKEY TO cust-browse IN FRAME brws-frame.

      WHEN KEYCODE("f10") THEN
        DO:
          IF p-status <> "create" THEN
            RUN returnall.                 /* return all only on blank line */
        END.
      WHEN KEYCODE("f11") THEN
        DO:
          DEFINE VARIABLE t-chose AS LOG NO-UNDO.
          FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.

          IF AVAILABLE order THEN
          DO TRANSACTION:
            FIND ord-lywy OF order EXCLUSIVE-LOCK NO-ERROR.
            IF NOT AVAILABLE ord-lywy THEN
            DO:
              CREATE ord-lywy.
              ord-lywy.link-order = order.link-order.
              IF AVAILABLE employee THEN
                ord-lywy.comment[4] = STRING(employee.name) + " " + string(TODAY).
              t-create = YES.
              DISPLAY ord-lywy.comment WITH FRAME fr-lywy.
            END.
    FORMAT {ps-getlywy.f} ROW 7 COL 1 OVERLAY.
            DO WHILE TRUE:
              UPDATE TEXT(ord-lywy.comment) GO-ON(f4) WITH FRAME fr-lywy.
              IF t-create AND ord-lywy.comment[1] = "" THEN
              DO:
                DELETE ord-lywy.
                t-create = NO.
              END.
              HIDE FRAME fr-lywy NO-PAUSE.
              VIEW FRAME fr-total2.
              VIEW FRAME brws-frame.
              RUN screenrefresh.
              APPLY "entry" TO cust-browse IN FRAME brws-frame.
              PAUSE 0 NO-MESSAGE.
              VIEW e IN FRAME f.  /* somehow wait-for still needs enabling */
              APPLY "entry" TO e IN FRAME f.
              RETURN NO-APPLY.
            END.
            IF LASTKEY = keycode("f4") THEN HIDE FRAME fr-lywy NO-PAUSE.

          END.
        END.
      WHEN KEYCODE("f12") THEN
        DO:
          IF e:screen-value = "" THEN
            APPLY "f12" TO cust-browse IN FRAME brws-frame.
          RETURN NO-APPLY.
        END.
      /* old version */
      WHEN KEYCODE("return") THEN
        DO:
          VIEW FRAME f.
          HIDE MESSAGE NO-PAUSE.
          s-rec = ?.  /* force a reset off of a return */
          IF e:screen-value <> "" THEN
          DO:
            IF e:screen-value BEGINS "sku#" THEN
            DO:
              ASSIGN
                v-trans.serial-no = e:screen-value
                v-trans.serial-no = "".
              ASSIGN
                e = "".
              DISPLAY e WITH FRAME f.
              RETURN NO-APPLY.
            END.

            IF not-owing = NO THEN
            DO:
              RUN rn-message.p("not-owing").
              ASSIGN
                e = "".
              RETURN NO-APPLY.
            END.
            ELSE IF p-auth BEGINS "write off" THEN
              DO:
                RUN rn-message.p("write-off").
                ASSIGN
                  e = "".
                DISPLAY e WITH FRAME f.
                RETURN NO-APPLY.
              END.
              ELSE
              DO:     /* on return of a serial number entered */
                ASSIGN
                  v-trans.serial-no = e:screen-value.
                IF v-trans.serial-no = "#to follow#" THEN
                DO:
                  ASSIGN
                    v-trans.serial-no = ""
                    e                 = "".
                  DISPLAY e WITH FRAME f.
                  RETURN NO-APPLY.
                END.
                DISABLE ALL WITH FRAME f.
                /* if not is_exch then */
                /* if not is_exch and t-scanin = no
                  then  */
                ASSIGN
                  s-rec = RECID(inv-locsrl) no-error.
                /* in what instance do I have a recid for inv-locsrl? */
                IF is_exch THEN
                DO:
                  newexchrec = RECID(v-trans). /* sitting on rec about to be used */
                  IF s-rec <> ? THEN
                  DO:
                    RUN useskuno.
                  END.
                  ELSE
                  DO:
                    RUN fromgetserial. /* locate an inv-locsrl first. */
                    IF s-rec = ? THEN  /* could not find unique inv-locsrl. */
                      RUN used-rent.     /* get model-no for possible selection */
                  END.
                  IF is_exch THEN
                  DO:  /* can be reset in used-rent */

                    RUN rentexch.      /* go make tests */
                  END.
                END.
                ELSE IF v-trans.estat = "P" THEN
                  DO:
                    ASSIGN
                      buyrec = RECID(v-trans).
                    IF RECID(v-trans) = v_rec THEN s-rec = ?.
                    IF s-rec <> ? THEN RUN useskuno.
                    ELSE RUN used-rent.

                    IF LASTKEY = keycode("f4") THEN
                    DO:
                      v-trans.serial-no = "".
                      e = v-trans.serial-no.
                      PAUSE 1 NO-MESSAGE.
                    END.
                    ELSE
                    DO:
                      FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
                      IF AVAILABLE inv-master THEN
                      DO:
                        ASSIGN
                          buyrec = RECID(v-trans).
                        RUN buynewitem.
                        PAUSE 1 NO-MESSAGE.
                      END.
                    END.
                  END.
                  ELSE
                  DO:     /* added following line sep 10 /99 */
                    IF RECID(v-trans) = v_rec THEN s-rec = ?.
                    IF s-rec <> ? THEN
                    DO:
                      RUN useskuno. /* select item from list */
                      IF s-rec <> ? THEN
                        FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
                    END.
                    ELSE
                    DO:

                      RUN fromgetserial.
                      IF LASTKEY = keycode("f4") THEN
                      DO:
                        v-trans.serial-no = "".
                        e = v-trans.serial-no.
                      END.
                    END.
                  END.
                RELEASE inv-locsrl.
                RELEASE inv-master.
              END.
          END.
          ELSE
          DO:    /* no value on screen so open model box */
            IF v-trans.estat <> "P" THEN      /* seems to work okay here **/
              ASSIGN e = v-trans.serial-no.
            HIDE FRAME f NO-PAUSE.
            IF is_exch THEN
            DO:
              newexchrec = RECID(v-trans). /* sitting on rec about to be used */
              RUN dof5.

              IF is_exch THEN
              DO:  /* now here after model/serial select at botom*/

                RUN rentexch. /* sometimes dof5 will run rentexch */
              END.
            END.
            ELSE IF v-trans.estat = "P" THEN
              DO:
                RUN dof5.
              END.
              ELSE
              DO:
                RUN dof5.   /* when adding an item */
              END.
            IF LASTKEY = keycode("f4") THEN
            DO:
              bl-row = bl-row - 1.
            END.
          END.

          FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
          RUN setupframef(NO, YES).
          RETURN NO-APPLY.
        /*   CANNOT EXECUTE CODE IS NEVER REACHED
            if lastkey = keycode("f4") then do:
               v-trans.serial-no = "".
               e = "".
               display e with frame f.
          end.
        **/
        END.
      OTHERWISE
      DO:
      END.
    END.
  END.

/* ---------------------- TRIGGERS FOR ITEM BROWUSER ----------------------- */
/* @(#) rntrig-060.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-060.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ANY-KEY OF cust-browse IN FRAME brws-frame
  DO: /* just trap the 'end' key*/
    IF KEYLABEL(LASTKEY) BEGINS "esc" THEN
    DO:
      APPLY LASTKEY TO DEFAULT-WINDOW.
      RETURN NO-APPLY.
    END.

    CASE LASTKEY:

      WHEN KEYCODE("esc-t") THEN
        DO:
          DEFINE VARIABLE t-trans AS LOG NO-UNDO.
          RUN ss/is-trans.p(OUTPUT t-trans).
          MESSAGE
            "TRANSACTION BLOCK:" t-trans
            VIEW-AS ALERT-BOX ERROR.
        END.
      WHEN KEYCODE("end") THEN
        DO:
          RETURN NO-APPLY.
        END.
      WHEN KEYCODE("f2") THEN
        DO:
          APPLY LASTKEY TO cust-browse IN FRAME brws-frame.
          PAUSE 0 NO-MESSAGE.     /* problems with hit spacebar to continue */
          VIEW FRAME brws-frame.
          PAUSE 0 NO-MESSAGE.
          VIEW FRAME f.
          PAUSE 0 NO-MESSAGE.
          APPLY "entry" TO SELF.
          RETURN NO-APPLY.
        END.
    END.
  END.

/* @(#) rntrig-070.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-070.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f4 OF cust-browse IN FRAME brws-frame
  DO:
    HIDE FRAME f NO-PAUSE.
    HIDE FRAME brws-frame NO-PAUSE.
    HIDE FRAME fr-total2 NO-PAUSE.
    HIDE FRAME fr-key NO-PAUSE.
    HIDE FRAME fr-keys NO-PAUSE.
    STATUS INPUT "".
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  /*  /* commit-sale = no at this point */

  run undosales.
  */
  END.

/* @(#) rntrig-080.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-080.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f6 OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE t-old-item      AS INTEGER NO-UNDO.
    DEFINE VARIABLE t-warranty-link AS INTEGER NO-UNDO.
    DEFINE VARIABLE tsku28          AS LOG     NO-UNDO. /* is current vtrans sku 28? */
    IF v-trans.estat = "x" THEN
    DO:
      MESSAGE "You cannot remove an item which already exists on order".
      PAUSE 3 NO-MESSAGE.
      RETURN.
    END.
    IF v-trans.estat = "E" THEN
    DO:
      MESSAGE "You must Undo Exchange Using F7 to Remove this Item.".
      PAUSE 3 NO-MESSAGE.
      RETURN.
    END.
    IF v-trans.sku-no = 422888 THEN
    DO:
      /* could not do a for each here InvFun.cls */
      FOR EACH b-trans WHERE b-trans.warranty-link <> 0:
        IF b-trans.create-value <> 0 THEN ASSIGN
            b-trans.orig-value = b-trans.create-value.
        b-trans.extended = b-trans.orig-value * b-trans.qty.
      END.
    END.
    /* this is a patch because a voided order-i could have an item-no which
       matches an item-no of a new item added to the contract and then suspended.
    */
    FIND order-i OF order NO-LOCK
      WHERE order-i.item-no = v-trans.item-no
      AND order-i.sku-no = v-trans.sku-no
      AND order-i.void = NO NO-ERROR.
    IF NOT AVAILABLE order-i
      AND (v-trans.old-item = NO OR v-trans.estat = "P")
      AND RECID(v-trans) <> v_rec THEN
    DO:
      IF v-trans.sku-no = 28 OR v-trans.rent-rate = 0 THEN tsku28 = YES.
      MESSAGE "Now Deleting Current Record".
      IF t-holdit AND v-trans.line-desc[1] BEGINS "rh" THEN
      DO:
        MESSAGE "This item from Hold contract will be returned to inventory "
          VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE t-reply.
        IF t-reply THEN
        DO:
          ASSIGN
            v-trans.void     = YES
            v-trans.retail   = 0
            v-trans.extended = 0.
        END.
        ELSE
        DO:
          RETURN NO-APPLY.
        END.
      END.
      FIND inv-locsrl NO-LOCK WHERE inv-locsrl.serial-no = v-trans.serial-no
        AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
      /* reset back into inventory when not already set elswhere */
      IF AVAILABLE inv-locsrl AND inv-locsrl.i-status = 0 THEN
        RUN rs-invstatus.p(v-trans.serial-no, v-trans.sku-no, INPUT 0,
          s-ordnum, order.loc-code, p-status).
      /* don't change status if item was originally marked as -1 */
      /* if created on this contract then destroy it. */
      FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
      IF AVAILABLE inv-locsrl AND inv-locsrl.doc-ref BEGINS order.order-no
        THEN
      DO TRANSACTION:     /* rs-invstatus may have made it unavailable */
        FIND inv-locsrl WHERE inv-locsrl.serial-no = v-trans.serial-no
          AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
        IF AVAILABLE inv-locsrl AND inv-locsrl.doc-ref BEGINS order.order-no
          THEN  DELETE inv-locsrl.
      END.
      RELEASE inv-locsrl.
      t-old-item = v-trans.item-no.   /* the item deleted is a new purchase */
      t-warranty-link = v-trans.warranty-link. /* the item deleted is ext-war */
      IF v-trans.void AND v-trans.line-desc[1] BEGINS "RH" THEN
      DO:
      END.
      ELSE
      DO:
        FIND vlocsrl WHERE vlocsrl.sku-no = v-trans.sku-no AND
          vlocsrl.serial-no = v-trans.serial-no NO-ERROR.
        IF AVAILABLE vlocsrl THEN DELETE vlocsrl.
        DELETE v-trans.
      END.
      FIND v-trans WHERE v-trans.warranty-link = t-old-item NO-ERROR.
      IF AVAILABLE v-trans THEN
      DO:
        FIND vlocsrl WHERE vlocsrl.sku-no = v-trans.sku-no AND
          vlocsrl.serial-no = v-trans.serial-no NO-ERROR.
        IF AVAILABLE vlocsrl THEN DELETE vlocsrl.
        DELETE v-trans.
      END.
      IF t-warranty-link <> 0 THEN
      DO:
        FIND v-trans WHERE v-trans.item-no = t-warranty-link NO-ERROR.
        IF AVAILABLE v-trans THEN
        DO:
          /* task 5910 v-trans.rglr-warranty should be the same */
          ASSIGN
            v-trans.extended-warranty = 0.
        END.
      END.
      /**** delete only if record deleted is not sku28 and hade serial#*/
      IF NOT tsku28 AND p-rent-code = "school"
        AND NOT order.int-status = "create" THEN
      DO:
        RUN rnSchBalProt.p("F6",tSchCostShare).
      END.
      FIND v-trans WHERE RECID(v-trans) = v_rec.  /* must have this line */
      RUN reopenquery.
      RUN showdipfield.
    END.
    ELSE
    DO:   /* some items may still need to be removed */
      MESSAGE "Cannot delete item from Order".
    END.
  END.

/* @(#) rntrig-090.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-090.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f7 OF cust-browse IN FRAME brws-frame
  DO:
    /* def buffer b-trans for order-i. */
    DEFINE VARIABLE skyqty AS INTEGER INIT 0.
    IF v-trans.estat = "x" THEN
    DO:
      MESSAGE "Move to the blank line and enter a serial number <or> Press Return    to get Model Box, for an item to complete the Exchange".
      RETURN NO-APPLY.
    END.         /* type in a serial number and hit f7 instead of f5 */

    IF v-trans.estat = "" AND v-trans.product-no = ""
      AND v-trans.serial-no <> "" AND v-trans.old-item = NO THEN
    DO:
      RETURN NO-APPLY.
    END.
    DEFINE VARIABLE act-todo AS CHARACTER NO-UNDO.
    IF v-trans.estat = "C" THEN
    DO:
      v-trans.rent-rate = v-trans.orig-rentrate.
      v-trans.after-rate = v-trans.before-rate.
      v-trans.estat = "".
      RUN setupframef(NO, YES).
      RETURN NO-APPLY.
    END.
    IF v-trans.estat = "P" OR v-trans.estat = "B" THEN
    DO: /* undo buy */

      IF v-trans.serial-no <> "" THEN
      DO:
        /* screwing up if v-trans.old-item = no then do:  rtoaccessories */
        FIND inv-master NO-LOCK
          WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
        IF AVAILABLE inv-master AND inv-master.serial-reqd = "r" AND
          v-trans.serial-no BEGINS "sku#" THEN
        DO:
          APPLY "f6" TO cust-browse.
          RETURN NO-APPLY.
        END.

        ELSE IF AVAILABLE inv-master AND inv-master.never-used
            AND v-trans.serial-no BEGINS "sku#" THEN
          DO:
            APPLY "f6" TO cust-browse.
            RETURN NO-APPLY.
          END.

          ELSE IF t-funct-name = "r-own.create" AND NOT is_exch THEN
            DO:
              /*
              if avail inv-master then do:
                     /* make it disappear and inv-master.sku-no <> 39
              and inv-master.sku-no <> 49 */ then do:
              */
              IF v-trans.old-item = NO AND NOT v-trans.sku-no = 28 THEN
              DO:

                RUN getValidRtoAccessGroup.p(inv-master.group-no,OUTPUT pBuyOnly,
                  OUTPUT pChoice).
                IF pBuyOnly OR (pBuyOnly = NO AND pChoice = NO) THEN
                DO:
                  APPLY "f6" TO cust-browse.
                  RETURN NO-APPLY.
                END.
                ELSE IF pChoice THEN
                  DO:
                    IF v-trans.rent-rate <> 0 THEN
                    DO:
                      APPLY "f6" TO cust-browse.
                      RETURN NO-APPLY.
                    END.
                    ELSE
                      RUN undobuynewitem.
                  END.
              END.
              ELSE RUN undobuynewitem.
            END.
            ELSE
            DO:
              /* THE UNDO OF A PROMO PRICE SHOULD RE-INSTATE THE OLD PRICE WHICH
              IS WHAT? */
              RUN undobuynewitem.
            END.
      END.
      IF AVAILABLE v-trans THEN  /* on warranty or printed matter its deleted */
        v-trans.estat = "".

      RUN correcttotal.
      RUN displaytotal.
      VIEW FRAME fr-total2.
      VIEW FRAME fr-keys.
      VIEW FRAME cust-brwse.
      status-ok = cust-browse:refresh().
      APPLY "cursor-down" TO cust-browse IN FRAME brws-frame .
      RETURN NO-APPLY.
    END.                   /* else item has been added, to be bought not rented */
    ELSE IF (v-trans.estat = "" AND v-trans.old-item = NO)
      /* or (v-trans.estat = "" and v-trans.dt-rented >= today) */
      /* above blocks exchange */ AND v-trans.sku-no <> 28 THEN
      DO:
        /* but should not allow purchase in middle of exchange */
        DEFINE VARIABLE can-tax AS LOG.
        RUN rn-taxcodes.p(order.loc-code, t-loc-code, OUTPUT can-tax).
        IF can-tax THEN
        DO:
          IF NOT is_exch THEN
          DO:
            ASSIGN
              v-trans.estat = "P".
            buyrec = RECID(v-trans).
            RUN buynewitem.   /* no longer creates new line off warranty */
            FIND v-trans WHERE v-trans.sku-no = 0
              AND v-trans.product-no = "" NO-ERROR.
            IF AVAILABLE v-trans THEN v_rec = RECID(v-trans).
            ELSE RUN newwtrans.
          END.
          RUN setupframef(YES, YES).
          RETURN NO-APPLY.
        END.
        ELSE
        DO:
          MESSAGE " ITEMS CANNOT BE ADDED TO THIS STORES CONTRACT FOR PURCHASE"
            SKIP
            "DUE TO TAX CONSIDERATIONS AND OTHER PROBLEMS. USE CUSTOMER SALE."
            VIEW-AS ALERT-BOX .
          RETURN NO-APPLY.
        END.

      END.
      ELSE IF v-trans.estat = "L" THEN
        DO:
          v-trans.estat = "".
          RUN setupframef(YES, YES).
          RETURN NO-APPLY.
        END.
    /* no R B E on item just added */
    act-todo = "" .
    IF (v-trans.estat = "" ) AND p-rent-code <> "create"
      THEN
    DO:    /* then find out what action to do next */
      /*tactivate test
      if v-trans.after-rate <> v-trans.before-rate and v-trans.link-rent =v-trans.item-no and v-trans.old-item = yes and v-trans.rate-var <> 0 then
   return .  school f8 */


      DEFINE VARIABLE t-endkey AS LOG.
      /* only valid for qty of one as sk28 allows for partial returns.
       except when it has just been added *****/
      IF v-trans.old-item = NO AND v-trans.sku-no = 28 /* and v-trans.qty = 1*/
        THEN
      DO:  /* jul29 */
        APPLY "f6" TO cust-browse.
        RETURN NO-APPLY.
      END.
      IF is_exch THEN
      DO:
        MESSAGE "Complete the current exchange first." VIEW-AS ALERT-BOX.
        RETURN NO-APPLY. /* already in middle of exchange */
      END.
      IF t-funct-name = "rental.create" AND v-trans.serial-no BEGINS "SKU# 0000040"
        THEN
      DO:
        RUN select2.p
          ("Return,Exchange,Buy",15,32,"",INPUT-OUTPUT act-todo
          ,OUTPUT t-endkey).
      END.
      ELSE IF t-funct-name = "loan.create" OR p-auth BEGINS "write off"
          OR v-trans.dt-rented > TODAY THEN
        DO:
          RUN select2.p("Return,Buy",15,32,"",INPUT-OUTPUT act-todo,OUTPUT t-endkey).
        END.
        ELSE
        DO:
          IF order.order-no BEGINS "RO" OR order.order-no BEGINS "o" THEN
          DO:
            /* if order.order-no = "ro031320" then */

            RUN select2.p
              ("Return,Exchange,Buy",15,32,"",INPUT-OUTPUT act-todo
              ,OUTPUT t-endkey).
          /** could run this for single items only ...maybe
          else
          run select2.p
          ("Return,Exchange,Buy",15,32,"",input-output act-todo
          ,output t-endkey).
          ***/
          END.
          ELSE IF v-trans.serial-no BEGINS "sku#" THEN
              RUN select2.p("Return,Buy,Buy All",15,32,"",INPUT-OUTPUT act-todo
                ,OUTPUT t-endkey).
            ELSE
              RUN select2.p
                ("Return,Exchange,Buy,Buy All",15,32,"",INPUT-OUTPUT act-todo
                ,OUTPUT t-endkey).
        END.
      IF t-endkey THEN
      DO:
        RETURN NO-APPLY.
      END.
    END.

    IF act-todo = "" THEN
    DO:
      IF v-trans.estat = "R" THEN
      DO:       /* undo return */
        APPLY "f10" TO cust-browse IN FRAME brws-frame.
        RETURN NO-APPLY.
      END.
      ELSE IF v-trans.estat <> "" THEN   /* undo exchange or buy */
        DO:
          IF is_exch THEN RETURN.
          IF v-trans.estat = "E" THEN
          DO:
            RUN undoexch.
            s-rec = ?.
            recm = ?.
            is_exch = NO.
            RELEASE inv-locsrl.
            RELEASE inv-master.
          /* you need to search for the old one. */
          END.
          IF v-trans.estat = "B" THEN
            RUN undobuynewitem.
        END.    /* show old insurance if it exists or show no insurance **/
    END.
    ELSE
    DO:
      IF act-todo = "RETURN" THEN
      DO:       /*  do return */
        /* Test if a return has already been done from this line ***/
        FIND FIRST b-trans
          WHERE b-trans.link-rent = v-trans.item-no
          AND RECID(b-trans) <> recid(v-trans) NO-ERROR.
        IF AVAILABLE b-trans AND b-trans.item-status <> "owing" THEN
        DO:
          /* task7001 its previous */
          RUN reopenquery.
          RUN setupframef(NO,YES).
          RETURN NO-APPLY.
        END.
        DEFINE VARIABLE retrec AS RECID NO-UNDO.
        retrec = RECID(v-trans).
        IF (v-trans.qty > 1 AND t-funct-name <> "loan.create")
          OR (v-trans.qty >= 1 AND t-funct-name = "loan.create")
          AND v-trans.serial-no BEGINS "sku#" THEN
        DO:
          retrec = RECID(v-trans).
          RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
          /* a strange case of intermittent issue
            with an exchange done before a return which lands here */
          IF s-rec <> ? THEN s-rec = ?.
          RUN rn-retqty.p(v-trans.qty, v-trans.item-no, v-trans.link-order,
            t-funct-name,
            OUTPUT skyqty, OUTPUT t-endkey, OUTPUT v-trans.qty-new).

          RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
          IF t-funct-name <> "loan.create" THEN
          DO:
            ASSIGN
              v-trans.qty-new = 0.
          END.
          IF t-endkey THEN
          DO:
            RUN reopenquery.
            RUN setupframef(NO,YES).
            RETURN NO-APPLY.
          END.
          IF skyqty = 0 THEN
          DO:
            RUN reopenquery.
            RUN setupframef(NO,YES).
            RETURN NO-APPLY.
          END.
          IF skyqty <> v-trans.qty THEN
          DO:

            RUN partialreturn(skyqty). /* create a separate record */
            /*** if order.dt-due > today then **/
            DO:
              v-trans.estat = "z".   /* pass a flag */
              RUN rentirtn.    /* newly added items don't need to be returned */
            END.
            IF v-trans.old-item = NO THEN
              DELETE v-trans.
            IF AVAILABLE v-trans AND NOT v-trans.serial-no BEGINS "sku#" THEN
            DO:
              IF s-rec <> ? AND p-rent-code <> "rentown" THEN
              DO:
                /* CALLS VERSION 1.19  */
                RUN rn-unravel.p(s-rec, recm, t-dt-enter, s-link-order,
                  v-trans.orig-value, v-trans.rent-rate,
                  INPUT-OUTPUT itemnum, OUTPUT is-unravel).

                RUN reopenquery.
              END.
            END.
            RUN newwtrans.
            PAUSE 0 NO-MESSAGE.
            FIND v-trans WHERE RECID(v-trans) = retrec NO-ERROR.
            IF AVAILABLE v-trans THEN
            DO:
              VIEW FRAME fr-total2.
              VIEW FRAME fr-keys.
              RUN setupframef(NO, YES).
              status-ok = cust-browse:refresh() IN FRAME brws-frame.
              oMsg:msg-refresh().
              RETURN NO-APPLY.
            END.
            oMsg:msg-refresh().
          END.
          ELSE
          DO:   /* when skyqty = v-trans.qty. */
            RUN rentirtn.
            RUN correcttotal.
            RUN displaytotal.
            VIEW FRAME fr-total2.
            VIEW FRAME fr-keys.
            /* put it back on the same location in browser. */
            FIND v-trans WHERE RECID(v-trans) = retrec.
            status-ok = cust-browse:refresh() IN FRAME brws-frame.
            RETURN NO-APPLY.
          END.
        END.
        ELSE
        DO:
          APPLY "f10" TO cust-browse IN FRAME brws-frame.
          RETURN NO-APPLY.
        END.
      END.
      ELSE IF act-todo = "EXCHANGE" THEN
        DO:
          IF order.order-no BEGINS "ro" AND v-trans.sku-no = 40 THEN.
          ELSE IF v-trans.serial-no BEGINS "sku#" THEN
            DO:
              IF v-trans.serial-no BEGINS "SKU# 0000040"
                AND t-funct-name = "rental.create" THEN.
              ELSE
              DO:
                ASSIGN
                  exchrec    = ?
                  newexchrec = ?
                  is_exch    = NO.
                RETURN NO-APPLY.
              END.
            END.
          ASSIGN
            exchrec = RECID(v-trans).  /* might be able to remove */
          FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
          IF AVAILABLE v-trans AND v-trans.estat = "p" THEN
          DO:
            MESSAGE "YOU CANNOT DO AN EXCHANGE WHILE THE BLANK LINE HAS BEEN MARKED"
              SKIP
              "AS A PURCHASE. GO TO THE BLANK LINE AND USE F7 TO UNDO THE PURCHASE"
              SKIP
              "THEN USE F7 ON THE ITEM TO BEGIN THE EXCHANGE." VIEW-AS ALERT-BOX.
            ASSIGN
              exchrec    = ?
              newexchrec = ? .
            RETURN NO-APPLY.
          END.
          DEFINE VARIABLE testx     AS LOG     INIT NO.
          DEFINE VARIABLE t-x-estat AS INTEGER INIT 0.
          DEFINE VARIABLE t-e-estat AS INTEGER INIT 0.
          FOR EACH v-trans:
            IF v-trans.estat = "x" THEN
            DO:
              t-x-estat = t-x-estat + 1.
            END.
            IF v-trans.estat = "e" THEN
              t-e-estat = t-e-estat + 1.
          END.
          IF t-x-estat > t-e-estat THEN testx = YES.
          IF testx THEN
          DO:
            MESSAGE "You must complete the first exchange by entering a product.".
            FIND v-trans WHERE RECID(v-trans) = v_rec.
            RETURN NO-APPLY.
          END.
          FIND v-trans WHERE RECID(v-trans) = exchrec.
          v-trans.estat = "x".
          is_exch = YES.
          FIND v-trans WHERE RECID(v-trans) = v_rec.
          newexchrec = RECID(v-trans).
          RUN setupframef(NO, YES).
          MESSAGE "Enter Serial Number or Select Model of New Item in Exchange.".
          RETURN.
        END.
        ELSE IF act-todo = "BUY"  THEN
          DO:

            IF (v-trans.estat = "" ) AND v-trans.sku-no <> 28 THEN
            DO:
              IF v-trans.rent-rate = 0 THEN ASSIGN
                  v-trans.estat = "P".
              ELSE ASSIGN v-trans.estat = "B".
              buyrec = RECID(v-trans).
              RUN buynewitem.
              FIND v-trans WHERE v-trans.sku-no = 0  /* patch do to warranty */
                AND v-trans.product-no = "" NO-ERROR.
              IF AVAILABLE v-trans THEN v_rec = RECID(v-trans).
              ELSE RUN newwtrans.
              FIND v-trans NO-LOCK WHERE RECID(v-trans) = buyrec NO-ERROR.
              RUN correcttotal.
              RUN displaytotal.
              VIEW FRAME fr-total2.
              VIEW FRAME fr-keys.
              VIEW FRAME cust-brwse.
              VIEW FRAME f.
              RUN reopenquery.      /* needed */
              RUN showdipfield.
              status-ok = cust-browse:refresh().
              APPLY "cursor-down" TO cust-browse IN FRAME brws-frame .
              RETURN NO-APPLY.
            END.
          END.
          ELSE IF act-todo = "BUY ALL"  THEN
            DO:
              DEFINE VARIABLE t-lastitem AS INTEGER NO-UNDO.
              ASSIGN
                buyrec = RECID(v-trans).
              FIND FIRST v-trans NO-LOCK WHERE v-trans.estat = "e" NO-ERROR.
              IF AVAILABLE v-trans THEN
              DO:
                MESSAGE "BUY ALL cannot be executed after Exchanges have been made" SKIP
                  "Use the BUY Function for individual items." VIEW-AS ALERT-BOX.
                FIND v-trans WHERE RECID(v-trans) = buyrec NO-ERROR.
                RETURN.
              END.
              FIND FIRST v-trans NO-LOCK WHERE v-trans.estat <> "" NO-ERROR.
              IF AVAILABLE v-trans THEN
              DO:
                IF AVAILABLE order AND order.rent-code = "rentown" THEN .
                ELSE
                DO:
                  MESSAGE "BUY ALL cannot be executed after changes have been made" SKIP
                    "Use the BUY Function for individual items." VIEW-AS ALERT-BOX.
                  FIND v-trans WHERE RECID(v-trans) = buyrec NO-ERROR.
                  RETURN.
                END.
              END.
              IF order.rent-code = "school" THEN
              DO:
                FIND FIRST v-trans NO-LOCK WHERE v-trans.old-item = NO
                  AND v-trans.sku-no > 0 NO-ERROR.
                IF AVAILABLE v-trans THEN
                DO:
                  MESSAGE "BUY ALL cannot be executed when new items have been added" SKIP
                    "Use the BUY Function for individual items." VIEW-AS ALERT-BOX.
                  FIND v-trans WHERE RECID(v-trans) = buyrec NO-ERROR.
                  RETURN.
                END.
              END.
              FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
              IF AVAILABLE v-trans THEN t-lastitem = v-trans.item-no.
              FIND v-trans WHERE RECID(v-trans) = buyrec NO-ERROR.

              oMsg:msg-hide().
              /* ORIGINAL RTO WAS IN act-todo = "BUY" which ran buynewitem first */
              RUN warranty1("auto",OUTPUT t-endkey).
              IF t-endkey = NO
                THEN
                IF order.order-no BEGINS "ro" THEN
                DO:
                END.
                ELSE IF order.rent-code = "SCHOOL" THEN
                  DO:
                    RUN rnSchRentBuy.p(buffer order, "newp2.p",
                      tSchCostShare, tSchCostShareValue, OUTPUT t-endkey).
                  END.
                  ELSE
                    RUN rn-rentbuy.p(buffer order, "newp2.p", OUTPUT t-endkey).
              IF t-endkey THEN
              DO:
                FOR EACH v-trans WHERE v-trans.sku-no <> 0 AND NOT v-trans.void:
                  IF v-trans.estat = "o" THEN v-trans.extended = v-trans.amt-received.
                  IF v-trans.estat = "b" OR v-trans.estat = "p" THEN
                  DO:
                    IF v-trans.warranty-link = 0 THEN
                    DO:
                      RUN undobuynewitem.
                    END.
                  END.
                END.
                FOR EACH v-trans WHERE v-trans.warranty-link <> 0:
                  v-trans.void = YES.
                END.

                FIND v-trans WHERE RECID(v-trans) = v_rec.
                IF AVAILABLE v-trans THEN
                DO:
                  RUN reopenquery.
                  RUN showdipfield.
                  RETURN NO-APPLY.
                END.
                RETURN.
              END.

              ELSE
              DO:
                RUN reopenquery.
              END.

              FIND v-trans WHERE RECID(v-trans) = v_rec.
              VIEW FRAME fr-total2.
              VIEW FRAME fr-keys.
              RUN reopenquery.
              RUN showdipfield.
              oMsg:msg-refresh().
              RETURN NO-APPLY.
            END.

      IF v-trans.estat <> "C" AND v-trans.serial-no <> ""
        AND is_exch  THEN
      DO:  /* C means backing out of buy/exchange */
        v-trans.estat = SUBSTRING(act-todo,1,1).
        v-trans.item-status = act-todo.
      END.
      ELSE IF v-trans.estat <> "E" AND v-trans.estat <> "R"
          AND v-trans.estat <> "B" AND v-trans.estat <> "P"
          THEN
          IF v-trans.disc-per <> 0 THEN v-trans.estat = "*".
          ELSE v-trans.estat = "".
    END.
    VIEW FRAME fr-total2.
    VIEW FRAME fr-keys.
    RUN reopenquery.
    RUN showdipfield.
  END.

/* @(#) rntrig-100.i 1.3 03/27/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-100.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON F8 OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE x        AS INTEGER.
    DEFINE VARIABLE klm      AS INTEGER.
    DEFINE VARIABLE p-rec    AS RECID   NO-UNDO.
    DEFINE VARIABLE t-second AS LOG     NO-UNDO.
    IF v-trans.serial-no = "" THEN
    DO:
      PAUSE 0 NO-MESSAGE.
      RETURN.
    END.
    IF AVAILABLE v-trans
      AND (v-trans.sku-no = 0351993 OR v-trans.sku-no = 422888) THEN
      RETURN NO-APPLY. /*COUPON */
    ASSIGN
      t-discount-note = ""
      t-disc-reason   = "".

    DO x = 1 TO cust-browse:down.
      IF cust-browse:is-row-selected(x) THEN LEAVE.
    END.
    rwpos = x.
    t-screenvalue = v-trans.orig-value .
    t-screenrate = v-trans.rent-rate.
    PAUSE 0 NO-MESSAGE.
    t-tot2 = t-tot2 - v-trans.orig-value * v-trans.qty.
    /* subtract the old total */
    IF SUBSTRING(v-trans.serial-no,1,3) = "SKU" AND
      v-trans.serial-no <> "SKU# 0000040" AND
      v-trans.old-item = NO THEN
    DO:

      /* loop on quantity field --------***/
      DEFINE VARIABLE x-qty    AS INTEGER NO-UNDO.
      DEFINE VARIABLE t-endkey AS LOG     NO-UNDO.
      loopxa: REPEAT ON ERROR UNDO loopxa, LEAVE loopxa
        ON ENDKEY UNDO loopxa, LEAVE loopxa:
        RUN screenrefresh.
        PAUSE 0 NO-MESSAGE.
        FIND inv-master NO-LOCK
          WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
        IF v-trans.estat = "p" AND (inv-master.serial-reqd = "r"
          OR neverUsed(inv-master.sku-no) = YES) THEN
        DO:
          RUN rn-qtynew.p(INPUT-OUTPUT x-qty,
            bl-row, offset, OUTPUT t-endkey).
          v-trans.qty-new = x-qty.
          IF LASTKEY = keycode("f4") OR t-endkey THEN
          DO:
            DELETE v-trans.
            RETURN.
          /* delete this line */
          END.
          IF x-qty > 0 THEN v-trans.qty = x-qty.
          v-trans.extended = v-trans.orig-value * v-trans.qty.
        END.

        ELSE IF v-trans.sku-no = 28 AND t-funct-name = "rental.create" THEN
          DO:
            IF v-trans.orig-value = 0 THEN v-trans.orig-value = 10.
            RUN rn-qty.p(INPUT-OUTPUT x-qty,
              INPUT-OUTPUT v-trans.qty-new,
              bl-row, offset, OUTPUT t-endkey).

            IF x-qty > 0 THEN v-trans.qty = x-qty.
            IF LASTKEY = keycode("f4") OR t-endkey THEN
            DO:

              DELETE v-trans.
              RETURN.

            /* delete this line */
            END.
          END.

          ELSE
          DO:
            IF v-trans.sku-no <> 61 AND NOT v-trans.line-desc[1] BEGINS "RH"
              THEN
            DO:
              RUN rn-qty.p(INPUT-OUTPUT x-qty,
                INPUT-OUTPUT v-trans.qty-new,
                bl-row, offset, OUTPUT t-endkey).

              IF x-qty > 0 THEN v-trans.qty = x-qty.
              IF v-trans.estat = "p" THEN
              DO:
                v-trans.extended = v-trans.orig-value * v-trans.qty.
              END.
            END.
          END.
        IF LASTKEY <> keycode("f4") THEN PAUSE 0 NO-MESSAGE.
        IF v-trans.description = "" THEN
        DO:
          FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no
            NO-ERROR.
          IF AVAILABLE inv-master THEN
            v-trans.description = inv-master.description.
        END.

        IF p-rent-code BEGINS "re" THEN
        DO:
          v-trans.avg-cost = v-trans.orig-value.
          IF v-trans.estat <> "p" THEN
          DO:
            RUN regularrent(OUTPUT v-trans.extended).
          END.
          ELSE
            v-trans.extended = v-trans.orig-value * v-trans.qty.
        END.
        IF order.rent-code = "school" THEN
        DO:
          RUN rsSchoolProrate.p("school", v-trans.sku-no,
            v-trans.dt-rented, OUTPUT v-trans.percent). /*  */
          IF MONTH(TODAY) = 6 THEN
            v-trans.percent = v-trans.est-repair-cost / v-trans.rent-rate.
          IF TODAY >= date(06,30,YEAR(year-end)) AND TODAY <=
            date(10,31,YEAR(year-end))
            AND tyears = 1 THEN v-trans.percent = 1.
          ELSE IF tyears = 1 AND year-end = TODAY AND order.dt-due = TODAY THEN
              v-trans.percent = 0.
          IF AVAILABLE order AND order.dt-due > year-end THEN
          DO:
            v-trans.percent = v-trans.percent + 1.
            v-trans.extended
            = v-trans.orig-value * v-trans.qty * v-trans.percent.
          END.
        END.
        LEAVE loopxa.
      END.
    END.
    /********* L00P ON NET VALUE ****************/
    IF is-warranty-sku(v-trans.sku-no) AND v-trans.estat = "P" THEN
    DO:
      FIND FIRST b-trans NO-LOCK WHERE b-trans.sku-no = 422888 NO-ERROR.
      /****** TRICK THE PROGRAM INTO ALLOWING ENTRY TO OVER-WRITE WARRANTY
              WHEN A SKU 42888 EXISTS ********/
      /*if avail b-trans then */
      DO: /*task 5943 allow any warranty change*/
        IF v-trans.create-value = 0 THEN  /* assign only once */
          v-trans.create-value = v-trans.orig-value.
        ASSIGN  /* snapshot in case of f6 */
          v-trans.before-value = v-trans.orig-value
          v-trans.estat        = "".
      END.
    END.   /* now warranty will fall into the loop ***/
    /* dont change orig-value once the buy has been made. */
    IF v-trans.estat <> "B" AND v-trans.estat <> "P" THEN
    loopx: DO ON ERROR UNDO loopx, LEAVE loopx
      ON ENDKEY UNDO loopx, LEAVE loopx:
      IF v-trans.estat = "R" THEN LEAVE loopx.
      IF p-rent-code = "rentown"
        AND NOT v-trans.serial-no BEGINS "sku#" THEN
      DO:
        IF v-trans.old-item = YES THEN RETURN.
        DEFINE VARIABLE t-rto-amt AS DECIMAL.
        DEFINE VARIABLE t-type    AS CHARACTER.
        FIND inv-locsrl NO-LOCK WHERE inv-locsrl.serial-no = v-trans.serial-no
          AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
        IF AVAILABLE inv-locsrl THEN
          t-old-value = get-current-retail(inv-locsrl.sku-no,
            inv-locsrl.serial-no).
        ELSE IF NOT AVAILABLE inv-locsrl THEN
          DO:  /* vlocsrl */
            FIND inv-master NO-LOCK
              WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
            RUN im/get-price.p
              (v-trans.sku-no,"",YES,OUTPUT t-old-value,OUTPUT t-type).
          END.
        IF is-generic(v-trans.sku-no) AND t-old-value = 0 THEN
          t-old-value = v-trans.over-retail.
        t-rto-amt = t-old-value.
        t-screenvalue = v-trans.orig-value.
        t-screenrate =  v-trans.rent-rate.
        RUN rn-rtovalue.p(INPUT-OUTPUT t-rto-amt,
          bl-row, offset, OUTPUT tz-endkey).
        IF tz-endkey THEN.
        ELSE
          ASSIGN v-trans.avg-cost = v-trans.orig-value.
      END.

      ELSE
      DO:
        IF v-trans.item-status = "BUY" OR v-trans.estat = "P"  THEN
          MESSAGE "Change This Amount to Match the Buy Amount You Want.".
        ELSE
          MESSAGE "Change The Original Value Amount Recorded on Contract".

        DISPLAY v-trans.orig-value WITH FRAME jku OVERLAY.

        oMsg:msg-hide().
        ENABLE v-trans.orig-value WITH FRAME jku OVERLAY
          NO-BOX NO-LABELS ROW rwpos + offset + 1 COL 45.
        APPLY "entry" TO v-trans.orig-value IN FRAME jku.
        REPEAT:    /* since f8 also clears the field we allow the following */
          WAIT-FOR RETURN, f8, f4 OF v-trans.orig-value IN FRAME jku.
          IF v-trans.orig-value = ? THEN v-trans.orig-value = 0.
          IF dec(v-trans.orig-value:screen-value) = ? THEN
            ASSIGN v-trans.orig-value:screen-value = STRING(v-trans.orig-value).

          IF LASTKEY = keycode("f4") OR LASTKEY = keycode("endkey")
            OR v-trans.orig-value
            = dec(v-trans.orig-value:screen-value IN FRAME jku)
            THEN
          DO:
            ASSIGN
              v-trans.orig-value:screen-value IN FRAME jku = STRING(v-trans.orig-value).
          END.
          ELSE
          DO:
            /** TEST THIS SECTION BELOW it does not look right ***/
            DEFINE VARIABLE tempserial LIKE v-trans.serial-no.
            tempserial = v-trans.serial-no.
            IF AVAILABLE v-trans AND v-trans.qty-new > 0 THEN
              v-trans.serial-no = "". /* this means the sku# is new */
            FIND cust-grp NO-LOCK
              WHERE cust-grp.cust-no = order.cust-no
              AND cust-grp.grp-no = 15 NO-ERROR.
            IF NOT AVAILABLE cust-grp THEN
            DO:

              IF NOT is-generic(v-trans.sku-no)  THEN
              DO:

                IF NOT v-trans.serial-no BEGINS "sku#" THEN
                DO:
                  t-endkey = YES.

                  p-rec = RECID(v-trans).
                  DEFINE VARIABLE t-disc-cnt AS INTEGER NO-UNDO.
                  FOR EACH v-trans:

                    IF v-trans.disc-reason <> "" THEN
                    DO:
                      t-disc-reason = v-trans.disc-reason.
                      t-discount-note = v-trans.discount-note.
                      IF RECID(v-trans) <> p-rec THEN
                      DO:
                        t-disc-cnt = t-disc-cnt + 1.
                      END.
                    END.
                  END.
                  IF t-disc-cnt = 1 THEN ASSIGN tx-msg   = YES t-second = NO.
                  IF tx-msg = NO THEN
                    ASSIGN t-disc-reason   = "" t-discount-note = "".
                  IF tx-msg = YES AND t-disc-cnt > 1 THEN t-second = YES.
                  FIND v-trans WHERE RECID(v-trans) = p-rec.

                  IF p-rent-code = "regular" THEN
                  DO:
                    RUN rn-disc-reason.p(order.cust-no, v-trans.sku-no,
                      v-trans.serial-no, "F8-RENT",INPUT-OUTPUT tx-msg,
                      t-second, INPUT-OUTPUT t-discount-note,
                      INPUT-OUTPUT t-disc-reason, OUTPUT t-endkey).
                  END.

                END.
              END.
            END.
            v-trans.serial-no = tempserial.
            oMsg:msg-refresh().

            IF t-endkey = NO OR p-rent-code <> "regular" THEN
            DO:
              /* continue on to orig-value box */
              v-trans.disc-reason = t-disc-reason.
              v-trans.discount-note = t-discount-note.
            END.
            ELSE
            DO:
              ASSIGN
                v-trans.orig-value:screen-value IN FRAME jku = STRING(v-trans.orig-value).
              DISPLAY v-trans.orig-value WITH FRAME jku OVERLAY.
              PAUSE 0 NO-MESSAGE.
            END.
          END.

          IF LASTKEY <> keycode("f4") THEN
          DO:
            ASSIGN v-trans.orig-value.
            IF v-trans.orig-value < 0 THEN
              v-trans.orig-value = v-trans.orig-value * -1.
            ASSIGN
              v-trans.avg-cost = v-trans.orig-value.
          END.
          IF LASTKEY = keycode("f8") THEN
          DO:
            IF v-trans.orig-value = 0 THEN
            DO:
              MESSAGE
                "Apply F7 KEY TO RESTORE THE ORIGINAL VALUE OR HIT ENTER TO RETURN.".
              PAUSE 3 NO-MESSAGE.
            END.
          END.
          ELSE
          DO:
            LEAVE.
          END.
        END.

        HIDE MESSAGE NO-PAUSE.
        ASSIGN v-trans.orig-value.
        IF v-trans.orig-value < 0 THEN
          v-trans.orig-value = v-trans.orig-value * -1.
        ASSIGN
          v-trans.avg-cost    = v-trans.orig-value
          v-trans.after-value = v-trans.orig-value.
        DISABLE v-trans.orig-value WITH FRAME jku.

      END. /* end of t-endkey */
      /***** TRICK THE PROGRAM ON THE WARRANTY SKU TO BLOCK ENTRY
          INTO RENT RATES BY RE-INSTATING THE PURCHASE FLAG ***/
      IF is-warranty-sku(v-trans.sku-no) THEN
        v-trans.estat = "P" .
      IF v-trans.item-status = "BUY" OR v-trans.estat = "P" THEN
      DO:
        v-trans.extended = v-trans.orig-value * v-trans.qty.
      END.
      ELSE
      DO:   /* only access rent rate and paid fields when a rental */
        PAUSE 0 NO-MESSAGE.
        /********** DONT ENTER RATE FIELD IF ALREADY ON RENTAL
        UNLESS AN EXCEPTION CAN BE MADE TO CORRECT A RATE INVARIANCE ******/
        DEFINE VARIABLE SchRateMay AS LOG NO-UNDO.
        IF v-trans.old-item = YES THEN
        DO:
          FIND syscust NO-LOCK WHERE syscust.type = "rn" NO-ERROR.
          IF p-rent-code = "school" AND AVAILABLE syscust
            AND MONTH(TODAY) = month(DATE(syscust.CHA-FLAG[3])) THEN
          DO:
            IF DAY(TODAY) < day(DATE(syscust.CHA-FLAG[3])) THEN
            DO:
              IF order.dt-due > TODAY AND v-trans.sku-no <> 28
                AND v-trans.estat = "" AND tschCostShare = NO
                AND tschCostShareValue = 0 AND year-end = order.dt-due
                AND YEAR(order.dt-due) = year(TODAY) THEN
              DO:
                SchRateMay = YES.
                IF v-trans.orig-rentrate = 0 THEN
                  v-trans.orig-rentrate = v-trans.rent-rate.
              END.
            END.
          END.
          ELSE IF p-rent-code = "school" AND
              tschCostShare AND tschCostShareValue <> 0 THEN LEAVE loopx.
            ELSE LEAVE loopx.
        END.
        IF v-trans.old-item = NO OR SchRateMay THEN
        DO:
          DO:
            DISPLAY v-trans.rent-rate WITH FRAME mjku OVERLAY.
            ENABLE v-trans.rent-rate WITH FRAME mjku OVERLAY
              NO-BOX NO-LABELS ROW rwpos + offset + 1 COL 57.
            t-orig-rate = v-trans.rent-rate.
            APPLY "entry" TO v-trans.rent-rate IN FRAME mjku.
            WAIT-FOR RETURN OF v-trans.rent-rate IN FRAME mjku.
            IF dec(v-trans.rent-rate:screen-value) = ? THEN
              ASSIGN v-trans.rent-rate:screen-value = STRING(t-orig-rate).
            IF dec(v-trans.rent-rate:screen-value) < 0 THEN
            DO:
              DEFINE VARIABLE yyt AS DECIMAL.
              yyt = dec(v-trans.rent-rate:screen-value) * - 1.
              v-trans.rent-rate:screen-value = STRING(yyt).
            END.
            t-endkey = YES.
            p-rec = RECID(v-trans).
            ASSIGN
              t-disc-reason   = ""
              t-discount-note = "".

            FIND v-trans WHERE RECID(v-trans) = p-rec.
            IF v-trans.rent-rate =  dec(v-trans.rent-rate:screen-value)
              OR LASTKEY = keycode("f4") THEN
            DO:
            /* do nothing on f4 */

            END.
            ELSE IF p-rent-code = "regular" THEN
              DO:
                RUN rn-disc-reason.p(order.cust-no, v-trans.sku-no,
                  v-trans.serial-no, "F8-RATE",INPUT-OUTPUT tx-msg, t-second,
                  INPUT-OUTPUT t-discount-note,
                  INPUT-OUTPUT t-disc-reason, OUTPUT t-endkey).
                oMsg:msg-refresh().
              END.

            IF t-endkey = NO THEN
            DO:    /* continue on to orig-value box */
              /* THE FOLLOWING SAYS DONT RECORD IF ON AN EXCHANGE */
              /* if v-trans.item-no = v-trans.link-rent then do: */
              ASSIGN
                v-trans.rate-no     = t-disc-reason
                v-trans.rate-reason = t-discount-note.
            END.
            ELSE
            DO:
              IF p-rent-code = "regular" THEN
              DO:
                ASSIGN
                  v-trans.orig-value:screen-value IN FRAME jku = STRING(v-trans.orig-value).
                DISPLAY v-trans.orig-value WITH FRAME jku OVERLAY.
                IF p-rent-code = "regular" THEN
                  ASSIGN v-trans.rent-rate:screen-value = STRING(v-trans.rent-rate).
                PAUSE 0 NO-MESSAGE.
              END.
            END.
            DISABLE v-trans.rent-rate WITH FRAME mjku.
            IF v-trans.rent-rate < 0 /* always positive value */
              THEN v-trans.rent-rate = v-trans.rent-rate * -1.
            IF p-rent-code <> "billing" AND p-rent-code <> "school" THEN
              ASSIGN v-trans.rent-rate = ROUND(dec(v-trans.rent-rate:screen-value),0).
            ELSE
            DO:
              IF p-rent-code = "school" THEN
              DO: /* store the month value */
                IF v-trans.est-repair-cost = 0 AND v-trans.billing <> 0 THEN
                  v-trans.est-repair-cost = v-trans.billing.
                IF schRateMay THEN
                DO:  /* task 2671 */
                  /* allow assignment but block exchange buy or return afterwards */
                  IF v-trans.rent-rate <> dec(v-trans.rent-rate:screen-value) THEN
                    v-trans.estat = "C".
                END.
              END.  /* assign for both school and billing */
              v-trans.rent-rate = dec(v-trans.rent-rate:screen-value).
              IF p-rent-code = "school" AND tAcceptPass = NO  THEN
              DO:
                /* bypass of costshare on f8 additional task 2772 */

                IF v-trans.old-item = NO THEN
                  v-trans.extended = v-trans.rent-rate * v-trans.qty.
                IF NOT v-trans.pInvRentExists AND v-trans.old-item = NO THEN
                  v-trans.est-repair-cost = .08 * v-trans.rent-rate * v-trans.qty.
                IF v-trans.after-rate <> v-trans.rent-rate THEN
                  v-trans.after-rate = v-trans.rent-rate.
              END.
            END.

            IF p-rent-code BEGINS "rentown" AND NOT f9active THEN
            DO:
              /* treat as used item if over-riding the new cost */
              IF v-trans.qty-new <> 0 THEN
              DO:
                RUN rto-cost(YES, OUTPUT tz-endkey, t-rto-amt,
                  v-trans.serial-no, YES).
                IF tz-endkey THEN
                DO:
                  v-trans.orig-value = t-screenvalue.
                  v-trans.rent-rate = t-screenrate.
                END.
              END.
              ELSE
              DO:
                RUN rto-cost(NO, OUTPUT tz-endkey, t-rto-amt,
                  v-trans.serial-no, YES).
                IF tz-endkey THEN
                DO:
                  v-trans.orig-value = t-screenvalue.
                  v-trans.rent-rate = t-screenrate.
                END.
              END.
            END.

            IF p-rent-code BEGINS "re" AND NOT f9active
              AND v-trans.estat <> "e" AND v-trans.estat <> "p" THEN
            DO:
              RUN regularrent(OUTPUT v-trans.extended).
            END.

            /* If there has been an exchange and we adjust the rental rate we need 
               to account for this in the rate variation. If this is not done the 
               amounts charged will not be accurate. Rate var is the difference between
               the rental amounts between 2 skus during the original rental. Since 
               rentals are calculated from the start date we need this offset to be right */
            ELSE IF NOT f9active AND v-trans.estat = "e" THEN
              DO:
                /* Get the record of the original rental item */
                FIND b-trans WHERE b-trans.item-no = v-trans.link-rent NO-ERROR.
                IF AVAILABLE b-trans THEN
                DO:
                  DEFINE VARIABLE old-date  AS DATE    NO-UNDO.
                  DEFINE VARIABLE p-rt-days AS INTEGER NO-UNDO.
                  DEFINE VARIABLE ratevar   LIKE order-i.rate-var.
                  DEFINE VARIABLE curRecid  AS RECID.
                  DEFINE VARIABLE oldrecid  AS RECID.
                  oldrecid = RECID(b-trans).
                  curRecid = RECID(v-trans).
                  /*AUG 25TH SCHOOL EXCHANGE */
                  IF p-rent-code = "school" THEN
                  DO:
                    RUN rnSchYearExch.p(b-trans.rent-rate, v-trans.rent-rate,
                      tSchCostShare, OUTPUT v-trans.retail ).
                    RUN rnSchRateVar.p(RECID(b-trans),RECID(v-trans)).
                    /* special case in month of may only n/c on same ser# exchange*/
                    IF AVAILABLE b-trans AND b-trans.serial-no = v-trans.serial-no
                      AND b-trans.sku-no = v-trans.sku-no THEN
                    DO:
                      ASSIGN
                        v-trans.extended = v-trans.extended - v-trans.retail.
                      v-trans.retail = 0.
                    END.
                  END.
                  ELSE
                  DO:
                    RUN rnGetExchDate.p(buffer order, b-trans.link-rent,
                      b-trans.item-no, OUTPUT old-date, OUTPUT ratevar).
                    FIND v-trans WHERE RECID(v-trans) = curRecid NO-ERROR.
                    IF old-date = ? THEN old-date = b-trans.dt-rented.
                    RUN effectdays.p(old-date, TODAY,  OUTPUT p-rt-days).
                    IF p-rent-code BEGINS "re" OR p-rent-code = "billing" THEN
                    DO:
                      IF p-rt-days = 0 THEN ratevar = 0.
                      ELSE ratevar
                        = ((b-trans.rent-rate - v-trans.rent-rate) / 30) * p-rt-days.
                      v-trans.rate-var = b-trans.rate-var + ratevar.
                    END.
                  END.
                END.
              END.
              /* ALSO SHOULD PRORATE FOR SCHOOL AFTER ASSIGN OF F8 RATE ****/
              ELSE IF (p-status = "create" AND NOT f9active)
                  OR (v-trans.old-item = NO AND NOT f9active)
                  AND (order.order-no BEGINS "rs") THEN
                DO:
                  /* ReProrate on change of rental rate */
                  /* NEED TO RESET est-repair-cost at order-i */
                  RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
                    v-trans.dt-rented, OUTPUT v-trans.percent).
                  IF tAcceptPass AND v-trans.old-item = NO THEN v-trans.percent = 1.
                  IF tyears = 1 AND TODAY >=
                    date(06,30,YEAR(year-end)) AND TODAY <= date(10,31,YEAR(year-end))
                    THEN v-trans.percent = 1.
                  IF tyears = 1 AND  year-end = TODAY AND order.dt-due = TODAY THEN
                    v-trans.percent = 0.
                  IF v-trans.sku-no = 28 THEN
                  DO: /* fixes part year and advance *qty*/
                    RUN newSchTestCalcsAug12.p(buffer order, v-trans.item-no,
                      year-end,tSchCostShare, tSchCostShareValue,
                      OUTPUT v-trans.extended).
                    v-trans.origextend = v-trans.extended.
                  END.
                  ELSE
                  DO:
                    RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
                      v-trans.dt-rented, OUTPUT v-trans.percent).
                    IF tAcceptPass AND v-trans.old-item = NO THEN v-trans.percent = 1.
                    IF TODAY >= date(06,30,YEAR(year-end)) AND tyears = 1
                      AND TODAY <= date(10,31,YEAR(year-end))
                      THEN v-trans.percent = 1.
                    IF tyears = 1 AND  year-end = TODAY AND order.dt-due = TODAY THEN
                      v-trans.percent = 0.			
                    IF order.rent-code = "SCHOOL" THEN
                      RUN newSchTestCalcsAug12.p(buffer order, v-trans.item-no,
                        year-end,tSchCostShare, tSchCostShareValue,
                        OUTPUT v-trans.extended).
                    /*8411 RS Monthly price override*/
                    ELSE IF order.rent-code = "billing" THEN
                        v-trans.extended = v-trans.rent-rate.
                    v-trans.origextend = v-trans.extended.
                  END.
                END.
          END.   /* next would only work on rent to own when new */
        END.
        IF NOT f9active THEN
          RUN setupframef(NO, YES). /* must have when not f9active */
        IF p-rent-code BEGINS "re" AND NOT f9active THEN NEXT.

      /* rent to own back office */
      END.
    END. /* loopx */
    IF NOT p-rent-code BEGINS "Re" THEN PAUSE 0 NO-MESSAGE. /*aug 05*/
    HIDE FRAME tyu NO-PAUSE. /* do these here to avoid flashing */
    HIDE FRAME vxx NO-PAUSE.
    HIDE FRAME jku NO-PAUSE.
    HIDE FRAME mjku NO-PAUSE.
    RUN setupframef(NO, YES).
  END.

/* @(#) rntrig-110.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-110.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f9 OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE t-value AS CHARACTER NO-UNDO.
    DEFINE VARIABLE tdays   AS INTEGER.
    DEFINE VARIABLE tAns    AS LOG       NO-UNDO.
    /* also runs line- description  */
    IF tSchCostShare OR tAcceptPass THEN RETURN NO-APPLY.
    IF v-trans.product-no = "" THEN
      DISABLE e WITH FRAME f.
    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
    oMsg:msg-hide().

    RUN rs-f9submenu.p( s-link-order, gwkreg, t-loc-code, v-trans.item-no,
      OUTPUT t-value).
    IF V-TRANS.product-no = "" THEN ENABLE e WITH FRAME f.
    /*9807 Add option to change Ship To flag*/
    IF t-value = "Ship To Customer" THEN
    DO:
      MESSAGE "This contract is currently Ship To Customer:" + string(tShipDirect) +
        ". Would you like to change it to:"  + (IF tShipDirect = YES THEN "no?" ELSE "yes?")
        VIEW-AS ALERT-BOX BUTTONS YES-NO UPDATE tAns.
      IF tAns = YES THEN ASSIGN
          tShipDirect = NOT tShipDirect.
    END.
    IF t-value = "SWITCH CONTRACT" THEN
    DO:
      DEFINE VARIABLE x-endkey AS LOG NO-UNDO.
      RUN setupframef(YES, YES).
      HIDE FRAME brws-frame NO-PAUSE.
      DISABLE e WITH FRAME f.
      HIDE FRAME f NO-PAUSE.
      HIDE FRAME fr-total2 NO-PAUSE.
      HIDE FRAME fr-descrip NO-PAUSE.
      IF p-rent-code = "school" THEN
      DO:
        /**** assign after-rate in case of toggle on and off ***/
        FOR EACH v-trans:
          IF v-trans.rent-rate <> 0 AND v-trans.after-rate = 0 THEN
            v-trans.after-rate = v-trans.rent-rate.
        END.
      END.
      RUN rs-switch.p(buffer order, INPUT-OUTPUT p-rent-code,
        INPUT-OUTPUT chg-code, OUTPUT t-date-due, OUTPUT x-endkey).

      IF x-endkey = NO THEN
      DO:
        IF t-date-due = ? THEN  t-date-due = order.dt-due. /* case on f4 */
        t-dt-enter = t-date-due .
        s-dt-return = t-dt-enter.
        FOR EACH v-trans:
          IF v-trans.estat = "P" OR v-trans.estat = "B" THEN
          DO:
            v-trans.extended = v-trans.orig-value * v-trans.qty.
            v-trans.retail = v-trans.extended.
          END.
          ELSE
          DO:
            IF p-rent-code = "Billing" THEN
            DO:
              IF v-trans.estat = "P" OR v-trans.estat = "B" THEN
                v-trans.extended = v-trans.orig-value * v-trans.qty.
              IF v-trans.product-no <> "" THEN
              DO:
                ASSIGN   /* default one month */
                  v-trans.rent-rate = v-trans.est-repair-cost
                  v-trans.extended  = v-trans.rent-rate * v-trans.qty
                  v-trans.retail    = v-trans.extended.
                IF v-trans.rent-rate <> 0 THEN
                DO:
                  RUN effectdays.p(TODAY, t-date-due, OUTPUT tdays).
                  ASSIGN
                    v-trans.extended = v-trans.rent-rate / 30 * tdays
                    v-trans.extended = v-trans.extended * v-trans.qty
                    v-trans.extended = ROUND(v-trans.extended,2)
                    v-trans.retail   = v-trans.extended.
                END.
              END.
            END.
            ELSE
            DO:
              IF v-trans.sku-no = 28 THEN
                v-trans.after-rate = 10.
              ASSIGN
                v-trans.rent-rate = v-trans.yearly
                v-trans.extended  = (v-trans.rent-rate * v-trans.qty) * v-trans.percent.
              v-trans.retail = v-trans.extended.
            END.
          END.
        END.
      END.
      VIEW FRAME brws-frame.
      VIEW FRAME f .
      VIEW FRAME fr-total2.
      VIEW FRAME fr-descrip.
    END.

    /*run rs-f9submenu.p( s-link-order, gwkreg, t-loc-code, v-trans.item-no,
    output t-value).
    IF V-TRANS.product-no = "" then enable e with frame f.
    */
    oMsg:msg-refresh().
    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
    IF t-value = "INVENTORY MAINTENANCE" THEN RUN time.p.
    VIEW FRAME fr-ord.
    RUN displaycust.
    PAUSE 0 NO-MESSAGE.
    RUN setupframef(NO, YES).
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-120.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-120.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON F10 OF cust-browse IN FRAME brws-frame
  DO:
    IF p-status = "create" THEN RETURN NO-APPLY.
    IF v-trans.estat = "" THEN
    DO:
      IF (v-trans.qty >= 1 AND t-funct-name = "loan.create")
        AND v-trans.serial-no BEGINS "sku#" THEN
      DO:
        /* THE CYCLING IS BAD WHEN MULTIPLE LINES OF MS-205B */
        RUN returnloan-tonew(v-trans.item-no).
      END.
      ELSE
      DO:
        v-trans.qty-new = 0.  /* how does this get undone */
        RUN rentirtn.
        IF v-trans.old-item <> NO THEN
          v-trans.estat = "R".
      END.
    END.
    ELSE IF v-trans.estat = "R" THEN
      DO:
        RUN undoreturn.
        v-trans.estat = "".
        IF v-trans.sku-no = 28 THEN v-trans.extended = v-trans.amt-received.
      END.
    RUN correcttotal.
    RUN displaytotal.
    VIEW FRAME fr-total2.
    VIEW FRAME fr-keys.
    VIEW FRAME cust-brwse.
    status-ok = cust-browse:refresh().
    APPLY "cursor-down" TO cust-browse IN FRAME brws-frame .
  END.

/* @(#) rntrig-130.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-130.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f1 OF cust-browse IN FRAME brws-frame
  DO:

    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
    oMsg:msg-hide().
    RUN rs-linedesc.p.
    oMsg:msg-refresh().
    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
    VIEW FRAME fr-ord.
    RUN displaycust.
    PAUSE 0 NO-MESSAGE.
    RUN setupframef(NO, YES).
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-140.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-140.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON F11 OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE t-chose AS LOG NO-UNDO.
    FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.

    IF AVAILABLE order THEN
    DO:
      FIND ord-lywy OF order EXCLUSIVE-LOCK NO-ERROR.
      IF NOT AVAILABLE ord-lywy THEN
      DO:
        CREATE ord-lywy.
        ord-lywy.link-order = order.link-order.
        FIND employee NO-LOCK WHERE employee.empl-no = t-empl-id NO-ERROR.
        IF AVAILABLE employee THEN
          ord-lywy.comment[4] = STRING(employee.name) + " " + string(TODAY).
      END.
    FORMAT {ps-getlywy.f}.
      DO WHILE TRUE:
        UPDATE TEXT(ord-lywy.comment) GO-ON(f4) WITH FRAME fr-lywy.
        HIDE FRAME fr-lywy NO-PAUSE.
        VIEW FRAME fr-total2.
        VIEW FRAME brws-frame.

        RUN screenrefresh.
        APPLY "entry" TO cust-browse IN FRAME brws-frame.
        PAUSE 0 NO-MESSAGE.
        VIEW e IN FRAME f.  /* somehow wait-for still needs enabling */
        PAUSE 0 NO-MESSAGE.
        RETURN NO-APPLY.
      END.
    END.
    ELSE UPDATE TEXT(ord-lywy.comment) WITH FRAME fr-lywy.
    HIDE FRAME fr-lywy NO-PAUSE.
    VIEW FRAME fr-total2.
    VIEW FRAME brws-frame.
    RUN screenrefresh.
    APPLY "entry" TO cust-browse IN FRAME brws-frame.
    VIEW e IN FRAME f.
    PAUSE 0 NO-MESSAGE.
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-150.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-150.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON f12 OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE p-test   AS LOG INIT NO NO-UNDO.
    DEFINE VARIABLE p-endkey AS LOG NO-UNDO.
    IF is_suspend THEN RETURN NO-APPLY.
    IF t-leaveout THEN RETURN NO-APPLY.

    IF order.rent-code = "SCHOOL" OR order.rent-code = "billing" THEN
    DO:
      F3BANDATTENDER = NO. /* SKIP SCHOOL DATE SCREEN */
      IF tShipDirect THEN
      DO: /*9807*/
        HIDE FRAME fr-display NO-PAUSE.
        RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
        oMsg:msg-hide().
        RUN ps/get-lywy-shipto.p(order.link-order
          ,order.cust-no
          ,"update,picked-up-by,shipInsure,OnHold"
          ,OUTPUT p-endkey).
        oMsg:msg-refresh().
        RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
        VIEW FRAME fr-display.
      END.
    END.
    RUN rnChkReopen.p(buffer order, OUTPUT p-test).
    IF p-test = NO THEN
    DO:
      IF is_exch THEN
      DO:
        MESSAGE
          "AN EXCHANGED ITEM HAS BEEN FOUND, BUT THE EXCHANGE HAS NOT BEEN COMPLETED."
          SKIP
          "PLEASE COMPLETE OR CANCEL THE EXCHANGE TO MOVE FORWARD."
          VIEW-AS ALERT-BOX.
        RETURN NO-APPLY.  /* middle of exchange so go back */
      END.
      IF (order.rent-code = "school" OR order.rent-code = "billing")
        AND order.int-status = "create" THEN
      DO:
        FIND FIRST v-trans NO-LOCK WHERE v-trans.sku-no > 0 AND
          v-trans.sku-no <> 28 AND v-trans.sku-no < 9999990 NO-ERROR.
        IF NOT AVAILABLE v-trans THEN
        DO:
          FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
          RETURN NO-APPLY.
        END.
      END.
      /* run checkRentHistory.p(output p-test).
      if not p-test then return no-apply.
      p-test = no.
      */
      IF t-holdit THEN
      DO:
        /* cannot f6 all items and go forward on create of a rental from hold */
        FIND FIRST v-trans NO-LOCK WHERE NOT v-trans.void
          AND v-trans.sku-no < 9999990 AND v-trans.sku-no <> 28
          AND v-trans.sku-no <> 0 AND v-trans.sku-no <> 351993
          NO-ERROR.
        IF NOT AVAILABLE v-trans THEN
        DO:
          MESSAGE "ONE ITEM IS REQUIRED ON A RENTAL CONTRACT IN ORDER TO PROCEED."
            SKIP
            "IF YOU ARE TRYING TO CANCEL A RENTAL HOLD, USE THE RENTAL HOLD PROGRAM."
            /*
            MESSAGE "RENTAL CONTRACTS ARE NOT CREATED TO REFUND COLLECTED AMOUNTS"
            SKIP "FROM HOLD CONTRACTS. USE THE F10 KEY IN THE HOLD PROGRAM TO RETURN"
            skip "ITEMS TO STOCK AND/OR REALIZE ANY CHARGES OR REFUNDS."
            */
            VIEW-AS ALERT-BOX.
          FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
          RETURN NO-APPLY.
        END.
      END.
      RUN rn-oneonly.p(INPUT p-rent-code, OUTPUT p-test).

      IF p-test THEN
        RETURN NO-APPLY.

      RUN rn-zero-rate.p(INPUT p-rent-code, OUTPUT p-test).
      IF p-test THEN
      DO:
        MESSAGE "SERIALIZED ITEMS MAY NOT HAVE A ZERO RENT RATE. " SKIP
          "USE F8 KEY TO CHANGE ITEM VALUE AND RENT RATE." VIEW-AS ALERT-BOX.
        RETURN NO-APPLY.
      END.
      RUN rn-patchcode.p(INPUT p-status, OUTPUT p-test).
      IF (order.order-no BEGINS "rs" OR order.order-no BEGINS "s")
        AND p-test = NO THEN
      DO:
        RETURN NO-APPLY.
      END.
      RUN loadorigextend(OUTPUT p-test).   /* version for v9 */
      IF p-test THEN RETURN NO-APPLY.
    END. /* SKIP CHECKS IF RE-OPENED */
    HIDE FRAME fr-descrip NO-PAUSE.

    tr-blk2: REPEAT  ON ERROR UNDO tr-blk2, LEAVE tr-blk2
    /* on endkey undo tr-blk2, leave tr-blk2 */  :
      STATUS INPUT "".
      RUN testsale.

      /* for schools disable the f9active key */

      IF s-issue < TODAY AND p-status = "create"
        AND NOT p-rent-code BEGINS "re" THEN f9active = NO.

      IF NOT f9active THEN
      DO:
        RUN cal_renttots.
        /* above calls item-screen.p which resets after-rate must reset */
        IF p-status = "create" AND p-rent-code = "billing" THEN
        DO:
          FOR EACH v-trans:
            IF v-trans.sku-no = 28 THEN v-trans.before-rate = 10.
            v-trans.after-rate = v-trans.before-rate.
          END.
        END.
        IF KEYFUNCTION(LASTKEY) = "end-error"
          OR (is-cancel AND p-rent-code BEGINS "re")
          OR (is-school AND p-rent-code = "school") THEN
        DO:
          FIND v-trans WHERE RECID(v-trans) = v_rec.
          is-school = NO.
          RUN reopenquery.
          VIEW FRAME brws-frame.
          PAUSE 0 NO-MESSAGE. /* must have */
          VIEW FRAME f.
          RUN displaytotal.
          PAUSE 0 NO-MESSAGE.  /* must have */
          oMsg:msg-refresh().
          APPLY "entry" TO e IN FRAME f.
          PAUSE 0 NO-MESSAGE.
          RETURN NO-APPLY.
        END.
      END.
      ELSE IF f9active AND p-rent-code BEGINS "re" THEN
        DO:
          /*def var chx-endkey as log init no.  task 4663
          run finalsale(output chx-endkey). */
          RUN backoffrent.

        END.

      tr-blk3: REPEAT:
        DO ON ENDKEY UNDO tr-blk3, LEAVE tr-blk3
        /* on error undo tr-blk3, leave tr-blk3 */ :
          DEFINE VARIABLE teststate AS LOG INIT NO. /* assume not a payment */

          /* force a patch here for regular rentals */
          IF NOT f9active THEN
            IF p-rent-code BEGINS "re" AND t-pay-enter = 0
              AND p-status = "create" AND discount = 0 AND NOT is-loan
              THEN
            DO:
              t-dt-enter = TODAY.
            END.
          DEFINE VARIABLE chk-endkey AS LOG INIT NO.
          RUN finalsale(OUTPUT chk-endkey).
          IF KEYFUNCTION(LASTKEY) = "end-error" OR chk-endkey
            AND NOT is_suspend THEN
          DO:
            PAUSE 0 NO-MESSAGE.
            FIND order NO-LOCK
              WHERE order.link-order = s-link-order NO-ERROR.
            LEAVE tr-blk3.
          END.
          ELSE
          DO:
            IF NOT is_suspend AND NOT f9active THEN
            DO:

              DEFINE VARIABLE t-endkey       AS LOG       NO-UNDO.
              DEFINE VARIABLE t-receipt-type AS CHARACTER NO-UNDO.
              DEFINE VARIABLE t-spec-note    AS LOG       NO-UNDO.

              RUN rn-longshort.p
                (BUFFER sale,NO,NO,OUTPUT t-endkey
                ,INPUT-OUTPUT t-receipt-type, OUTPUT t-spec-note).

              /* moved up here */
              FIND order WHERE order.link-order = t-hold-link NO-ERROR.
              IF AVAILABLE order THEN
              DO TRANSACTION:
                order.invoice-comment[2] = "".
                order.int-status = "picked up".
                order.close = YES.
              END.
              IF t-hold-link <> "" THEN RELEASE order.

              commit-sale = YES.  /* over-ride use of endkey */
              t-made-rental = YES.
              FIND order NO-LOCK
                WHERE order.link-order = s-link-order NO-ERROR.
              RUN rs-prntslip.p(0 ,YES, salrec, t-receipt-type, t-spec-note).
            END. /* end of not suspended */
            PAUSE 0 NO-MESSAGE.
            /* in case of suspend */
            commit-sale = YES.  /* over-ride use of endkey */
            t-made-rental = YES.
            FIND order WHERE order.link-order = t-hold-link NO-ERROR.
            IF AVAILABLE order THEN
            DO TRANSACTION:
              order.invoice-comment[2] = "".
              order.int-status = "picked up".
              order.close = YES.
            END.
            IF t-hold THEN
              FIND order NO-LOCK WHERE order.link-order = t-hold-link NO-ERROR.
            /* reset inv-locsrl for voided v-trans from "RH" contract */
            FOR EACH v-trans WHERE v-trans.void
              AND v-trans.line-desc[1] BEGINS "RH":
              IF NOT v-trans.serial-no BEGINS "SKU#" THEN
                RUN rs-invstatus.p(v-trans.serial-no, v-trans.sku-no, INPUT 0,
                  s-ordnum, order.loc-code, p-status).
            END.
            RETURN.
          END.
        END.
      END.      /* end of tr-blk3 */
    END.        /* end of tr-blk2 */
  END.

/* @(#) rntrig-160.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-160.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/


ON ctrl-c OF e IN FRAME f
  DO:
    MESSAGE "YOU ARE ABOUT TO EXIT " VIEW-AS ALERT-BOX.
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-170.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-170.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ctrl-g OF e IN FRAME f
  DO:
    DEFINE VARIABLE t-value AS cha NO-UNDO.
    DEFINE VARIABLE t-used  AS LOG NO-UNDO.
    parseCoupon = NO.
    t-scanin = NO.
    HIDE MESSAGE NO-PAUSE.
    oMsg:msg-hide().
    RUN get-scan.p("serial#",OUTPUT t-value,OUTPUT t-used).
    IF t-value <> "" THEN
    DO:
      IF t-value BEGINS "351993#" THEN
      DO:

        RUN ParseCoupon.p(t-value, v-trans.item-no, OUTPUT v-trans.sku-no,
          OUTPUT v-trans.serial-no, OUTPUT v-trans.description).
        t-scanin = NO.
        IF v-trans.description = "" THEN
          RETURN NO-APPLY.
        ELSE
        DO:
          parseCoupon = YES.
          status-ok = cust-browse:refresh() IN FRAME brws-frame.
          RUN newwtrans.
          RUN reopenquery.
          RUN showdipfield.
          oMsg:msg-refresh().
          FIND LAST v-trans WHERE v-trans.sku-no = 0 NO-ERROR.
          PAUSE 0 NO-MESSAGE. /* trying to stop press spacebar (if it exists) */
        END.
      END.
      ELSE
      DO:
        SELF:screen-value = t-value.
        t-scanin = YES.
        APPLY "enter" TO SELF.
      END.
    END.
    oMsg:msg-refresh().
    PAUSE 0 NO-MESSAGE.    /* trying to stop press spacebar (if it exists) */
    APPLY "enter" TO SELF.
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-180.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-180.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON page-down OF cust-browse IN FRAME brws-frame
  DO:
    RUN setupframef(NO, YES).
  END.

/* @(#) rntrig-190.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-190.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON CURSOR-UP OF cust-browse IN FRAME brws-frame
  DO:
    HIDE MESSAGE NO-PAUSE.
    i = i - 1.
    IF i = 0 THEN i = 1.
    IF p-rent-code = "rentown" THEN
    DO:
      IF v-trans.rent-rate <> 0 THEN ASSIGN
          t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
          t-rto-mth = (t-rto-tot - v-trans.deposit%) / v-trans.rent-rate.
      t-rto-mess = t-rtolab + string(t-rto-mth) +  t-rtolab1
        + string(t-rto-tot).
    END.

    ELSE t-rto-mess = "".
    DISPLAY v-trans.description v-trans.line-desc[2]
      t-rto-mess
      WITH FRAME fr-descrip ROW 15 COL 1.
  END.

/* @(#) rntrig-200.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-200.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON VALUE-CHANGED OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE x AS INTEGER.
    DO x = 1 TO cust-browse:down IN FRAME brws-frame.
      IF cust-browse:is-row-selected(x) THEN LEAVE.
    END.
    IF p-rent-code = "rentown" THEN
    DO:
      IF v-trans.rent-rate <> 0 THEN
        ASSIGN
          t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
          t-rto-mth = (t-rto-tot - v-trans.deposit%) / v-trans.rent-rate.
      t-rto-mess = t-rtolab + string(t-rto-mth) +  t-rtolab1
        + string(t-rto-tot).
    END.

    ELSE t-rto-mess = "".
    DISPLAY v-trans.description v-trans.line-desc[2]
      t-rto-mess
      WITH FRAME fr-descrip ROW 15 COL 1.
    rwpos = x.
    IF v-trans.serial-no = ""  THEN
    DO:
      i = x.   /* override page down position. */
      DISPLAY e WITH FRAME f.
      PAUSE 0 NO-MESSAGE.  /* sometimes sticks here, so need this */
      DO x = 1 TO cust-browse:down IN FRAME brws-frame.
        IF cust-browse:is-row-selected(x) THEN
        DO:
          IF p-rent-code = "rentown" THEN
          DO:
            IF v-trans.rent-rate <> 0 THEN ASSIGN
                t-rto-tot  = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit

                t-rto-mth  = (t-rto-tot - v-trans.deposit%) / v-trans.rent-rate
                t-rto-mess = t-rtolab + string(t-rto-mth) +  t-rtolab1
       + string(t-rto-tot).
          END.

          ELSE t-rto-mess = "".
          DISPLAY v-trans.description v-trans.line-desc[2]
            t-rto-mess
            WITH FRAME fr-descrip ROW 15 COL 1.
          HIDE FRAME fr-description NO-PAUSE.

          LEAVE.
        END.
      END.
      ENABLE e WITH FRAME f ROW rwpos + offset COL 4.
      APPLY "entry" TO e IN FRAME f.
      RETURN NO-APPLY.
    END.
  END.

/* @(#) rntrig-210.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-210.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON RETURN OF cust-browse IN FRAME brws-frame
  DO:
    APPLY "cursor-down" TO cust-browse IN FRAME brws-frame.
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-220.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-220.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON shift-F3 OF cust-browse IN FRAME brws-frame
  DO:
    IF order.order-no BEGINS "rs" OR order.order-no BEGINS "s" THEN
      RUN ss/pagefile.p("help/rn-newp2sch-hlp.txt","ADDING AN ITEM").
    ELSE IF order.order-no BEGINS "rn" OR order.order-no BEGINS "n" THEN
        RUN ss/pagefile.p("help/rn-newp2reg-hlp.txt","ADDING AN ITEM").
      ELSE IF order.order-no BEGINS "ro" OR order.order-no BEGINS "o" THEN
          RUN ss/pagefile.p("help/rn-newp2rto-hlp.txt","ADDING AN ITEM").
    RETURN NO-APPLY.
  END.

/* @(#) rntrig-230.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-230.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON ctrl-p ANYWHERE
  DO:
    DEFINE VARIABLE anyframe AS CHARACTER.
    ASSIGN
      anyframe = frame-field.

    anystring = FOCUS:SCREEN-VALUE.
    RUN rs-renthelp.p(INPUT anyframe , INPUT anystring).
    PAUSE 0 NO-MESSAGE.
    RUN displaytotal.
    PAUSE 0 NO-MESSAGE.
  END.

/* @(#) rntrig-240.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rntrig-240.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

ON "w", "W" OF cust-browse IN FRAME brws-frame
  DO:
    DEFINE VARIABLE t-rec        AS RECID.
    DEFINE VARIABLE t-warr-avail AS LOG   NO-UNDO.
    DEFINE VARIABLE t-use        AS LOG   NO-UNDO.

    IF v-trans.estat = "b" OR v-trans.estat = "p" THEN
    DO:
      IF v-trans.extended-warranty <> 0 THEN
      DO:
        MESSAGE
          "THIS ITEM ALREADY HAS A PURCHASED WARRANTY APPLIED ON THIS CONTRACT"          VIEW-AS ALERT-BOX.
        RETURN NO-APPLY.
      END.
      ELSE
      DO:
        t-rec = RECID(v-trans).
        DEFINE VARIABLE pz-endkey AS LOG     NO-UNDO.
        DEFINE VARIABLE tempitem  AS INTEGER.
        DEFINE VARIABLE lastitem  AS INTEGER.
        lastitem = itemnum. /* simpler solution than finding v_rec */
        FIND v-trans WHERE RECID(v-trans) = t-rec NO-ERROR.
        IF AVAILABLE v-trans AND (v-trans.sku-no = 19 OR v-trans.sku-no = 29
          OR v-trans.sku-no = 39 OR v-trans.sku-no = 59 OR v-trans.sku-no = 31)
          THEN
        DO:
          MESSAGE
            "THIS ITEM DOES NOT HAVE ADDITIONAL WARRANTY AVAILABLE FOR IT."
            VIEW-AS ALERT-BOX.
          RETURN NO-APPLY.
        END.
        RUN rn-get-extwarr.p("manual,single",v-trans.item-no,
          INPUT-OUTPUT lastitem, INPUT-OUTPUT t-rec, OUTPUT pz-endkey).
        IF AVAILABLE order AND order.order-no BEGINS "RO" THEN
          v-trans.extended-warranty
          = v-trans.extended-warranty + v-trans.rglr-warranty.

        FOR EACH v-trans:
          lastitem = v-trans.item-no.
        END.
        itemnum = lastitem.
        FIND v-trans WHERE v-trans.sku-no = 0
          AND v-trans.product-no = "" NO-ERROR.
        IF AVAILABLE v-trans THEN v_rec = RECID(v-trans).
        ELSE
          RUN newwtrans.
        RUN reopenquery.
        RUN showdipfield.
        oMsg:msg-refresh().
        RETURN NO-APPLY.
      END.
    END.
    ELSE
    DO:  /* check if item is warrantable or not. indicate purchase */
      IF AVAILABLE v-trans AND (v-trans.sku-no = 19 OR v-trans.sku-no = 29
        OR v-trans.sku-no = 39 OR v-trans.sku-no = 59 OR v-trans.sku-no = 31)
        THEN
      DO:
        MESSAGE
          "THIS ITEM DOES NOT HAVE ADDITIONAL WARRANTY AVAILABLE FOR IT."
          VIEW-AS ALERT-BOX.
        RETURN NO-APPLY.
      END.
      t-warr-avail = ext-warr-avail(v-trans.sku-no, t-use).

      IF t-warr-avail THEN
      DO:
        MESSAGE "THIS ITEM HAS A WARRANTY AVAILABLE, BUT MUST BE PURCHASED" SKIP
          "BEFORE IT CAN BE APPLIED." VIEW-AS ALERT-BOX.
      END.
      ELSE
      DO:
        MESSAGE "THIS ITEM DOES NOT HAVE ADDITIONAL WARRANTY AVAILABLE FOR IT."
          VIEW-AS ALERT-BOX.
      END .
    END.
  END.

/* ********************************* MAIN *********************************  */
DEFINE VARIABLE tempnum        LIKE order.order-no.
DEFINE VARIABLE leaveorder     AS LOG INIT NO.
DEFINE VARIABLE s-journal      LIKE sale.journal-no.
DEFINE VARIABLE t-ask-again    AS LOG INIT YES NO-UNDO. /* ask to put on insurance */
DEFINE VARIABLE suspend-endkey AS LOG INIT YES.
DEFINE VARIABLE hold-endkey    AS LOG INIT YES.
SESSION:SYSTEM-ALERT-BOXES = TRUE.

RUN login-info.p(INPUT "location", OUTPUT t-loc-code).
RUN login-info.p(INPUT "employee", OUTPUT t-empl-id).
RUN login-info.p(INPUT "register", OUTPUT gwkreg).

IF gwkreg = ? THEN
DO:   /* prevent backoffice use through f10 key */
  MESSAGE "This function is only available on a register."
    VIEW-AS ALERT-BOX ERROR.
  RETURN.
END.

/* must be here for create of order */
RUN rn-getyearend.p("school", TODAY, OUTPUT year-end).
tYears = 1.

FIND register NO-LOCK WHERE register.reg-no = gwkreg NO-ERROR.
RUN get-journal.p (INPUT t-loc-code, INPUT "TJ", gwkreg, INPUT NO,
  OUTPUT s-journal).

RUN last-cust.p("clear", buffer customer).
/* this section creates the sale-link for the sale this is done
well ahead of the sale to avoid any loc-number in use problems. The
order.link-order is not created at this point, because it might not
be a new order. */
DO TRANSACTION:   /* moved inside block the get-link includedes jun21/00*/
  RUN sl/get-ln-sale.p(OUTPUT t-linkno).
  
  FIND register exclusive
     where register.reg-no = gwkreg and register.loc-code = t-loc-code no-error.
  IF AVAILABLE register THEN ASSIGN
      t-transno           = register.last-tran# + 1
      register.last-tran# = t-transno.
  ELSE t-transno = t-transno + 1.     /* sale will be assigned this var*/
  FIND LAST sale OF register NO-LOCK NO-ERROR.
  IF AVAILABLE sale AND sale.trans-no = t-transno
    THEN t-transno = t-transno + 1.
END.
FIND employee NO-LOCK WHERE employee.empl-no = t-empl-id NO-ERROR.
/*****************************************************************************/
/*** THE Main Loop has two paths into (through the program).                 */
/* In the first instance the USER is prompted for the Customer's Name,       */
/* This is the most likely path chosen. The second path allows for the User  */
/* to search by Rental Contract Number where the Customer name is not known. */
/*****************************************************************************/
DEFINE VARIABLE x-reply AS LOG INIT NO.
/* WAS THE CONTRACT SUSPENDED */
IF s-link-order <> ? THEN
DO:
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  IF AVAILABLE order AND order.int-status = "su" THEN
    FIND LAST sale OF order NO-LOCK NO-ERROR.
  IF AVAILABLE sale AND sale.void = YES THEN
  DO:
    FIND sale-i OF sale NO-LOCK WHERE sale-i.sku-no = 9999999 NO-ERROR.

    /*SUSPENDED REGULAR RENT CREATED WITH RH CONTRACT */
    IF AVAILABLE sale-i AND sale-i.line-desc[1] BEGINS "RH" THEN
    DO:
      /* this suspend sale contains elements of both an RH contract
         and a newly created Rental */
      FIND order NO-LOCK WHERE order.order-no = sale-i.line-desc[1]
        AND order.cust-no = sale.cust-no NO-ERROR.
      IF AVAILABLE order THEN
      DO:  /* found "RH" order prev to suspend */
        is-loan = NO.
        FIND hold-order
          WHERE RECID(hold-order) = recid(order) NO-ERROR.

        IF AVAILABLE hold-order THEN
        DO TRANSACTION:

          t-hold-link = hold-order.link-order.
          t-holdit = YES.
          t-hold = YES.
          hold-order.int-status = "".
          hold-order.close-flag = NO.
          t-holdEmpl = hold-order.empl-no.
        END.
        RELEASE hold-order.
      END.
      FIND order WHERE order.link-order = s-link-order NO-ERROR.
      FIND customer OF order NO-LOCK NO-ERROR.
      RUN entersuspend(OUTPUT suspend-endkey).
      IF suspend-endkey = NO THEN
      DO: /* lastkey = f4 */
        destroy-locsrl-val().
        RETURN.
      END.
    END.
    ELSE IF AVAILABLE SALE-I THEN
      DO:
        IF t-funct-name = "loan.create" THEN is-loan = YES.
        ELSE is-loan = NO.
        FIND order WHERE order.link-order = s-link-order NO-ERROR.
        FIND customer OF order NO-LOCK NO-ERROR.
        RUN entersuspend(OUTPUT suspend-endkey).
        IF suspend-endkey = NO THEN
        DO: /* lastkey = f4 */
          destroy-locsrl-val().
          RETURN.
        END.
      END.
    IF LASTKEY = keycode("f1") OR LASTKEY = keycode(" ")
      OR LASTKEY = keycode("endkey") OR LASTKEY = keycode("return")
      THEN
    DO:
      destroy-locsrl-val().
      RETURN.
    END.
  END.  /* END OF SUSPEND WITH RH CONTRACT */
END.

ELSE IF AVAILABLE order AND order.sale-type = "rh" THEN
  DO: /*not suspended*/
    is-loan = NO.
    FIND hold-order NO-LOCK WHERE RECID(hold-order) = recid(order) NO-ERROR.
    t-hold-link = hold-order.link-order.
    t-holdit = YES.
    t-holdEmpl = hold-order.empl-no.
    loanreason = order.order-no.

    RUN enterhold(OUTPUT t-holdit).
    IF t-holdit = NO THEN
    DO: /* lastkey = f4 */

      loanreason = "".
      destroy-locsrl-val().
      RETURN. /* goes back to first quote screen */
    END.
    destroy-locsrl-val().
    RETURN.
  END.     /* end of section which brings up an RH CONTRACT */

commit-sale = NO.
t-made-rental = NO.
IF t-funct-name = "loan.create" THEN is-loan = YES.
ELSE is-loan = NO.
/* --------------------------------------------------------------------------*/
DEFINE VARIABLE t-endkey AS LOG INIT NO NO-UNDO.

IF NOT recallsuspend AND NOT t-holdit THEN
DO:
  RUN actionsegment.
  FIND order NO-LOCK WHERE order.link-order = t-hold-link NO-ERROR.
  /* if regular rents picks up a hold contract from either customer or
     number search then it exits actionsegment and lands here for processing
  */

  IF AVAILABLE order
    AND order.order-no BEGINS "rh" THEN
  DO: /* picked up a hold in reg rents */
    is-loan = NO.
    FIND hold-order NO-LOCK WHERE RECID(hold-order) = recid(order) NO-ERROR.
    t-hold-link = hold-order.link-order.
    t-holdit = YES.
    t-holdEmpl = hold-order.empl-no.
    loanreason = hold-order.order-no.

    RUN enterhold(OUTPUT t-holdit).
    IF t-holdit = NO THEN
    DO: /* lastkey = f4 */
      FIND order WHERE order.link-order = t-hold-link NO-ERROR.
      IF AVAILABLE order THEN
      DO TRANSACTION: /*this overwrites a picked up hold*/

        IF order.terms BEGINS "jamb" THEN
        DO:
          order.int-status = "picked up".
        END.
        ELSE
        DO:
          order.rent-code = "HOLD".
          order.int-status = "create".
        END.
      END.


      loanreason = "".
      destroy-locsrl-val().
      RETURN. /* goes back to first quote screen */
    END.
    destroy-locsrl-val().
    RETURN.
  END.
END.
/* bar code labels on return of all items */
oMsg:msg-hide().

IF LASTKEY = keycode("f4") AND commit-sale = NO THEN
DO:
  s-ordnum = "".
  HIDE FRAME fr-ord.
END.
DEFINE VARIABLE t-printcode AS LOG INIT NO.
FOR EACH v-trans WHERE v-trans.estat = "r" AND NOT v-trans.void:
  t-printcode = YES.
END.
FIND syscust NO-LOCK WHERE syscust.type = "rn" NO-ERROR.
IF AVAILABLE syscust THEN
  IF LASTKEY <> keycode("f4") AND NOT p-rent-code BEGINS "re" AND
    syscust.flag[3] = YES AND p-status <> "create" AND t-printcode
    THEN RUN printbarcode.
destroy-locsrl-val(). /* must have after printbarcode */

DELETE OBJECT myrent.
DELETE OBJECT oMSg.
DELETE OBJECT myCalc.
RUN ss/destroy-all-super-proc.p.

/* ************************ Procedure Implementations *********************** */
/* @(#) rnproc-IsShipDirect.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-IsShipDirect.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE IsShipDirect:
  DEFINE OUTPUT PARAMETER pShipDirect AS LOG NO-UNDO.
  DEFINE OUTPUT PARAMETER pProv AS CHARACTER NO-UNDO.
  pShipDirect = tShipDirect.
  IF NOT AVAILABLE tbl-ord-lywy THEN FIND FIRST tbl-ord-lywy NO-LOCK NO-ERROR.
  IF AVAILABLE tbl-ord-lywy THEN pProv = tbl-ord-lywy.prov.
END PROCEDURE.

/* @(#) rnproc-actionsegment.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-actionsegment.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE actionsegment:
  s-ordnum = "".
  DISPLAY s-ordnum WITH FRAME fr-ord.


  loop1: REPEAT ON ERROR UNDO loop1, LEAVE loop1
    ON ENDKEY UNDO loop1, LEAVE loop1:
    FOR EACH tsale:
      DELETE tsale.
    END.
    FOR EACH tsalei:
      DELETE tsalei.
    END.

    DEFINE VARIABLE cust-agr-dt AS DATE INIT "01/01/1950".
    HIDE FRAME fr-descrip NO-PAUSE.
    RUN getcust.
    /* this loop searches for the rental contract number */
    IF r-cust = ? THEN
    DO:
      PAUSE 0 NO-MESSAGE.
      loop2: REPEAT ON ERROR UNDO loop2, LEAVE loop2
        ON ENDKEY UNDO loop2, LEAVE loop2 :
        chg-code = 0.   /* re-init on loop */
        RUN searchnum.        /* always searches for an existing order */
        /* dont process reservations here */

        FIND order NO-LOCK WHERE order.link-order = t-hold-link NO-ERROR.
        IF AVAILABLE order THEN RETURN.
        DISABLE s-ordnum WITH FRAME fr-ord.
        IF p-orderid = ? THEN
        DO:
          NEXT.
        END.

        IF p-orderid <> ? THEN
        DO:

          FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
          IF AVAILABLE order THEN p-orderid = RECID(order).
          IF AVAILABLE order THEN
            FIND customer NO-LOCK WHERE customer.cust-no = order.cust-no NO-ERROR.
          RUN last-cust.p("set", buffer customer).
          r-cust = RECID(customer).
          RUN displaycust.
          RUN getcust.  /* task 5894 show overdue/ar screens*/
          IF AVAILABLE order AND order.shipDirect
            THEN tShipDirect = YES. /*9807*/
          IF order.rent-code = "SCHOOL" THEN
          DO:
            RUN getschool(NO).
            RUN displaycust.  /* re-display reqd */
          END.

        END.
        loop3: REPEAT ON ERROR UNDO loop3, LEAVE loop3
          ON ENDKEY UNDO loop3, LEAVE loop3:
          IF commit-sale THEN LEAVE loop1.
          FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.

          IF leaveorder THEN          /* init as no so loadvtrans */
            a-reply = NO.            /* else re-instate v-trans as is */
          ELSE a-reply = YES.         /* load v-trans */

          RUN rn-detectpap.p(buffer order, is_suspend, NO, OUTPUT t-endkey).
          IF t-endkey = NO THEN LEAVE loop3.
          /* only ask on school contracts */
          IF AVAILABLE order AND NOT order.order-no BEGINS "rs"
            AND NOT order.order-no BEGINS "ro"
            AND NOT order.order-no BEGINS "s"
            AND NOT order.order-no BEGINS "o"
            THEN t-ask-again = NO.
          ELSE t-ask-again = YES.
          IF AVAILABLE order AND (order.order-no BEGINS "rn"
            OR order.order-no BEGINS "n") THEN
          DO:
            t-order-no = order.order-no.
          END.
          RUN itembrowser.
          IF LASTKEY = keycode("f1") OR LASTKEY = keycode(" ")
            OR LASTKEY = keycode("endkey") OR is_suspend THEN
            LEAVE loop1.

          IF LASTKEY = keycode("f4") AND commit-sale = NO THEN
          DO:

            RUN undoorder(OUTPUT leaveorder).
            IF leaveorder THEN
            DO:  /* on yes leave leave loop1 */
              leaveorder = NO.   /* re-initialize. */
              p-orderid = ?.
              r-cust = ?.
              FOR EACH v-trans:
                DELETE v-trans.
              END.
              LEAVE loop2.
            END.
            ELSE leaveorder = YES.
          END.
        END.
      END.
    END.

    /* THIS LOOP Searches for the rental contract first **/
    ELSE IF r-cust <> ? THEN

      loop2a: REPEAT ON ERROR UNDO loop2a, LEAVE loop2a
        ON ENDKEY UNDO loop2a, LEAVE loop2a :
        FIND customer NO-LOCK WHERE RECID(customer) = r-cust.
        /* at this point sale record might exist from previous back out */

        RUN selectorder.

        FIND order NO-LOCK WHERE order.link-order = t-hold-link NO-ERROR.
        /*** leave this segment and create a rental from hold contract ***/
        IF AVAILABLE order THEN RETURN.
        chg-code = 0.   /* initialize on loop */
        loop3a: REPEAT ON ERROR UNDO loop3a, LEAVE loop3a
          ON ENDKEY UNDO loop3a, LEAVE loop3a:
          FIND customer NO-LOCK WHERE RECID(customer) = r-cust.
          DO TRANSACTION:
            FIND b-order WHERE b-order.link-order = s-link-order NO-ERROR.
            IF AVAILABLE b-order THEN
            DO:
              ASSIGN
                b-order.cust-no = customer.cust-no.
            END.
            FIND sale WHERE RECID(sale) = salrec NO-ERROR.
            /* fixed below for bug in rn-discounts.p testing */
            IF AVAILABLE sale AND AVAILABLE order
              THEN sale.cust-no = order.cust-no.
          END.    /* sale might not yet exist */
          FIND sale NO-LOCK WHERE RECID(sale) = salrec NO-ERROR.
          /* find b-order no-lock where b-order.link-order = s-link-order. */
          FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
          IF AVAILABLE order AND order.shipDirect
            THEN tShipDirect = YES. /*9807*/
          IF AVAILABLE order AND t-funct-name = "rental.create"
            THEN
          DO:
            RUN getschool(NO).
            RUN displaycust.
          END.

          IF AVAILABLE order AND
            order.int-status = "create" AND (t-funct-name = "rent.create"
            OR t-funct-name = "loan.create" OR t-funct-name = "r-own.create"
            OR t-hold )
            THEN
          DO:

            /* this section gets rental security date if required */
            FIND customer NO-LOCK
              WHERE customer.cust-no = order.cust-no NO-ERROR.
            IF NOT leaveorder THEN
            DO:
              DO:
                IF order.order-no BEGINS "rn" OR order.order-no BEGINS "n" THEN
                  RUN rn-cust-agree.p(buffer customer, buffer order,
                    INPUT-OUTPUT cust-agree-dt).
              /** run rn-equiFailure.p(order.cust-no, order.order-no). **/

              END.
            END.
            s-issue = order.dt-created.
            s-deposit = 0.
            IF p-status <> "create" THEN s-dt-return = order.dt-due.

            IF t-funct-name = "loan.create" THEN
            DO:
              ASSIGN
                t-reminder = NO.
            END.
            oMsg:msg-hide().
            DO:
              RUN save-frames.p(INPUT-OUTPUT t-frame-list,"hide").
              IF t-hold THEN p-rent-code = "HOLD".

              RUN date_ret.w(p-rent-code,
                INPUT-OUTPUT s-issue, INPUT-OUTPUT s-dt-return,
                s-link-order, INPUT-OUTPUT chg-code, OUTPUT f9active,
                OUTPUT s-deposit, OUTPUT msg-create, INPUT-OUTPUT t-reminder,
                INPUT t-deposit /*, output prepayday*/ ).
              RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
            END.

            /* another patch so it is assigned in regtot.p */
            IF t-funct-name <> "loan.create" THEN
            DO:
              IF order.charge-code <> chg-code
                AND order.int-status = "create" THEN
              DO TRANSACTION:
                order.charge-code = chg-code.
              END.
            END.
            RELEASE order.
            FIND order NO-LOCK
              WHERE order.link-order = s-link-order NO-ERROR.
            PAUSE 0 NO-MESSAGE.
            oMsg:msg-refresh().
            IF LASTKEY = keycode("f4") THEN LEAVE loop2a.
            t-dt-enter = s-dt-return.
          END.

          IF LASTKEY = keycode("f1") OR LASTKEY = keycode("return") THEN
          DO:
            IF AVAILABLE order AND
              order.int-status <> "create" AND (t-funct-name = "rent.create"
              OR t-funct-name = "loan.create")
              THEN
            DO:
              /* this section gets rental security date if required */
              FIND customer NO-LOCK
                WHERE customer.cust-no = order.cust-no NO-ERROR.
              /*if t-funct-name = "loan.create" then.
              else */
              DO:
                IF order.order-no BEGINS "rn" OR order.order-no BEGINS "n" THEN
                  RUN rn-cust-agree.p(buffer customer, buffer order,
                    INPUT-OUTPUT cust-agree-dt).
              END.
            END.
            loop3b: REPEAT ON ERROR UNDO loop3b, LEAVE loop3b:
              IF commit-sale THEN
              DO:  /* trap endkey and leave loop */
                LEAVE loop1.
              END.
              IF leaveorder THEN          /* init as no so loadvtrans */
                a-reply = NO.            /* else re-instate v-trans as is */
              ELSE a-reply = YES.         /* load v-trans */
              IF AVAILABLE order THEN
                RUN rn-detectpap.p(buffer order, is_suspend, NO, OUTPUT t-endkey).
              IF t-endkey = NO THEN LEAVE loop3b.
              IF AVAILABLE order AND
                NOT order.order-no BEGINS "rs"
                AND NOT order.order-no BEGINS "ro"
                AND NOT order.order-no BEGINS "s"
                AND NOT order.order-no BEGINS "o"
                THEN t-ask-again = NO.
              ELSE t-ask-again = YES.
              /*
              if not order.order-no begins "ro" then
              t-ask-again = yes.  */
              RUN itembrowser.
              FIND order NO-LOCK
                WHERE order.link-order  = s-link-order NO-ERROR.
              IF f9active AND LASTKEY <> keycode("f4") THEN LEAVE loop1.
              IF LASTKEY = keycode("f4") AND commit-sale = NO THEN
              DO:
                RUN undoorder(OUTPUT leaveorder).
                IF leaveorder THEN
                DO:  /* on yes leave leave loop1 */
                  /*
                    run undosales.
                  */
                  leaveorder = NO.   /* re-initialize. */
                  LEAVE loop3a.
                END.
                ELSE leaveorder = YES.
              END.
              ELSE IF LASTKEY = keycode("f4") AND commit-sale = YES THEN
                DO:
                  FIND order NO-LOCK
                    WHERE order.link-order = s-link-order NO-ERROR.
                  LEAVE loop1.
                END.

              /* for above if order not just created dont do otherwise do. */
              IF LASTKEY = keycode("f1") OR LASTKEY = keycode(" ")
                OR LASTKEY = keycode("endkey") OR is_suspend = YES
                THEN LEAVE loop1.
            END.
          END.
        END.   /* loop 3a i think */
      END.
  END.
END PROCEDURE.

/* @(#) rnproc-returnloan-tonew.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-returnloan-tonew.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE returnloan-tonew:
  DEFINE INPUT PARAMETER p-item-no AS INTEGER NO-UNDO.
  DEFINE VARIABLE t-endkey AS LOG     NO-UNDO.
  DEFINE VARIABLE skyqty   AS INTEGER NO-UNDO.
  FIND v-trans WHERE v-trans.item-no = p-item-no NO-ERROR.
  IF (v-trans.qty >= 1 AND t-funct-name = "loan.create")
    AND v-trans.serial-no BEGINS "sku#" THEN
  DO:
    DEFINE VARIABLE retrec AS RECID NO-UNDO.
    retrec = RECID(v-trans).
    /* use v-sale-s.line-no for qty to return to new. */
    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
    oMsg:msg-hide().
    RUN rn-retqty.p(v-trans.qty, v-trans.item-no, v-trans.link-order,
      t-funct-name,
      OUTPUT skyqty, OUTPUT t-endkey, OUTPUT v-trans.qty-new).
    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
    oMsg:msg-refresh().
    IF t-endkey THEN
    DO:
      RUN reopenquery.
      RUN setupframef(NO,YES).
      RETURN.
    END.
    IF skyqty <> v-trans.qty THEN
    DO:
      PAUSE 0 NO-MESSAGE.
      RUN partialreturn(skyqty). /* create a separate record */
      PAUSE 0 NO-MESSAGE.
      IF order.dt-due > TODAY THEN
      DO:
        v-trans.estat = "z".   /* pass a flag */
        RUN rentirtn.    /* newly added items don't need to be returned */
      END.
      IF v-trans.old-item = NO THEN
        DELETE v-trans.
      RUN newwtrans.
      FIND v-trans WHERE RECID(v-trans) = retrec NO-ERROR.
      IF AVAILABLE v-trans THEN
      DO:
        VIEW FRAME fr-total2.
        VIEW FRAME fr-keys.
        FIND v-trans WHERE RECID(v-trans) = retrec.
        status-ok = cust-browse:refresh() IN FRAME brws-frame.
        PAUSE 0 NO-MESSAGE.
        RETURN.
      END.
    END.
    ELSE
    DO:
      PAUSE 0 NO-MESSAGE. /* required on full return task 5839*/
      RUN rentirtn.
      RUN correcttotal.
      RUN displaytotal.
      VIEW FRAME fr-total2.
      VIEW FRAME fr-keys.
      /* put it back on the same location in browser. */
      FIND v-trans WHERE RECID(v-trans) = retrec.
      status-ok = cust-browse:refresh() IN FRAME brws-frame.
      RETURN.
    END.
  END.
END.

/* @(#) rnproc-entersuspend.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-entersuspend.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE entersuspend:
  DEFINE OUTPUT PARAMETER p-suspend AS LOG INIT YES.
  r-cust = RECID(customer).
  recallsuspend = YES.
  p-rent-code = order.rent-code.
  s-link-order = order.link-order.
  p-orderid = RECID(order).
  a-reply = YES.
  DO TRANSACTION:
    order.sale-type = "Rn".
    IF order.terms BEGINS "crea" OR order.terms BEGINS "lcre" THEN
    DO:
      order.int-status = "create".
      p-status = "create".
      order.dt-created = TODAY.
      IF NOT t-hold THEN
        t-dt-enter = order.dt-due.
      s-dt-return = order.dt-due.
    END.
    ELSE order.int-status = "".
  END.
  IF AVAILABLE order THEN
    chg-code = order.charge-code.
  ASSIGN
    s-ordnum = order.order-no.
  DISPLAY s-ordnum WITH FRAME fr-ord.
  DEFINE VARIABLE x-reply AS LOG INIT YES NO-UNDO.

  RUN displaycust.
  losesuspend: REPEAT:
    IF x-reply = YES THEN a-reply = YES.
    ELSE a-reply = NO.
    RUN itembrowser.
    FIND order WHERE order.link-order  = s-link-order NO-ERROR.

    IF LASTKEY = keycode("f4") AND commit-sale = YES THEN
    DO:
      FIND order NO-LOCK
        WHERE order.link-order = s-link-order NO-ERROR.
      p-suspend = NO.
      LEAVE losesuspend.
    END.
    IF LASTKEY = keycode("f4") THEN
    DO:
      oMsg:msg-hide().
      p-suspend = NO.
      MESSAGE "YOU ARE LEAVING A SUSPENDED SALE. " SKIP
        "PRESS Y TO LEAVE or N to RETURN TO ITEM SCREEN."
        VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO-CANCEL
        UPDATE x-reply.
      IF x-reply = ? OR x-reply = NO THEN a-reply = NO.

      ELSE IF x-reply = YES THEN
        DO:
          a-reply = YES.  /* added may27/03 */
          /* if lastkey = keycode("f4") then*/
          DO TRANSACTION:

            /* feb 12 / 2008 */
            FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.

            IF AVAILABLE order AND order.int-status = "create" THEN
              ASSIGN
                order.invoice-comment[2] = ""
                order.int-status         = "picked up".

            RUN undosales.
          END.
          s-ordnum = "".
          p-orderid = ?.
          r-cust = ?.
          DISABLE s-ordnum WITH FRAME fr-ord.
          HIDE FRAME fr-ord NO-PAUSE.
          oMsg:msg-hide().
          RETURN.
        END.
    END.
    ELSE
    DO:
      a-reply = NO.
      p-suspend = NO.
      RETURN.
    END.
    IF x-reply THEN
    DO:
      p-suspend = NO.
      LEAVE losesuspend.
    END.
  END.
END.

/* @(#) rnproc-enterhold.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-enterhold.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE enterhold:
  DEFINE OUTPUT PARAMETER p-hold AS LOG INIT YES.

  DEFINE VARIABLE t-days         AS INTEGER NO-UNDO.
  DEFINE VARIABLE t-hold-duedate AS DATE    NO-UNDO.
  DEFINE VARIABLE firstContract  AS LOG     NO-UNDO.
  DEFINE VARIABLE tRegContract   LIKE order.order-no.

  IF order.order-no BEGINS "RH" THEN
  DO:
    ASSIGN
      t-hold-link = order.link-order
      t-holdEmpl  = order.empl-no.
    IF p-auth BEGINS "write off" THEN
    DO:
      MESSAGE "NEW Contracts cannot be created for writeoff customers"
        VIEW-AS ALERT-BOX.
      RETURN ERROR.
    END.
    t-funct-name = "rent.create".
    t-hold-duedate = order.dt-due.
    chg-code = order.charge-code.  /* use what was created in hold */
    IF chg-code > 0 THEN t-reminder =  NO.
    /****TRANSLATE THE HOLD CONTRACT DATES TO TODAY ***/
    s-issue = TODAY.
    /* the following should also handle sundays when < 30 days */
    RUN rn-translateDate.p(order.dt-create, order.dt-due,
      s-issue, OUTPUT s-dt-return).

    FIND customer NO-LOCK WHERE customer.cust-no = order.cust-no NO-ERROR.
    r-cust = RECID(customer).
    t-reminder = customer.reminders.

    RELEASE order. /*temporary */
    RUN get-next.p(INPUT "", INPUT "N", INPUT "N9999999",
      OUTPUT s-ordnum).
    t-hold = YES.
    t-dt-enter = s-dt-return. /* the dates dont match on a purchase. */
    RUN createorder.
  END.

  /* this should be based on new contract from here on */
  FIND customer NO-LOCK WHERE customer.cust-no = order.cust-no NO-ERROR.
  r-cust = RECID(customer).
  recallhold = YES.
  p-rent-code = order.rent-code.
  s-link-order = order.link-order.
  a-reply = YES.
  DO TRANSACTION:
    order.sale-type = "Rn".

    IF order.terms BEGINS "crea" OR order.terms BEGINS "lcre" THEN
    DO:
      order.int-status = "create".
      p-status = "create".
      order.dt-created = TODAY.
      order.dt-due = s-dt-return. /*today.*/
    END.
    ELSE order.int-status = "".
  END.
  s-link-order = order.link-order.
  ASSIGN
    s-ordnum = order.order-no.
  DISPLAY s-ordnum WITH FRAME fr-ord.
  DEFINE VARIABLE x-reply AS LOG INIT YES NO-UNDO.

  RUN displaycust.
  /* losehold: repeat: */
  IF x-reply = YES THEN a-reply = YES.
  ELSE a-reply = NO.
  p-rent-code = "regular".
  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"hide").

  /* assign s-issue = today s-dt-return = today. */
  FOR EACH v-trans:
    v-trans.extended = 0.
  END.
  /*  s-issue = today. */
  FIND bord-lywy NO-LOCK
    WHERE bord-lywy.link-order = t-hold-link NO-ERROR.
  IF AVAILABLE bord-lywy THEN
  DO:
    FIND ord-lywy OF order NO-ERROR.
    IF NOT AVAILABLE ord-lywy THEN
    DO TRANSACTION:
      CREATE ord-lywy.
    END.
    IF AVAILABLE ord-lywy THEN
    DO TRANSACTION:
      ASSIGN
        ord-lywy.link-order = order.link-order
        ord-lywy.comment[1] = bord-lywy.comment[1]
        ord-lywy.comment[2] = bord-lywy.comment[2]
        ord-lywy.comment[3] = bord-lywy.comment[3]
        ord-lywy.comment[4] = bord-lywy.comment[4].
    END.
  END.
  HIDE FRAME fr-ordlywy NO-PAUSE.
  IF t-hold THEN p-rent-code = "HOLD". /* SET TO BLOCK BACK OFFICE*/
  RUN date_ret.w(p-rent-code,
    INPUT-OUTPUT s-issue, INPUT-OUTPUT s-dt-return,
    s-link-order, INPUT-OUTPUT chg-code, OUTPUT f9active,
    OUTPUT s-deposit, OUTPUT msg-create, INPUT-OUTPUT t-reminder,
    INPUT t-deposit /*, output prepayday*/).
  IF t-hold AND p-rent-code = "HO" THEN p-rent-code = "regular".

  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
  IF LASTKEY = keycode("f4") THEN
  DO: /* f4 from date_ret.w */
    FIND order WHERE order.link-order = s-link-order NO-ERROR.
    IF AVAILABLE order THEN
    DO TRANSACTION:
      ASSIGN
        order.int-status         = "picked up"
        order.invoice-comment[2] = "".
      FOR EACH order-i OF order:
        DELETE order-i.
      END.
      FOR EACH order-s OF order:
        DELETE order-s.
      END.
      FOR EACH v-trans:
        DELETE v-trans.
      END.
      RELEASE order.
    END.
    FIND order NO-LOCK WHERE order.link-order = t-hold-link NO-ERROR.
    /* THIS WILL SET TO UNDO HOLD FROM DATE SCREEN **/
    p-hold = NO.
    t-hold = NO.
    RETURN .
  END.

  IF order.charge-code <> chg-code
    AND order.int-status = "create" THEN
  DO TRANSACTION:
    ASSIGN
      order.charge-code = chg-code
      order.dt-created  = TODAY
      order.dt-due      = s-dt-return.
  END.
  ELSE IF order.int-status = "create" THEN
    DO TRANSACTION:
      order.dt-created = TODAY.
      order.dt-due = s-dt-return.
    END.
  RELEASE order.
  FIND order NO-LOCK
    WHERE order.link-order = s-link-order NO-ERROR.
  PAUSE 0 NO-MESSAGE.
  oMsg:msg-refresh().
  t-dt-enter = s-dt-return.
  /* this section gets rental security date if required */
  FIND customer NO-LOCK
    WHERE customer.cust-no = order.cust-no NO-ERROR.
  /*if t-funct-name = "loan.create" then.
  else */
  DO:
    IF order.order-no BEGINS "rn" OR order.order-no BEGINS "n" THEN
      RUN rn-cust-agree.p(buffer customer, buffer order,
        INPUT-OUTPUT cust-agree-dt).
  END.
  a-reply = NO.
  looprx: REPEAT ON ERROR UNDO looprx, LEAVE looprx:
    IF a-reply = YES THEN LEAVE looprx.
    a-reply = YES.   /*needed to load browser */
    /*patch job feb 27/07 find problem*/

    FOR EACH order-i OF order NO-LOCK:
      FIND order-s OF order WHERE order-s.item-no = order-i.item-no NO-ERROR.
      IF NOT AVAILABLE order-s THEN
      DO:
        CREATE order-s.
        ASSIGN
          order-s.item-no    = order-i.item-no
          order-s.link-order = order-i.link-order
          order-s.serial-no  = order-i.serial-no.
      END.
    END.

    RUN itembrowser.
    FIND order WHERE order.link-order  = s-link-order NO-ERROR.
    /* the stupid f4 off of a printslip generates this  */
    IF LASTKEY = keycode("f4") AND commit-sale = NO THEN
    DO:
      oMsg:msg-hide().
      p-HOLD = NO.
      MESSAGE "YOU ARE LEAVING A RENTAL CONTRACT. " SKIP
        "PRESS Y TO LEAVE or N to RETURN TO ITEM SCREEN."
        VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO-CANCEL
        UPDATE x-reply.

      IF x-reply = ? OR x-reply = NO THEN
      DO:
        a-reply = NO.
      END.
      ELSE IF x-reply = YES THEN
        DO:
          a-reply = YES.  /* added may27/03 */
          /* if lastkey = keycode("f4") then*/
          DO TRANSACTION:
            IF order.int-status = "create" THEN
              ASSIGN
                order.invoice-comment[2] = ""
                order.int-status         = "picked up".

            RUN undosales.  /* SHOULD DELETE ALL ORDER-I */
          END.
          s-ordnum = "".
          p-orderid = ?.
          r-cust = ?.
          DISABLE s-ordnum WITH FRAME fr-ord.
          HIDE FRAME fr-ord NO-PAUSE.
          oMsg:msg-hide().
          PAUSE 0 NO-MESSAGE.
          RETURN.
        END.
    END.
    IF x-reply THEN
    DO:
      FIND order WHERE order.link-order = t-hold-link NO-ERROR.
      IF AVAILABLE order THEN
      DO TRANSACTION:
        order.invoice-comment[2] = "".
        order.int-status = "Picked Up".
        order.close = YES.
      END.
      RELEASE order.
      t-hold-link = ? .
      p-hold = NO.
      LEAVE /* losehold */ .
    END.
  END.     /* end of repeat */

END.

/* @(#) rnproc-setf5.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-setf5.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE setf5:
  ASSIGN
    v-trans.serial-no = e:screen-value IN FRAME f.
  IF e:screen-value = "#to follow#" OR e:screen-value BEGINS "SKU#" THEN
  DO:
    ASSIGN
      v-trans.serial-no = ""
      e                 = "".
    DISPLAY e WITH FRAME f.
    RETURN.
  END.
  HIDE FRAME f NO-PAUSE.
  ASSIGN
    s-rec = ?.
  IF not-owing = NO THEN
  DO:
    RUN rn-message.p("not-owing").
    ASSIGN
      e = "".
    RETURN.
  END.
  RUN used-rent. /* add item to inventory */

  IF is_exch THEN
  DO: /* used-rent can change this flag */
    RUN rentexch.
  END.
  IF v-trans.estat = "P" THEN
  DO:
    ASSIGN
      buyrec = RECID(v-trans).
    IF s-rec <> ? THEN RUN useskuno.
    ELSE RUN used-rent.
    IF v-trans.qty-new = 0 THEN
      RUN buynewitem.

  END.
END.

/* @(#) rnproc-disp-msg.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-disp-msg.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE disp-msg:
  DEFINE INPUT PARAMETER p-field AS cha NO-UNDO.
  DEFINE VARIABLE t-msg  AS cha NO-UNDO.
  DEFINE VARIABLE t-msg2 AS cha NO-UNDO.
  IF p-field = "delete" THEN ASSIGN t-msg  = "" t-msg2 = "".
  ELSE
  DO:
    t-msg = "F1=LINE-DESC,<ENTER>=NON-SERIAL,SHIFT-F3=HELP".
    IF p-rent-code BEGINS "RE" THEN
      t-msg = t-msg + ",F3=EasyPay".     /* regular and loans */
    /* F3=SCHOOL BLOCKED BECAUSE OF COST SHARE , CANT SWITHC */
    /*   may2013
else if not recallsuspend then t-msg = t-msg + ",F3=SCHOOL".  school */
    IF order.order-no BEGINS "rn" OR order.order-no BEGINS "N" THEN
      p-rent-code = "REGULAR".  /* A PATCH */
    ELSE IF order.order-no BEGINS "ro" OR order.order-no BEGINS "o" THEN
        p-rent-code = "RENTOWN".
    IF p-status = "create" THEN t-msg = t-msg + ",F5=ADD,F6=DELETE,F7=PURCHASE".
    ELSE t-msg = t-msg + ",F5=ADD,F6=DELETE,F7=RETURN/EXCH/BUY".
    IF AVAILABLE v-trans AND v-trans.old-item = NO THEN
      t-msg2 =
        "F8=OVERRIDE,F9=SUB-MENU,F10=RETURN ONE/ALL,F11=SP.NOTES,F12=ACCEPT,W=PERFORMANCE WARRANTY".
    ELSE t-msg2 =
        "F9=SUB-MENU,F10=RETURN ONE/ALL,F11=SP.NOTES,F12=ACCEPT,W=PERFORMANCE WARRANTY".
    t-msg = t-msg + "," + t-msg2.
  END.
  oMsg:msg-display-buttons(t-msg,20, 0 ).
END PROCEDURE.

/* @(#) rnproc-undoorder.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-undoorder.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE undoorder:

  DEFINE VARIABLE is-exit AS LOG INIT YES. /* allow exiting if nothing changed */
  DEFINE OUTPUT PARAMETER z-reply AS LOG INIT YES.
  FOR EACH v-trans WHERE RECID(v-trans) <> v_rec AND NOT v-trans.void:
    IF (v-trans.estat <> "O" AND v-trans.estat <> "")
      OR v-trans.old-item = NO THEN
    DO:
      is-exit = NO.
    END.
  END.
  IF is-exit = NO THEN
  DO:

    MESSAGE "Items have been changed on this Order. To Back out of Contract"
      SKIP
      "Type Y. Type N to Return to Item Screen." VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE z-reply.
    IF z-reply = ? THEN z-reply = NO.
  END.
  IF z-reply THEN
  DO:
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
    IF AVAILABLE order THEN
    DO:
      FOR EACH v-trans WHERE v-trans.sku-no <> 0
        AND v-trans.sku-no < 9999990 AND v-trans.old-item = NO
        AND NOT v-trans.void AND NOT v-trans.serial-no BEGINS "sku#":

        FIND inv-locsrl WHERE inv-locsrl.serial-no = v-trans.serial-no
          AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
        IF AVAILABLE inv-locsrl AND inv-locsrl.doc-ref = order.order-no
          AND inv-locsrl.i-status = -1 AND v-trans.dt-rented = TODAY
          THEN
          DELETE inv-locsrl .
      END.

      FOR EACH vlocsrl:
        DELETE vlocsrl.
      END.
    END.
  END.
END.

/* @(#) rnproc-undosales.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-undosales.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE undosales:
  /** the following delete sales created and returns inventory on
         way back out of order **/
  IF commit-sale THEN RETURN.
  DO TRANSACTION:
    FIND sale WHERE sale.link-sale = salerec NO-ERROR.
    IF AVAILABLE sale THEN
    DO:
      FOR EACH saletend OF sale :
        saletend.void = YES.
      END.
      FOR EACH sale-i OF sale:
        sale-i.void = YES. /*  */
      END.
      /* find register of sale no-lock no-error. */
      sale.void = YES. /* delete sale. */

      FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
      IF AVAILABLE order AND order.cust-no <> sale.cust-no THEN
      DO:

      /* delete sale. */
      END.
    END.
  END.
END.

/* @(#) rnproc-loadvtrans.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-loadvtrans.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE loadvtrans:
  DEFINE VARIABLE cnt   AS INTEGER NO-UNDO.
  DEFINE VARIABLE itype LIKE order-i.item-type.

  not-owing = NO. /* assume all items are left in a state of owing. */
  /* delete any prior existing v-trans and set new stock back to inventory */
  FOR EACH v-trans:     /* reset into inventory */
    IF v-trans.old-item = NO AND v-trans.estat = ""
      AND RECID(v-trans) <> v_rec THEN
      DELETE v-trans.
  END.
  i = 1.
  t-paid = 0.
  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
  IF AVAILABLE order THEN
    ASSIGN p-orderid = RECID(order).
  IF p-orderid <> ? THEN
  DO:
    /* date_ret.w and getcust before this */
    IF order.rent-code <> "school" THEN
      chg-code = order.charge-code.
    IF order.int-status = "" THEN p-status = "change".
    IF order.rent-code = "school" THEN p-rent-code = "school". /* patch job*/

    IF recallsuspend AND t-hold THEN
      t-dt-enter = order.dt-due.
    /* 10639  Student Rental - change the way we select a contract type to be yearly or monthly*/
    IF p-status = "create" OR t-hold THEN
      not-owing = YES.
    p-rent-code = order.rent-code.

    /* this copies existing order into v-trans. but doesnt generate blanks */

    IF AVAILABLE order THEN
    DO:
      t-taxcollect = order.tax-collect.
      lnk = order.link-order.
      IF t-hold AND NOT recallsuspend THEN
      DO:
        FIND hold-order NO-LOCK
          WHERE hold-order.link-order = t-hold-link NO-ERROR.
        IF AVAILABLE hold-order THEN
        DO:
          RUN loadvhold.
          RETURN.
        END.
      END.

      ELSE IF recallsuspend THEN
        DO:

          RUN recallsuspend.
          FIND FIRST order-i OF order NO-LOCK WHERE NOT order-i.void
            AND order-i.dt-return = ? NO-ERROR.
          IF AVAILABLE order-i THEN not-owing = YES.
          RETURN.
        END.
      FIND FIRST order-i NO-LOCK OF order NO-ERROR. /* exclusive lock */

      IF NOT AVAILABLE order-i THEN not-owing = YES.
      ELSE
        IF AVAILABLE order-i THEN
        DO:
          itype = "RI".
          /* technically following has no items owing */
          FIND LAST sale OF order NO-LOCK NO-ERROR.

          FOR EACH order-i NO-LOCK OF order WHERE order-i.item-type
            BEGINS "RI" AND order-i.void = NO:
            CREATE v-trans.
            BUFFER-COPY order-i TO v-trans.
            ASSIGN
              v-trans.before-value = order-i.orig-value
              v-trans.before-rate  = order-i.rent-rate
              v-trans.after-value  = order-i.orig-value
              v-trans.after-rate   = order-i.rent-rate.

            /* {rn-vtrans.i}              patch below */
            v-trans.create-value = order-i.create-value.
            v-trans.used-flag = "u".  /*patch may17/2006 for ext-warran*/
            v-trans.origextend = order-i.extended. /* only place */
            v-trans.amt-received = order-i.extended. /*schoolcalc buy-all*/
            IF v-trans.est-repair-cost = 0 AND v-trans.rent-rate <> 0
              AND order.rent-code = "school" THEN
              RUN getSchMth(order-i.serial-no).
            IF V-TRANS.SKU-NO = 28 THEN v-trans.est-repair-cost = 1.00.
            /* patch and f8 discounts done just before suspend */
            v-trans.pos-disc = 0. /* issues taxes regtot.p */
            IF NOT t-hold THEN v-trans.old-item = YES.

            IF itemnum < order-i.item-no THEN itemnum = order-i.item-no.

            lnk = order-i.link-order.

            /* override with value in rent-rate field */
            /* causes issue with hold back from suspend
               use only for schools */

            IF t-funct-name = "rental.create" THEN
              RUN getinvrent. /* cannot use     getprice */
            DO:
              v-trans.retail = 0.
              v-trans.old-item = YES.
              IF v-trans.item-status = "OWING" THEN
              DO:
                v-trans.estat = "O".
                v-trans.product-no = "Returned/Owed".
              END.
              IF v-trans.line-desc[1] BEGINS "RH" THEN
                v-trans.line-desc[1] = "".  /* return versus f6 of RH */
              /* voids create the following condition so recreate */
              ELSE IF v-trans.item-status = ""
                  AND v-trans.product-no = "Returned/Owed" THEN
                DO:
                  FIND inv-master NO-LOCK WHERE inv-master.sku-no =
                    v-trans.sku-no NO-ERROR.
                  IF AVAILABLE inv-master THEN v-trans.product-no =
                      inv-master.product-no NO-ERROR.
                END.
              IF v-trans.estat <> "P" THEN
                IF NOT order-i.serial-no BEGINS "SKU#" THEN
                DO:
                  ASSIGN
                    t-rto-tot = (v-trans.orig-value * v-trans.qty)
                     + v-trans.rent-credit
                    /*t-rto-tot = v-trans.orig-value*/
                    t-rto-mth = v-trans.orig-value / v-trans.rent-rate.

                END.
            END.
            IF v-trans.estat <> "O" THEN not-owing = YES.
            IF v-trans.item-status = "LOAN" THEN. /* v-trans.estat = "L".*/
            t-paid = t-paid + v-trans.extended. /*** prev paid amt **/
            FIND inv-master NO-LOCK  /* compare dept's on exchange */
              WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
            IF AVAILABLE inv-master THEN
              v-trans.dept-code = inv-master.dept-code.
            IF v-trans.link-rent > s-link-rent THEN
              s-link-rent = v-trans.link-rent + 1.
            FIND order-s NO-LOCK OF order-i NO-ERROR.
            DO:
              IF AVAILABLE order-s THEN
              DO:
                v-trans.serial-no = order-s.serial-no.
              END.
              IF v-trans.serial-no <> "" THEN
                nrecs = nrecs + 1.
              /* nrecs is total# of  records with serial number/sku */
              ite = order-i.item-no + 1. /* is total # of items in order-i */
            END.
          END.
        /* patch as void sets amt-received to zero and regtot.p needs it */
        END.
        ELSE
        DO:
          ite = 1.
        END.
    END.
    ELSE MESSAGE "no order detected for this order".
  END.
  /* item type has been changed    */

  FOR EACH order-i OF order WHERE order-i.item-type BEGINS "S":
    FIND order-s OF order WHERE order-s.item-no = order-i.item-no NO-ERROR.
    IF AVAILABLE order-s AND order-s.item-no >= 400 THEN
    DO:
      DELETE order-s.
    END.
    FIND v-trans WHERE v-trans.item-no = order-i.item-no NO-ERROR.
    IF AVAILABLE v-trans THEN
      v-trans.item-no = v-trans.item-no - 400.
    DELETE order-i.
  END.

  itemnum = 0.
  FOR EACH v-trans:
    IF itemnum <= v-trans.item-no THEN itemnum = v-trans.item-no.
  END.
  FIND LAST order-i OF order NO-LOCK NO-ERROR.  /* a previous "rr" order-i */
  IF AVAILABLE order-i AND order-i.item-no > itemnum
    THEN itemnum = order-i.item-no.
  /** finally find original date for any item previously exchanged. ***/
  FOR EACH v-trans WHERE v-trans.link-rent <> v-trans.item-no:
  /** work up the chain */
  END.
/* if not recallsuspend and p-status <> "create" then do: */
END.

/* @(#) rnproc-getSchMth.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getSchMth.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getSchMth: /* patch the mth rate for schools into order-i */
  DEFINE INPUT PARAMETER tserial LIKE order-i.serial-no.
  DEFINE VARIABLE nf   AS CHARACTER NO-UNDO.
  DEFINE VARIABLE tinv AS DECIMAL   NO-UNDO.
  FIND inv-master NO-LOCK WHERE inv-master.sku-no = order-i.sku-no NO-ERROR.
  IF order-i.serial-no BEGINS "sku#"
    AND inv-master.serial-reqd <> "N" THEN ASSIGN
      nf      = "BAD"
      tserial = "".
  ELSE IF tserial <> "" AND inv-master.serial-reqd = "N" THEN ASSIGN
        nf = "".
  IF is-generic(order-i.sku-no) THEN
  DO:
    IF order-i.create-value <> 0 THEN
      v-trans.est-repair-cost
      = (v-trans.create-value * v-trans.qty) * .30 / 8.
    ELSE
      v-trans.est-repair-cost = (v-trans.orig-value * v-trans.qty) * .30
        / 8.
    RETURN.
  END.
  IF nf = "" THEN
    tinv = get-rent-rate-30(order-i.sku-no,
      order.loc-code, tserial).
  IF tinv = 0 THEN
    tinv = order-i.rent-rate * .08.
  FIND borderi OF order WHERE RECID(borderi) = recid(order-i) NO-ERROR.
  IF AVAILABLE borderi THEN
  DO:
    borderi.est-repair-cost = tinv.
    v-trans.est-repair-cost = tinv.
    RELEASE borderi.
  END.
END.

/* @(#) rnproc-recallsuspend.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-recallsuspend.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE recallsuspend:
  FIND LAST sale OF order NO-LOCK WHERE sale.void NO-ERROR.
  lnk = order.link-order.
  IF order.rent-code = "school" AND order.dt-due > year-end THEN
    year-end = order.dt-due.
  t-dt-enter = order.dt-due.
  IF AVAILABLE sale THEN
  DO:

    /* GRAB INFO FROM THE SKU 9999999 */
    FIND sale-i OF sale NO-LOCK WHERE sale-i.sku-no = 9999999 NO-ERROR.
    IF AVAILABLE sale-i THEN
    DO:
      IF sale-i.line-desc[1] BEGINS "RH" THEN pickUpBy = sale-i.line-desc[4].
      IF sale-i.product-no BEGINS "LOAN" THEN
        is-loan = YES.
    END.
    FIND sale-i OF sale NO-LOCK WHERE sale-i.sku-no = 9999993 NO-ERROR.
    IF AVAILABLE sale-i AND sale-i.sku-no = 9999993 THEN
    DO:
      ASSIGN
        tSchoolAcct        = sale-i.line-desc[1]
        tTeacher           = sale-i.line-desc[2]
        tStudent           = sale-i.line-desc[3]
        tSchCostShare      = sale-i.hold-flag
        tSchCostShareValue = sale-i.hold-retail
        tAcceptPass        = IF sale-i.line-desc[4] BEGINS "yes" THEN YES
                          ELSE NO.
    END.

    /***** DEAL ONLY WITH COPYING FOR ITEMS. *****/
    FOR EACH sale-i OF sale NO-LOCK:
      FIND sale-s OF sale-i NO-LOCK NO-ERROR.
      IF sale-i.sku-no > 9999990 THEN NEXT.
      IF sale-i.sku-no = 23 THEN NEXT.
      IF sale-i.sku-no = 0 THEN NEXT.

      /* RECREATE VLOCSRL IF INV-LOCSRL DOES NOT EXIST */
      IF AVAILABLE sale-s AND sale-i.item-type = "RI"
        AND NOT sale-i.serial-no BEGINS "sku#" AND sale-i.qty-from-new <> 0
        THEN
      DO:
        FIND inv-locsrl NO-LOCK WHERE inv-locsrl.sku-no = sale-i.sku-no
          AND inv-locsrl.serial-no = sale-s.serial-no NO-ERROR.
        IF NOT AVAILABLE inv-locsrl THEN
        DO:
          CREATE vlocsrl.
          BUFFER-COPY sale-i TO vlocsrl.
          ASSIGN
            vlocsrl.doc-ref         = order.order-no
            vlocsrl.dt-created      = TODAY     /* cannot retrieve from inv-locsrl*/
            vlocsrl.dt-first-rented = TODAY
            vlocsrl.dt-modified     = TODAY
            vlocsrl.cost            = sale-i.avg-cost.
        END.
      END.
      /* loan r4 141919 on N1733641 */
      CREATE v-trans.
      BUFFER-COPY sale-i TO v-trans.
      ASSIGN
        v-trans.link-order = order.link-order
        v-trans.qty-new    = sale-i.qty-from-new  /* BAD ON PARTIAL RETURNS*/
        v-trans.orig-value = v-trans.after-value
        v-trans.rent-rate  = sale-i.after-rate. /* does not store rent rate */
      IF sale-i.dt-loan <> ? THEN v-trans.dt-loan = sale-i.dt-loan.
      /* special case of school converted to monthly task 5681*/
      IF order.rent-code = "billing" AND order.int-status = "create" THEN
      DO:
        RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
          v-trans.dt-rented, OUTPUT v-trans.percent).
        IF v-trans.sku-no = 28 THEN v-trans.before-rate = 10.
        ASSIGN
          v-trans.after-rate = v-trans.before-rate /*convert back to school*/
          v-trans.extended   = v-trans.after-rate * v-trans.qty
          v-trans.retail     = v-trans.extended
          v-trans.rntrefund  = v-trans.retail.
      END.
      /* find out if item was a previous exchange and get discrecid,ratevar
       as these are not recovered from the sale-i */
      IF NOT AVAILABLE sale-s AND sale-i.item-type = "RI" THEN
      DO:
        FIND order-i OF order NO-LOCK
          WHERE order-i.item-no = sale-i.link-rent NO-ERROR.
        IF AVAILABLE order-i THEN   /* task 4355 */
          ASSIGN
            v-trans.disc-recid = order-i.disc-recid
            v-trans.rate-var   = order-i.rate-var.
        IF order-i.link-rent <> order-i.item-no THEN
          ASSIGN
            v-trans.link-rent = order-i.link-rent
            v-trans.link-item = order-i.item-no .
      END.

      IF AVAILABLE sale-s AND sale-i.item-type = "RI"
        AND sale-i.description BEGINS "Loan" THEN
        v-trans.dt-loan = TODAY.
      /* added nov30th */
      IF AVAILABLE sale-s AND sale-i.item-type = "rp" THEN
      DO:
        v-trans.orig-rentrate = sale-i.before-value. /* new item re-instate*/
        IF (order.order-no BEGINS "ro" OR order.order-no BEGINS "rs") THEN
          ASSIGN
            v-trans.extended  = sale-i.retail /* school?? */
            v-trans.retail    = v-trans.extended
            v-trans.rntrefund = v-trans.retail.
      END.
      /* INITIAL TESTING IN JUL17 SHOWS "RI" FOR NEW SCHOOL */
      IF AVAILABLE sale-s AND sale-i.item-type = "ri" THEN
      DO:
        IF (order.order-no BEGINS "ro" OR order.order-no BEGINS "rs") THEN
          v-trans.extended = sale-i.retail. /* school?? */
      END.

      IF v-trans.item-type = "RR" THEN
      DO:
        FIND order-i OF order NO-LOCK
          WHERE order-i.item-no = v-trans.link-rent NO-ERROR.

        ASSIGN
          v-trans.estat        = "R"
          v-trans.extended     = order-i.extended + (v-trans.retail - v-trans.disc-amt)
          v-trans.amt-received = order-i.extended
          v-trans.origextend   = order-i.extended
          v-trans.disc-amt     = order-i.disc-amt
          v-trans.rent-credit  = order-i.rent-credit
          v-trans.rate-var     = order-i.rate-var
          V-TRANS.OLD-ITEM     = YES.
      END.
      ELSE IF v-trans.item-type = "RE" THEN
        DO: /* the old item */
          FIND order-i OF order
            NO-LOCK WHERE order-i.item-no = v-trans.link-rent NO-ERROR.
          ASSIGN
            v-trans.estat        = "x"
            v-trans.link-item    = v-trans.item-no
            v-trans.extended     = order-i.extended
            v-trans.amt-received = order-i.extended
            v-trans.origextend   = order-i.extended
            v-trans.orig-amount  = order-i.extended
            v-trans.disc-amt     = order-i.disc-amt
            v-trans.rent-credit  = order-i.rent-credit
            v-trans.rate-var     = order-i.rate-var
            V-TRANS.OLD-ITEM     = YES.  /* estat = "x" */
        END.
        ELSE IF v-trans.item-type = "RB" THEN
          DO:
            /* patch for recovering suspended sale-i and COUPON */
            IF v-trans.line[4] BEGINS "BUY" THEN   /* performance warranty */
              ASSIGN
                v-trans.estat = "P".
            IF v-trans.sku-no = 351993 THEN    /* Coupon */
              ASSIGN
                v-trans.extended = v-trans.after-value * -1
                v-trans.retail   = v-trans.extended
                v-trans.estat    = "P".
            ELSE
              v-trans.extended = (v-trans.after-value * v-trans.qty)
                + v-trans.rent-owed.
            /* example strings did not have "p" nor line[4] begins BUY so error. */
            IF v-trans.rent-rate = 0 THEN v-trans.estat = "P".
          END.
      IF v-trans.item-type = "RI"
        AND AVAILABLE sale-s AND sale-i.link-rent <> 0
        AND sale-i.link-rent = sale-i.link-item
        AND sale-i.link-rent <> sale-i.item-no THEN
      DO:
        v-trans.estat = "E".
        v-trans.old-item = NO.

        FIND order-i OF order NO-LOCK WHERE order-i.item-no =
          v-trans.link-item NO-ERROR.
        IF AVAILABLE order-i THEN
        DO:  /* RECALC THE EXCHANGE */
          DEFINE VARIABLE p-rt-days AS INTEGER.
          DEFINE VARIABLE ratevar   AS DECIMAL.
          DEFINE VARIABLE old-date  AS DATE.
          ASSIGN
            old-date            = order-i.dt-rented - order-i.disc-recid
            v-trans.rate-var    = order-i.rate-var
            v-trans.disc-amt    = order-i.disc-amt
            v-trans.rent-credit = order-i.rent-credit.

          RUN effectdays.p(old-date, TODAY, OUTPUT p-rt-days).
          ratevar = (order-i.rent-rate - v-trans.rent-rate)
            / 30 * p-rt-days.

          v-trans.rate-var = v-trans.rate-var + ratevar.
          v-trans.disc-recid = v-trans.dt-rented - order-i.dt-rented
            + order-i.disc-recid.
          v-trans.extended = order-i.extended. /* wrong */
          v-trans.link-item = v-trans.item-no.
        END.
        ELSE IF v-trans.item-type = "RI"
            AND AVAILABLE sale-s AND sale-i.link-rent <> 0 AND
            sale-i.link-item = 0
            AND sale-i.link-rent = sale-i.item-no THEN
          DO:
            FIND order-i OF order NO-LOCK WHERE order-i.item-no =
              v-trans.link-item NO-ERROR.
            IF NOT AVAILABLE order-i THEN
            DO:
              v-trans.old-item = NO.
            END.
          END.
      END.
      ELSE IF v-trans.item-type = "RI" AND v-trans.product-no
          = "returned/owed" THEN
          ASSIGN
            v-trans.estat = "O".

      IF v-trans.item-type <> "rb" THEN v-trans.retail = 0.
      IF sale-i.item-type = "RP" THEN v-trans.item-type = "RI".
      IF v-trans.estat <> "e" THEN
      DO:
        FIND order-i NO-LOCK  OF order
          WHERE order-i.item-no = v-trans.link-rent NO-ERROR.
        IF AVAILABLE order-i THEN
        DO:

          ASSIGN
            v-trans.old-item     = YES
            v-trans.dt-return    = order-i.dt-return
            v-trans.disc-recid   = order-i.disc-recid
            v-trans.rate-var     = order-i.rate-var
            v-trans.disc-amt     = order-i.disc-amt /* occurs after suspend */
            v-trans.rent-credit  = order-i.rent-credit /* occurs after suspend*/
            v-trans.amt-received = order-i.amt-received
            v-trans.origextend   = sale-i.retail - sale-i.taxable-amt
            v-trans.extended     = sale-i.taxable-amt.
          /* task 2198 */
          IF v-trans.estat = "R" THEN
            ASSIGN
              v-trans.extended   = order-i.extended + (sale-i.retail - sale-i.disc-amt)
              v-trans.origextend = order-i.extended.
          IF v-trans.item-type = "RI" THEN
            ASSIGN
              v-trans.extended = order-i.extended
              t-paid           = t-paid + v-trans.extended.
          IF v-trans.item-type = "rb" AND v-trans.rent-rate <> 0 THEN
          DO:
            ASSIGN
              v-trans.extended    = sale-i.after-value - sale-i.rent-credit
              v-trans.estat       = "B"
              v-trans.rent-credit = sale-i.rent-credit.
          END.
          /* NEED TO LINK THE SALE-I.ITEM-TYPE "RE" WITH THE
             NEW ITEM ADDED WHICH HAS NO order-i. */
          IF itemnum < order-i.item-no THEN itemnum = order-i.item-no.

        END.
      END.
      ELSE IF NOT AVAILABLE order-i THEN
        DO:
          /**** NO ORDER-I CREATED SO MUST BE NEW ITEM ***********/

          IF is-loan THEN v-trans.dt-loan = TODAY.

        END.
      /* BIG PATCH FOR SCHOOL AS sale-i.after-rate not set on protection ***/
      IF v-trans.sku-no = 28
        AND (order.order-no BEGINS "ro" OR order.order-no BEGINS "rs") THEN
      DO:
        IF (order.rent-code = "billing" OR order.order-no BEGINS "ro")
          /*THEN v-trans.rent-rate = 1.
          ELSE v-trans.rent-rate = 10.*/
          /*12379/12448: Recall suspend should copy protection rates */
          THEN v-trans.rent-rate = IF (v-trans.old-item = NO AND v-trans.estat = "")
            THEN 2
            ELSE IF sale-i.after-rate <> 0
            THEN sale-i.after-rate
            ELSE 1.
        ELSE v-trans.rent-rate = IF (v-trans.old-item = NO AND v-trans.estat = "")
            THEN 20
            ELSE IF sale-i.after-rate <> 0
            THEN sale-i.after-rate
            ELSE 10.
      END.
    END.
    itemnum = 0.

    FOR EACH v-trans:      /* suspend does not recalc extended */
      IF v-trans.old-item = NO THEN
      DO:
        /* messes up ""p" and b" */
        IF order.rent-code = "billing" AND order.int-status = "create" THEN.
        ELSE
          RUN regularrent(OUTPUT v-trans.extended).
      END.
      FIND order-i OF order NO-LOCK
        WHERE order-i.item-no = v-trans.item-no NO-ERROR.
      IF AVAILABLE order-i THEN  /* patch for loss if info on suspend */
        ASSIGN
          v-trans.disc-recid = order-i.disc-recid
          v-trans.rate-var   = order-i.rate-var.
      IF order.rent-code = "billing" THEN
      DO: /* task 5681 */
        IF NOT AVAILABLE order-i THEN
          v-trans.origextend = v-trans.rent-rate * v-trans.qty.
        ELSE
          v-trans.origextend = order-i.extended.
      END.
      IF itemnum <= v-trans.item-no THEN itemnum = v-trans.item-no.
    END.

    FIND LAST order-i OF order NO-LOCK NO-ERROR.  /* a previous "rr" order-i */
    IF AVAILABLE order-i AND order-i.item-no > itemnum
      THEN itemnum = order-i.item-no.
  END.
END.

/* @(#) rnproc-loadvhold.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-loadvhold.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE loadvhold:
  FIND hold-order NO-LOCK WHERE hold-order.link-order = t-hold-link NO-ERROR.
  FOR EACH v-trans:
    DELETE v-trans.
  END.

  IF AVAILABLE hold-order THEN
    FOR EACH order-i NO-LOCK OF hold-order WHERE (order-I.item-type
      = "" OR order-i.item-type = "RI")  AND order-i.void = NO:
      CREATE v-trans.
      BUFFER-COPY order-i TO v-trans.
      ASSIGN
        v-trans.before-value = order-i.orig-value
        v-trans.before-rate  = order-i.rent-rate
        v-trans.after-value  = order-i.orig-value
        v-trans.after-rate   = order-i.rent-rate.
      /* {rn-vtrans.i}              patch below */

      v-trans.create-value = order-i.create-value.
      IF itemnum < order-i.item-no THEN itemnum = order-i.item-no.
      lnk = order.link-order.
      RUN getinvrent.
      DO:
        ASSIGN
          v-trans.link-order   = s-link-order
          v-trans.origextend   = order-i.extended  /* only place */
          v-trans.retail       = 0
          v-trans.old-item     = NO
          v-trans.rent-rate    = order-i.rent-rate
          v-trans.before-rate  = order-i.rent-rate
          v-trans.qty          = order-i.qty
          v-trans.qty-new      = order-i.qty-new
          v-trans.dt-rented    = TODAY
          v-trans.item-type    = "ri"
          v-trans.line-desc[1] = hold-order.order-no
          v-trans.serial-no    = order-i.serial-no
          v-trans.summer-chg   = ((order-i.rent-rate * order-i.qty) * .15).
        IF v-trans.estat <> "P" THEN
          v-trans.amt-received = v-trans.extended.
      END.
      IF v-trans.estat <> "O" THEN not-owing = YES.
      IF v-trans.item-status = "LOAN" THEN. /* v-trans.estat = "L".*/
      t-paid = t-paid + v-trans.extended. /*** prev paid amt **/

      IF v-trans.link-rent > s-link-rent THEN
        s-link-rent = v-trans.link-rent + 1.

      DEFINE VARIABLE testdate     AS DATE .
      DEFINE VARIABLE t-tot-due    AS DECIMAL.
      DEFINE VARIABLE t-disc       AS DECIMAL .
      DEFINE VARIABLE t-due-amount AS DECIMAL.
      testdate = order.dt-due.
      IF testdate <= TODAY THEN testdate = TODAY + 1.
      t-hold-link = hold-order.link-order.
      /* number 1 */
      RUN jacaltest.p(INPUT testdate, INPUT s-link-order,
        INPUT v-trans.item-no, OUTPUT t-tot-due,
        OUTPUT t-disc, OUTPUT t-due-amount).
      ASSIGN
        tPartialRefund   = v-trans.semester * - 1
        t-disc           = v-trans.taxrate2
        t-due-amount     = v-trans.taxrate1
        v-trans.extended = t-due-amount.

      IF v-trans.serial-no <> "" THEN
        nrecs = nrecs + 1.
      /* nrecs is total# of  records with serial number/sku */
      ite = order-i.item-no + 1. /* is total # of items in order-i */
    END.
  IF t-dt-enter < TODAY THEN t-dt-enter = TODAY + 1.
  RUN reopenquery.
  FIND order EXCLUSIVE-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
END.

/* @(#) rnproc-createorder.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-createorder.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE createorder:
  DEFINE VARIABLE t-cust LIKE customer.cust-no.

  IF t-funct-name = "rent.create" OR t-funct-name = "loan.create" THEN
    p-rent-code = "REGULAR" .
  ELSE IF t-funct-name = "r-own.create" THEN
      p-rent-code = "RENTOWN" .
    ELSE p-rent-code = "SCHOOL" . /* this is the default */
  IF p-rent-code = "REGULAR" THEN s-issue = TODAY. /* no backdates on regular */
  FIND customer NO-LOCK WHERE RECID(customer) = r-cust NO-ERROR.

  FIND register NO-LOCK WHERE
    register.reg-no = gwkreg AND register.loc-code = t-loc-code .

  RUN sl/get-ln-order.p(INPUT t-loc-code, OUTPUT s-link-order).
  CREATE order.
  ASSIGN
    order.loc-code           = t-loc-code
    order.sale-type          = "RN"
    order.order-no           = s-ordnum
    order.dt-created         = TODAY    /* s-issue can later overide */
    order.dt-prepaymt        = TODAY
    order.cust-no            = customer.cust-no
    order.link-order         = s-link-order
    order.int-status         = "create"
    order.co-code            = "l"
    order.rent-code          = p-rent-code
    p-orderid                = RECID(order)
    neworderec               = RECID(order)
    order.terms              = "create"
    order.renew              = 1
    order.invoice-comment[1] = pickUpBy
    order.empl-no            = t-empl-id
    order.DateStamp          = NOW
    t-renew                  = order.renew
    p-status                 = "create"
    order.dt-due             = t-dt-enter .

  IF t-dt-enter < TODAY THEN order.dt-due = TODAY.
  IF t-hold THEN order.invoice-comment[2] = hold-order.order-no.

  FIND syscust NO-LOCK WHERE syscust.type = "rn" NO-ERROR.
  IF AVAILABLE syscust THEN order.discount = syscust.dec-flag[5].
  IF order.order-no BEGINS "rs"
    OR order.order-no BEGINS "ro" THEN
    order.discount = 0. /* not for schools */
  IF order.order-no BEGINS "n" THEN
  DO:
    p-rent-code = "regular".
    order.rent-code = "REGULAR".
  END.
  IF order.order-no BEGINS "RO" THEN
  DO:
    p-rent-code = "rentown".
    order.rent-code = "rentown".
  /* if prepayday > 0 and prepayday < 29 then
  order.dt-prepaymt = date(month(today),prepayday,year(today)). *****/
  END.

  /* year-end comes from new  */
  IF order.rent-code = "SCHOOL" THEN
    order.dt-due = year-end.
  ELSE
    IF order.rent-code = "BILLING" THEN  /* no longer created can remove */
      RUN rx-setdate.p(OUTPUT order.dt-due).
  newordercreated = YES.
END.

/* @(#) rnproc-screenrefresh.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-screenrefresh.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE screenrefresh:
  HIDE FRAME brws-frame NO-PAUSE.
  status-ok = cust-browse:refresh().
  VIEW FRAME brws-frame.
END.

/* @(#) rnproc-reopenquery.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-reopenquery.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE reopenquery:    /* get other procs to use this */

  DEFINE VARIABLE x             AS INTEGER.
  DEFINE VARIABLE method-status AS LOGICAL.
  DEFINE VARIABLE temp-rowid    AS ROWID.
  method-status =
    cust-browse:set-repositioned-row(bl-row, "always") IN FRAME brws-frame.
  RUN correcttotal.    /* total up the v-trans */
  STATUS INPUT "".
  HIDE FRAME brws-frame NO-PAUSE.

  IF p-rent-code = "BILLING" THEN retitle =
      "  SERIAL#          MODEL            QTY      NET VALUE    Mo.RATE       PAID  "
      .
  ELSE IF p-rent-code = "SCHOOL" THEN retitle =
        "  SERIAL#          MODEL            QTY      NET VALUE    Yr.RATE       PAID  "
        .
    ELSE IF p-rent-code = "REGULAR" THEN retitle =
          "  SERIAL#          MODEL            QTY      NET VALUE     RATE(EA)    TOTAL  "
          .
      ELSE IF p-rent-code = "RENTOWN" THEN retitle =
            "  SERIAL#          MODEL            QTY      NET VALUE     Mo RATE     PAID   "
            .
  OPEN QUERY cust-qry FOR EACH v-trans NO-LOCK
    WHERE v-trans.item-status <> "SOLD"
    AND v-trans.item-type <> "RE" AND NOT v-trans.void
    AND v-trans.item-no <> 903.
  nrecs = 0.
  FOR EACH v-trans WHERE v-trans.item-type <> "RE"
    AND v-trans.void = NO:
    nrecs = nrecs + 1.   /* count of records */
  END.
  RUN displaytotal.
  bl-row = nrecs + 1.
  i = nrecs.
  IF bl-row > 7 THEN bl-row = 7.  /* when bl is > size of browser */

  REPOSITION cust-qry TO ROW(i).
  ENABLE cust-browse WITH FRAME brws-frame NO-LABELS TITLE retitle.
  PAUSE 0 NO-MESSAGE.  /* add */
  VIEW FRAME brws-frame.  /* added */
  PAUSE 0 NO-MESSAGE.
END.

/* @(#) rnproc-newwtrans.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-newwtrans.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE newwtrans:    /* creates a new blank line */
  /* set link-rent to above unless we find s-link-rent gets change elsewhere */
  CREATE v-trans.
  itemnum = itemnum + 1.

  v_rec = RECID(v-trans).
  ASSIGN
    newexchrec         = ?            /* kill exchange */
    exchrec            = ?

    is_exch            = NO
    v-trans.link-order = lnk
    v-trans.item-no    = itemnum
    v-trans.link-rent  = itemnum
    /* but is-loan is no when loan is overdue. */
    v-trans.dt-rented  = IF is-loan AND p-status = "create" THEN
                      s-dt-return ELSE IF is-loan AND p-status = "change"
                      AND order.dt-due >= TODAY THEN order.dt-due
                      ELSE IF t-funct-name = "loan.create" AND
                      p-status = "change" AND order.dt-due < TODAY THEN TODAY
    ELSE TODAY   /* s-issue1 changed aug 19 */
    v-trans.info-item  = YES
    v-trans.item-type  = 'RI'
    v-trans.dt-return  = IF is-loan THEN ?
                      ELSE IF t-funct-name = "loan.create"
                      AND p-status = "change" AND order.dt-due < TODAY THEN ?
    ELSE order.dt-due /* blank this out later */
    v-trans.old-item   = NO.
  IF is-loan AND p-status = "change" AND s-dt-return = ?
    THEN s-dt-return = order.dt-due.

  IF p-rent-code BEGINS "re" THEN
  DO:
    IF is-loan THEN
    DO:
      v-trans.dt-loan = IF f9active THEN s-issue ELSE TODAY.
      v-trans.item-status = "LOAN".
      IF t-funct-name = "loan.create" AND order.dt-due < TODAY THEN
        v-trans.dt-rented = TODAY.
      ELSE
        v-trans.dt-rented = s-dt-return.
    END.
    ELSE
      v-trans.dt-rented = IF f9active THEN s-issue ELSE TODAY.
    IF t-funct-name <> "loan.create" THEN
      v-trans.dt-return = IF f9active THEN dum-date ELSE order.dt-due.
  END.
END.

/* @(#) rnproc-showdipfield.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-showdipfield.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE showdipfield:
  HIDE FRAME fr-descrip NO-PAUSE.
  DISPLAY e WITH FRAME f OVERLAY.
  ENABLE e WITH FRAME f NO-LABELS NO-BOX ROW bl-row + offset COL 4.
  APPLY "entry" TO e IN FRAME f.
END.

/* @(#) rnproc-dof5.i 1.12 03/06/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-dof5.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE dof5:
  DEFINE VARIABLE t-frames    AS CHARACTER NO-UNDO.
  DEFINE VARIABLE t-focus     AS HANDLE    NO-UNDO.
  DEFINE VARIABLE z-endkey    AS LOG       INIT YES NO-UNDO.
  DEFINE VARIABLE t-set-vsale AS LOG       NO-UNDO.
  IF parseCoupon THEN
  DO:
    parseCoupon = NO.
    RETURN.
  END.
  oMsg:msg-hide().
  t-frames = save-frames-and-focus(t-focus).
  RUN sel-inv.w("overlay,row=18,start-model",OUTPUT recm).
  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  IF AVAILABLE inv-master THEN
    RUN dlgmodel.w(inv-master.nodash,
      v-trans.estat, inv-master.sku-no, OUTPUT recm, OUTPUT v-trans.serial-no).
  ELSE ASSIGN recm = ?.
  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  IF AVAILABLE inv-master THEN
  DO:
    FIND inv-locsrl NO-LOCK WHERE inv-locsrl.serial-no = v-trans.serial-no
      AND inv-locsrl.sku-no = inv-master.sku-no NO-ERROR.
    /* 9306 */
    IF AVAILABLE inv-locsrl AND inv-locsrl.demoitem = YES
      THEN
    DO:
      MESSAGE "Demo item will be changed into an used item." VIEW-AS ALERT-BOX.
    END. /* IF AVAILABLE inv-locslr*/

    IF AVAILABLE inv-locsrl THEN s-rec = RECID(inv-locsrl).
    IF AVAILABLE inv-master THEN
    DO: /* TASK 4047* chk on lywy */
      RUN rn-chkrepair.p(v-trans.serial-no,
        inv-master.sku-no, OUTPUT z-endkey).
      IF z-endkey = NO THEN
      DO:
        v-trans.serial-no = "".
        e = "".
        s-rec = ?.
        recm = ? .
      END.
    END.
  END.
  /* CASES non-serialzed or used serialized or flip to new screen **/
  restore-frames-and-focus(t-frames,t-focus).
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  oMsg:msg-refresh().
  PAUSE 0 NO-MESSAGE.

  IF recm = ? THEN
  DO:
    RUN setupframef(NO, YES).
    RETURN.
  END.
  ELSE
    FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  IF NOT AVAILABLE inv-master OR (is_exch AND AVAILABLE inv-master AND
    inv-master.serial-reqd = "n") THEN
  DO:
    ASSIGN
      recm              = ?
      v-trans.serial-no = ""
      e                 = "" .
    IF AVAILABLE inv-master THEN
      MESSAGE " YOU ARE ATTEMPTING TO EXCHANGE A SERIALIZED ITEM FOR ONE WHICH"
        SKIP
        "DOES NOT REQUIRE A SERIAL NUMBER. THE EXCHANGE WILL NOT BE COMPLETED."
        VIEW-AS ALERT-BOX.
    RETURN.
  END.

  IF (p-rent-code = "rentown" OR p-rent-code = "billing" OR p-rent-code =
    "school") AND (AVAILABLE inv-master AND inv-master.sku-no = 28) THEN
  DO:
    v-trans.rent-rate = 1.
    v-trans.avg-cost = 1.
    v-trans.orig-value = 1.
    IF p-rent-code = "school" THEN
      ASSIGN
        v-trans.rent-rate  = 10
        v-trans.avg-cost   = 10
        v-trans.orig-value = 10
        v-trans.avg-cost   = 10.
    IF v-trans.estat = "P" THEN v-trans.estat = "".
  END.
  ELSE
  DO:
    IF AVAILABLE inv-master AND inv-master.sku-no = 351993
      AND t-hold THEN
    DO:
      MESSAGE
        "RENTAL COUPONS CANNOT BE USED ON THE CREATE" SKIP
        "OF A RENTAL FROM A HOLD Contract."
        VIEW-AS ALERT-BOX.
      ASSIGN
        recm              = ?
        s-rec             = ?
        v-trans.serial-no = ""
        e                 = "".
      RELEASE inv-master.
      RETURN.
    END.
    RUN rn-holdtestskus.p(t-funct-name, INPUT-OUTPUT recm).
    IF t-funct-name <> "loan.create" THEN
    DO:
      IF v-trans.estat <> "P" THEN
      DO:
        IF (AVAILABLE inv-master
          AND (inv-master.group-no >= 8500 AND inv-master.group-no <= 8999))
          AND v-trans.estat <> "P"
          THEN
        DO:
          IF t-funct-name = "r-own.create" THEN
          DO:
            v-trans.estat = "P".
            buyrec = RECID(v-trans).
          END.
          ELSE
          DO:
            MESSAGE "SHEET MUSIC AND BOOKS MUST BE PURCHASED ON A RENTAL."
              VIEW-AS ALERT-BOX.
            ASSIGN
              recm = ?.
          END.
        END.
      END.
    END.
  END.   /* end of else do: */
  /* MUST TEST GROUP NO FOR PRINTED MATTER INDEPENDENTLY */
  IF recm = ? THEN
  DO:
    ASSIGN
      v-trans.estat     = ""
      v-trans.serial-no = ""
      e                 = "".
    IF is_exch THEN
    DO:
      FIND v-trans WHERE RECID(v-trans) = exchrec.
      v-trans.estat = "".
      v-trans.item-type = "RI".
      is_exch = NO.
      exchrec = ?.
    END.
    PAUSE 1 NO-MESSAGE.
    RUN reopenquery.
    RETURN.
  END.
  ELSE
  DO:
    /* QUESTION IS THIS IN EXCHANGE */
    IF neverUsed(inv-master.sku-no) = YES THEN
    DO:
      ASSIGN
        v-trans.estat = "P"
        buyrec        = RECID(v-trans).
      status-ok = cust-browse:refresh() IN FRAME brws-frame.
    END.

    IF t-funct-name = "r-own.create" AND NOT is_exch THEN
    DO:
      /** TEST FULLY EV-7 EXAMPLE inv-master.serial-reqd <> "N"
        and newwtrans  *******/
      /**** Allow serialized product ***/
      IF AVAILABLE inv-master AND inv-master.sku-no <> 28 THEN
      DO:
        IF AVAILABLE inv-master AND inv-master.serial-reqd = "N"
          OR (v-trans.isGeneric = YES) THEN
        DO:

          RUN getValidRtoAccessGroup.p(inv-master.group-no,OUTPUT pBuyOnly,
            OUTPUT pChoice).
          /***** NOT ALLOWED ON RTO'S *****/
          IF pBuyOnly = NO AND pChoice = NO THEN
          DO:
            IF inv-master.serial-reqd = "N" THEN
            DO: /* force purchase */

              ASSIGN
                v-trans.estat  = "P"
                v-trans.sku-no = inv-master.sku-no
                v-trans.qty    = 1
                buyrec         = RECID(v-trans).
            END.
          END.
          IF pChoice THEN
          DO:
            MESSAGE "Would customer like to add this product to the RTO contract?"
              SKIP
              "Type Y to add this product to the RTO contract " SKIP
              "or Type N to purchase this product now."
              VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE t-reply.

            IF t-reply = ? THEN t-reply = NO.
          END.
          IF t-reply = NO THEN
          DO:
            FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
            ASSIGN
              v-trans.estat = "P"  /* will call buynewitem */
              buyrec        = RECID(v-trans).
          END.

        END.
      END.
    END.

    IF t-funct-name <> "loan.create" THEN
    DO:
      IF AVAILABLE inv-master AND (inv-master.group-no >= 8500
        AND inv-master.group-no <= 8522)
        OR (AVAILABLE inv-master
        AND (inv-master.group-no > 8523 AND inv-master.group-no <= 8999))
        THEN
      DO:
        FIND v-trans WHERE RECID(v-trans) = v_rec.
        ASSIGN
          v-trans.estat = "P"  /* will call buynewitem */
          buyrec        = RECID(v-trans).
      END.
    END.
    /* MAY NEED TO APPLY FOR "P" OR LOAN ABOVE AS WELL */
    IF v-trans.serial-no = "" AND inv-master.serial-reqd = "N"
      THEN
    DO:   /* pc-10 would land here */
      RUN usenonserial.
      RETURN.
    END.
  END.
  /* END OF PLAYING WITH INV-MASTER, NOW SEE vlocsrl OR inv-locsrl exists */
  s_ser = v-trans.serial-no.              /* case we have a serial-no */

  /* TEST IF ALREADY ON THIS ORDER ***/
  DEFINE VARIABLE t-flag AS LOG NO-UNDO.
  RUN rn-testitem.p(v-trans.serial-no, inv-master.sku-no, v_rec,
    OUTPUT t-flag).
  IF t-flag THEN
  DO:
    IF is_exch THEN ASSIGN e = "".
    VIEW cust-browse IN FRAME brws-frame.
    RETURN.
  END.

  IF v-trans.serial-no <> "" THEN
  DO:

    FIND inv-locsrl WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
    IF AVAILABLE inv-locsrl THEN
    DO:
      BUFFER-COPY inv-locsrl TO v-trans.
      ASSIGN
        v-trans.used-flag  = "U"
        v-trans.dept-code  = inv-master.dept-code
        v-trans.product-no = inv-master.product-no
        v-trans.qty        = 1
        v-trans.date-code  = inv-locsrl.date-code.
      IF inv-locsrl.description = "" THEN
        ASSIGN
          v-trans.description = inv-master.description.
      IF inv-locsrl.description <> "" THEN ASSIGN
          v-trans.product-no = inv-locsrl.description.
      ELSE
        ASSIGN
          v-trans.product-no = inv-master.product-no.
      /***** THIS SECTION HERE NEEDS TO DEAL WITH GETPRICE
           AND RENTRET  : FOR SCHOOLS RTO?/
           t-askAgain(input-output t-ask-again).
       ***************/

      RUN useskuno. /* forces rto exchange */
      IF is_exch AND NOT t-funct-name = "r-own.create" THEN
      DO:

        RUN rentexch.
      END.
      PAUSE 1 NO-MESSAGE.
    END.
  END.
  /* THIS SECTION WOULD ONLY HAPPEN ON F4 OF NO SELECTION **/
  /* when an inv-master got selected but selection list had no item
     then an f4 back will allow creating an item with serial num */

  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  IF AVAILABLE inv-master AND s-rec = ? THEN
  DO:
    IF inv-master.serial-reqd <> "N" THEN
    DO:
      FIND bmast WHERE RECID(bmast) = recm NO-LOCK NO-ERROR.
      FIND b-inv WHERE RECID(b-inv) = s-rec NO-LOCK NO-ERROR .
      FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
      IF (v-trans.estat <> "p") OR (v-trans.estat = "p"
        AND inv-master.serial-reqd = "y") THEN
      DO:
        /*create new item here */
        RUN getitem(INPUT-OUTPUT s-rec). /* should run rn-unravel.p */
        /* THIS SHOULD END IT FOR NEW ITEMS ON RTO */
        /* THE ABOVE FAILS WHEN EXCHANGE ACROSS DEPT NOT ALLOWED */
        IF AVAILABLE vlocsrl THEN
        DO:
          ASSIGN
            recm = RECID(bmast).
          FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
          FIND FIRST vlocsrl WHERE RECID(vlocsrl) = s-rec NO-ERROR.
          IF AVAILABLE vlocsrl THEN
          DO:
            FIND v-trans WHERE v-trans.sku-no = vlocsrl.sku-no
              AND v-trans.serial-no = vlocsrl.serial-no NO-ERROR.
            IF AVAILABLE v-trans AND v-trans.link-rent = v-trans.item-no THEN
            DO:
              IF order.rent-code = "school" THEN
              DO:  /* skips rto */
                FIND v-trans WHERE RECID(v-trans) = v_rec.
              END.
            END.
          END.
          RETURN.
        END.
        /* inv-master is lost on new item not exchangeable on schools aug 25*/
        ELSE IF NOT AVAILABLE vlocsrl THEN
          DO:
            IF s-rec <> ? THEN
            DO:
              FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
              IF AVAILABLE inv-locsrl THEN
              DO:
                RUN rn-chkrepair.p(inv-locsrl.serial-no,
                  inv-master.sku-no, OUTPUT z-endkey).
                IF z-endkey = NO THEN
                DO:
                  v-trans.serial-no = "".
                  e = "".
                  RETURN.
                END.
                ASSIGN
                  v-trans.sku-no     = inv-locsrl.sku-no
                  v-trans.serial-no  = inv-locsrl.serial-no
                  v-trans.product-no = inv-locsrl.description
                  v-trans.dept-code  = inv-master.dept-code
                  v-trans.date-code  = inv-locsrl.date-code.
                IF inv-locsrl.description <> "" THEN
                DO:
                  v-trans.product-no = inv-locsrl.description.
                  v-trans.description = inv-locsrl.description.
                END.
                ELSE
                DO:
                  v-trans.product-no = inv-master.product-no.
                  v-trans.description = inv-master.description.
                END.
                IF AVAILABLE inv-locsrl THEN
                DO:
                  RUN useskuno.
                  IF is_exch THEN
                  DO:

                    RUN rentexch.
                  END.
                /* run buynewitem in useskuno as newwtrans already called */
                END.
              END.
            END.  /* end of v-trans.estat = "p" */
          END.
        IF LASTKEY = keycode("f4") THEN
        DO:
          IF is_exch THEN
          DO:
            FIND v-trans WHERE RECID(v-trans) = exchrec.
            v-trans.estat = "".
            v-trans.item-type = "RI".
            is_exch = NO.
          END.
          RETURN.
        END.
        IF is_exch THEN
        DO:

          RUN rentexch.
          is_exch = NO.  /*** should i ? */
        END.
        ELSE
        DO:
          /* VLOCSRL NOT CREATED so EXCHANGE ACROSS DEPT HITS HERE
            and inv-master is lost */
          PAUSE 0 NO-MESSAGE.
          RUN screenrefresh.
          IF NOT is-unravel AND AVAILABLE inv-master THEN  /* not on packages */
            RUN paidoff.
        END.
        IF AVAILABLE v-trans
          AND v-trans.estat = "p" AND inv-master.serial-reqd = "r" THEN
          RUN usenonserial.      /* treat as if a sku-no. */
        ELSE IF NOT AVAILABLE v-trans THEN
            RETURN.
      END.
      ELSE
      DO:
        RUN usenonserial.
      END.
    END.
    PAUSE 0 NO-MESSAGE.
  END.

  /* Display any existing Rental notes for product when adding by Model/SKU/Brand/Etc... search */
  IF AVAILABLE inv-master THEN DO:
    DEF VAR skuCount AS INT NO-UNDO INIT 0.
    
    FOR EACH v-trans WHERE
    v-trans.sku-no = inv-master.sku-no
    AND (v-trans.dt-rented = TODAY OR v-trans.dt-loan = TODAY)  /* Loan-Rentals store the return date under DT-RENTED */
    AND v-trans.dt-LastStatusChanged = ?:                       /* and their start date under DT-LOAN. */
      IF AVAIL v-trans THEN
        skuCount = skuCount + 1.
    END.

    IF skuCount = 1 THEN DO:
      t-rental-notes = GetInvNotes(inv-master.sku-no, "rentals").
      IF t-rental-notes <> "" THEN
        MESSAGE t-rental-notes VIEW-AS ALERT-BOX INFORMATION.
    END.
  END.
  /* Restore current v-trans record after checking for Rental Notes */
  IF v_rec <> ? OR v_rec <> 0 THEN
    FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
END PROCEDURE.

/* @(#) rnproc-getdescription.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getdescription.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getdescription:
  DEFINE VARIABLE tempserial AS CHARACTER NO-UNDO.

  IF v-trans.sku-no = 0351993 THEN
  DO: /* COUPON */
    DEFINE FRAME tCoupon
      v-trans.serial-no FORMAT "x(40)" VIEW-AS FILL-IN SIZE 16 BY 1
      WITH NO-LABELS TITLE "Enter Coupon Serial Number" OVERLAY.
    loopcx: REPEAT ON ERROR UNDO loopcx, LEAVE loopcx
      ON ENDKEY UNDO loopcx, LEAVE loopcx:
      IF v-trans.serial-no BEGINS "sku#" THEN ASSIGN
          v-trans.serial-no = "".
      DISPLAY v-trans.serial-no WITH FRAME tCoupon OVERLAY.
      ENABLE v-trans.serial-no WITH FRAME tCoupon OVERLAY
        ROW bl-row + offset COL 21.
      APPLY "entry" TO v-trans.serial-no IN FRAME tCoupon.
      WAIT-FOR RETURN, f4 OF v-trans.serial-no IN FRAME tCoupon.
      IF LASTKEY = keycode("f4") THEN RETURN.

      IF v-trans.serial-no:screen-value <> "" THEN
      DO:
        /**** needs work to use here
        define var pValue as char no-undo.
        pValue = "351993#" + v-trans.serial-no:screen-value.
        run ParseCoupon.p(pValue, v-trans.item-no, output v-trans.sku-no,
          output v-trans.serial-no, output v-trans.description).
        ******/
        FIND FIRST tender-track NO-LOCK
          WHERE tender-track.tend-no = 8
          AND tender-track.number = v-trans.serial-no:screen-value NO-ERROR.
        IF NOT AVAILABLE tender-track THEN
        DO:
          MESSAGE "Coupon serial number has not been created!"
            VIEW-AS ALERT-BOX.
          ASSIGN
            v-trans.serial-no              = "SKU# 0351993"
            v-trans.product-no             = inv-master.product-no
            v-trans.description            = ""
            v-trans.serial-no:screen-value = "".
        END.
        ELSE
        DO:   /* has been created */
          IF tender-track.dt-redeem <> ? THEN
          DO:
            MESSAGE "Coupon has already been redeemed and may not be used!"
              VIEW-AS ALERT-BOX.
            ASSIGN
              v-trans.serial-no              = "SKU# 0351993"
              v-trans.product-no             = inv-master.product-no
              v-trans.description            = ""
              v-trans.serial-no:screen-value = "".
          END.
          ELSE IF tender-track.expDate < TODAY THEN
            DO:
              MESSAGE "Coupon has already expired and may not be used!"
                VIEW-AS ALERT-BOX.
              ASSIGN
                v-trans.serial-no              = "SKU# 0351993"
                v-trans.product-no             = inv-master.product-no
                v-trans.description            = ""
                v-trans.serial-no:screen-value = "".
            END.

            ELSE
            DO:  /* number good and redeemable */
              tempserial = v-trans.serial-no:screen-value.

              FIND order NO-LOCK
                WHERE order.LINK-ORDER = v-trans.link-order NO-ERROR.
              IF AVAILABLE order AND order.order-no BEGINS "RO" THEN
              DO:
                MESSAGE "RENTAL COUPON SKU 351993 ARE NOT ALLOWED ON RTO CONTRACTS!"
                  VIEW-AS ALERT-BOX.
                ASSIGN
                  v-trans.serial-no              = "SKU# 0351993"
                  v-trans.product-no             = inv-master.product-no
                  v-trans.description            = ""
                  v-trans.serial-no:screen-value = "".
              END.
              ELSE IF AVAILABLE order AND order.int-status <> "create" THEN
                DO:
                  ASSIGN
                    v-trans.serial-no              = "SKU# 0351993"
                    v-trans.product-no             = inv-master.product-no
                    v-trans.description            = ""
                    v-trans.serial-no:screen-value = "".
                  MESSAGE
                    "Rental Coupons can only be used on the create of a new Contract."
                    VIEW-AS ALERT-BOX.
                END.
              FOR EACH b-trans WHERE b-trans.serial-no = "SKU# 0351993"
                AND RECID(b-trans) <> recid(v-trans):
                IF b-trans.description = v-trans.serial-no:screen-value THEN
                DO:
                  MESSAGE "Coupon is already on this Contract" VIEW-AS ALERT-BOX.
                  ASSIGN
                    v-trans.serial-no              = "SKU# 0351993"
                    v-trans.product-no             = inv-master.product-no
                    v-trans.description            = ""
                    v-trans.serial-no:screen-value = "".
                END.
                ELSE
                DO:
                  MESSAGE "Only one Coupon allowed per Transaction"
                    VIEW-AS ALERT-BOX.
                  ASSIGN
                    v-trans.serial-no              = "SKU# 0351993"
                    v-trans.product-no             = inv-master.product-no
                    v-trans.description            = ""
                    v-trans.serial-no:screen-value = "".
                END.
              END.
              IF v-trans.serial-no:screen-value <> "" THEN
                ASSIGN
                  v-trans.description = v-trans.serial-no:screen-value
                  v-trans.orig-value  = tender-track.amount
                  v-trans.serial-no   = "SKU# 0351993"
                  v-trans.retail      = v-trans.orig-value * - 1
                  v-trans.extended    = v-trans.orig-value * - 1
                  v-trans.item-type   = "RB"
                  v-trans.product-no  = inv-master.product-no
                  v-trans.link-item   = v-trans.item-no  /*for suspend of sale-i*/
                  v-trans.estat       = "P".
            END.

        END.

        HIDE MESSAGE NO-PAUSE.
        /*assign frame tCoupon v-trans.serial-no. */
        HIDE FRAME tCoupon NO-PAUSE.

        DISABLE v-trans.serial-no WITH FRAME tCoupon.
        IF v-trans.description <> "" THEN LEAVE.
        IF v-trans.serial-no <> "" AND v-trans.serial-no <> "SKU# 0351993"
          THEN LEAVE.
        IF LASTKEY = keycode("f4") THEN LEAVE.
      END.
      HIDE MESSAGE NO-PAUSE.
      HIDE FRAME tCoupon NO-PAUSE.

    END.
    RETURN.
  END.
  DEFINE VARIABLE t-prod AS CHARACTER.
  DEFINE FRAME ttt
    v-trans.product-no FORMAT "x(40)" VIEW-AS FILL-IN SIZE 16 BY 1
    WITH NO-LABELS OVERLAY.
  loopax: REPEAT ON ERROR UNDO loopax, LEAVE loopax
    ON ENDKEY UNDO loopax, LEAVE loopax:
    IF v-trans.serial-no BEGINS "sku#" AND NOT
      v-trans.serial-no = "SKU# 0422888" THEN ASSIGN v-trans.product-no = "".
    ELSE IF AVAILABLE v-trans AND v-trans.serial-no = "SKU# 0422888"
        AND AVAILABLE inv-master THEN ASSIGN
          v-trans.product-no = inv-master.description.
    DISPLAY v-trans.product-no WITH FRAME ttt OVERLAY.
    ENABLE v-trans.product-no WITH FRAME ttt OVERLAY
      NO-BOX NO-LABELS ROW bl-row + offset COL 21.
    APPLY "entry" TO v-trans.product-no IN FRAME ttt.
    WAIT-FOR RETURN, f4 OF v-trans.product-no IN FRAME ttt.
    HIDE MESSAGE NO-PAUSE.
    ASSIGN FRAME ttt v-trans.product-no.
    HIDE FRAME ttt NO-PAUSE.
    v-trans.description = v-trans.product-no.
    DISABLE v-trans.product-no WITH FRAME ttt.
    IF v-trans.product-no <> "" THEN LEAVE.
  END.
  HIDE MESSAGE NO-PAUSE.
  HIDE FRAME ttt NO-PAUSE.
END.

/* @(#) rnproc-useskuno.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-useskuno.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE useskuno:
  DEFINE VARIABLE t-flag      AS LOG       NO-UNDO.
  DEFINE VARIABLE t-set-vsale AS LOG       NO-UNDO.
  DEFINE VARIABLE iStatFlag   AS CHARACTER. /* from beLocSrl.cls flag is R,RH,I,S,T,H,!*/
  IF LASTKEY = keycode("f4") THEN RETURN. /* TEST THE CONDITION THAT CALLS*/
  FIND v-trans WHERE RECID(v-trans) = v_rec.
  IF NOT AVAILABLE inv-locsrl THEN
    FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
  ELSE s-rec = RECID(inv-locsrl).
  IF NOT AVAILABLE inv-master THEN
    FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  ELSE recm = RECID(inv-master). /* Loses recm on scanner */

  IF AVAILABLE inv-locsrl THEN
  DO:

    RUN rn-testitem.p(v-trans.serial-no, inv-master.sku-no, v_rec, OUTPUT t-flag).
    /* ---------- test to see if item entered is already on this order ---*/
    IF t-flag THEN
    DO:
      IF is_exch THEN ASSIGN e = "".
      VIEW cust-browse IN FRAME brws-frame.
      RETURN.
    END.


    /* TEST FOR RENT TO OWN THAT EITHER A INV-RENT EXISTS OR IS SKU 39, 49*/
    IF p-rent-code = "rentown" THEN
    DO:
      IF inv-master.sku-no <> 39 AND inv-master.sku-no <> 49 THEN
      DO:
        FIND LAST inv-rent NO-LOCK
          WHERE inv-rent.loc-code = ""
          AND inv-rent.sku-no = inv-master.sku-no
          AND inv-rent.dt-start <=  TODAY
          AND inv-rent.dt-end   >= TODAY NO-ERROR.
        IF AVAILABLE inv-rent THEN
        DO:
          v-trans.pInvRentExists = YES.
          BUFFER-COPY inv-rent TO v-trans.
          RUN rnGetDefaultMths.p(inv-master.sku-no,
            OUTPUT v-trans.defaultMonths).
        END.
        IF NOT AVAILABLE inv-rent THEN
        DO:
          FIND v-trans WHERE RECID(v-trans) = v_rec.
          ASSIGN
            v-trans.estat = "P"  /* will call buynewitem */
            buyrec        = RECID(v-trans).

        END.
      END.
      ELSE IF (inv-master.sku-no = 39 OR inv-master.sku-no = 49) THEN
        DO:
          /* seems to get lost NOTE IF WILL FIND INV-RENT FOR PREV ITEM */
          RELEASE inv-rent.
          FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.

          IF AVAILABLE v-trans AND AVAILABLE inv-locsrl THEN
          DO:
            v-trans.product-no = inv-locsrl.description.
            /* determine it this was just created and selling price */
            IF inv-locsrl.doc-ref BEGINS order.order-no AND
              (v-trans.orig-value = 0 OR v-trans.orig-value = ?)  THEN
            DO:
              MESSAGE
                "THIS ITEM SKU CANNOT BE CREATED AND ADDED TO A RENT TO OWN" SKIP
                "CONTRACT WITHOUT FIRST ENTERING A CURRENT SELLING PRICE." SKIP
                "CREATE THE ITEM RECORD IN INVENTORY AND THEN CREATE THE RENT" SKIP
                "TO OWN CONTRACT" VIEW-AS ALERT-BOX.
              FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
              ASSIGN
                v-trans.serial-no   = ""
                v-trans.product-no  = ""
                v-trans.description = ""
                v-trans.avg-cost    = 0.
              VIEW cust-browse IN FRAME brws-frame.
              RETURN.
            END.
            IF NOT AVAILABLE inv-rent THEN
            DO:
              v-trans.avg-cost = get-current-retail(inv-locsrl.sku-no,
                inv-locsrl.serial-no).
              v-trans.orig-value  = v-trans.avg-cost.
            END.
            IF AVAILABLE v-trans  /* USED ITEMS MAY NOT HAVE A VALUE */
              AND (v-trans.orig-value = ? OR v-trans.orig-value = 0) THEN
            DO:
              MESSAGE "Current Selling price not available for item." SKIP
                "Please have that entered on inventory record" SKIP
                "before placing item on contract." VIEW-AS ALERT-BOX.
              FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
              ASSIGN
                v-trans.serial-no   = ""
                v-trans.product-no  = ""
                v-trans.description = ""
                v-trans.avg-cost    = 0.
              VIEW cust-browse IN FRAME brws-frame.
              RETURN.
            END.
          END.
        END.
    END.

    /* restore v-trans to current record being processed. */
    FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
    /* ---------- end of testing for item if already on this order ---- */
    IF NOT is_exch THEN
      IF NOT duplicate-ran THEN
        IF (inv-locsrl.i-status = -1 AND inv-locsrl.doc-ref <> order.order-no)
          OR inv-locsrl.i-status = 2
          AND inv-locsrl.serial-no = v-trans.serial-no THEN
        DO:

          IF inv-locsrl.i-status = 2 THEN
          DO:
            iStatFlag = get-status(inv-locsrl.serial-no,inv-locsrl.sku-no).
            IF iStatFlag BEGINS "R" OR iStatFlag = "S" THEN
              MESSAGE "Item with serial#" inv-locsrl.serial-no
                "and model#" inv-master.product-no        SKIP
                "has already been"
                IF iStatFlag = "S" THEN "sold" ELSE "rented"
                "if the item has a different sku#, please add it"  SKIP
                "to the used inventory by pressing F5."  SKIP
                "***************************************************************" SKIP
                "NOTE: YOU ARE ALLOWED TO ADD THIS ITEM TO THE CONTRACT BUT PLEASE" SKIP
                "CHECK SERIAL RETAIL INQUIRY AND GET PRIOR EXISITING CONTRACT CLOSED."
                SKIP   "*************************************************************** "
                SKIP "               TO ADD ITEM SELECT OK                              "
                VIEW-AS ALERT-BOX QUESTION BUTTONS OK-CANCEL UPDATE t-reply.

            IF NOT t-reply THEN
            DO:

              DEFINE VARIABLE t-num AS INTEGER INIT 0.
              FOR EACH inv-locsrl NO-LOCK
                WHERE inv-locsrl.serial-no = v-trans.serial-no :
                IF CAN-FIND(inv-master WHERE inv-master.sku-no = inv-locsrl.sku-no
                  AND inv-master.serial-reqd <> "N") THEN
                  t-num = t-num + 1.
              END.
              IF t-num = 1 OR t-reply = NO THEN
              DO:
                v-trans.product-no = "".
                s-rec = ?.
                v-trans.serial-no = "".
                RETURN.
              END.
              ELSE IF t-num > 1 THEN
                DO:
                  FIND inv-master NO-LOCK
                    WHERE inv-master.sku-no = inv-locsrl.sku-no
                    AND inv-master.serial-reqd <> "N" NO-ERROR.
                  IF AVAILABLE inv-master THEN
                    ASSIGN recm = RECID(inv-master).
                  ELSE recm = ? .
                  RUN rn-dlgser.w(v-trans.serial-no,
                    INPUT-OUTPUT recm, OUTPUT s-rec, OUTPUT t-found ).
                  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
                  FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
                  IF recm <> ? THEN
                  DO:  /* test if item is on this contract */
                    RUN rn-testitem.p(v-trans.serial-no, inv-master.sku-no,
                      v_rec, OUTPUT t-flag).
                    IF t-flag THEN
                    DO:
                      IF is_exch THEN ASSIGN e = "".
                      VIEW cust-browse IN FRAME brws-frame.
                      RETURN.
                    END.
                  END.
                  IF recm = ? THEN
                  DO:
                    v-trans.product-no = "".
                    s-rec = ?.
                    v-trans.serial-no = "".
                    RETURN.
                  END.
                  ELSE
                  DO:
                    IF inv-locsrl.description <> "" THEN
                      v-trans.product-no = inv-locsrl.description.
                    ELSE
                      v-trans.product-no = inv-master.product-no.
                  END.
                END.
            END.
          END.
        END.

    /* when a generic serialized use whats already in product-no else */
    FIND inv-master NO-LOCK WHERE inv-master.sku-no = inv-locsrl.sku-no NO-ERROR.
    IF AVAILABLE inv-master THEN ASSIGN recm = RECID(inv-master).
    IF v-trans.product-no = "" THEN
      IF inv-locsrl.description <> "" THEN
        v-trans.product-no = inv-locsrl.description.
      ELSE
        v-trans.product-no = inv-master.product-no.

    ASSIGN
      v-trans.serial-no = inv-locsrl.serial-no
      v-trans.sku-no    = inv-locsrl.sku-no
      v-trans.qty       = 1.
    /* if item has serial number and needs description then do */
    FIND inv-master NO-LOCK WHERE inv-master.sku-no =
      inv-locsrl.sku-no NO-ERROR.
    FIND sysrectp NO-LOCK WHERE
      sysrectp.rec-type = inv-master.rec-type NO-ERROR.
    IF AVAILABLE sysrectp THEN
      IF sysrectp.desc-req THEN
      DO:
        looptc: DO ON ERROR UNDO looptc, LEAVE looptc
          ON ENDKEY UNDO looptc, LEAVE looptc:
          status-ok = cust-browse:refresh() IN FRAME brws-frame.
          IF v-trans.product-no = "" THEN
            RUN getdescription.
          v-trans.orig-value = 0.
        END.
        IF AVAILABLE inv-locsrl THEN
          IF v-trans.serial-no = "" THEN
          DO:
            ASSIGN
              v-trans.serial-no = STRING("SKU# ") +
            string(inv-locsrl.sku-no,"9999999").
            /* insert here the description problem  */
            FIND inv-master NO-LOCK WHERE inv-master.sku-no =
              inv-locsrl.sku-no NO-ERROR.
          END.
        RUN getprice.    /*mar21 */

        IF AVAILABLE inv-master THEN
          RUN paidoff. /* oct25/99 example sks-11b didnt land on qty field. */

        VIEW FRAME brws-frame.
        IF NOT is_exch THEN
        DO:
          IF v-trans.estat = "" THEN
          DO: /* block auto "P" */
            RUN newwtrans.
            RUN tAskAgain(INPUT-OUTPUT t-ask-again).
          END.
          ELSE
            RUN newwtrans.
        END.
        RETURN.

      END.
      ELSE
      DO:   /* description not required */
        /* rto exchange can hit here */
        RUN getprice.
      END.

    IF v-trans.product-no = "" THEN
    DO:
      FIND inv-master NO-LOCK WHERE RECID (inv-master) = recm.
      IF AVAILABLE inv-master THEN
        ASSIGN v-trans.product-no = inv-master.product-no.
    END.
    /* finally you should add totals to fr-total2 run p-display. */
    PAUSE 0 NO-MESSAGE.
    VIEW FRAME brws-frame.   /* testcode */
  END.
  ELSE
  DO:

    IF NOT is_exch AND AVAILABLE inv-master THEN
    DO:  /*AUG25TH add avail inv-mast*/
      RUN paidoff.
    END.
  END.
  /* change made here from old */
  IF NOT is_exch THEN
  DO:
    IF s-rec <> ? AND p-rent-code <> "rentown" THEN
    DO:
      IF order.int-status = "create" AND NOT t-hold THEN
        /*12851: t-dt-enter being set to ? when adding used package serial to monthly*/
        t-dt-enter = IF s-dt-return <> ? THEN s-dt-return ELSE t-dt-enter.
        //t-dt-enter = s-dt-return.
      ELSE IF NOT t-hold THEN t-dt-enter = order.dt-due.
      oMsg:msg-hide().
      PAUSE 0 NO-MESSAGE.
      is-unravel = NO.
      IF v-trans.extended = ? THEN
      DO: /* patch after 1 item already added */
        RUN rentret(v-trans.sku-no).  /*1st call in useskun0 */
      END.
      /* avoid purchasing the first item at the rent rate bug 191 */
      IF v-trans.estat = "p" AND v-trans.old-item = NO
        THEN v-trans.extended = v-trans.orig-value * v-trans.qty.
      /* CALLS VERSION 1.19  */
      RUN rn-unravel.p(s-rec, recm, t-dt-enter, s-link-order,
        v-trans.orig-value, v-trans.rent-rate,
        INPUT-OUTPUT itemnum, OUTPUT is-unravel).

      PAUSE 0 NO-MESSAGE.
      FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
      oMsg:msg-refresh().
      PAUSE 0 NO-MESSAGE.
      RUN reopenquery.
    END.
    IF v-trans.estat = "P" AND inv-master.serial-reqd = "y" THEN
    DO:
      RUN buynewitem.  /* works for f7key first and mf-2008-00 */
      PAUSE 0 NO-MESSAGE.
      RUN reopenquery.
      PAUSE 1 NO-MESSAGE.
    END.    /* following reqd for e160p when f7 first and wrrty of 1 year */
    IF v-trans.product-no = "" AND v-trans.orig-value = 0
      AND v-trans.rent-rate = 0 THEN.
    ELSE
      /* do not run new line. it will be run somewhere else for buynewitem. */

      IF v-trans.estat = "" THEN
      DO:  /* block auto "p" */
        RUN newwtrans.
        RUN tAskAgain(INPUT-OUTPUT t-ask-again).
      END.
      ELSE
        RUN newwtrans.



  END.
  PAUSE 1 NO-MESSAGE.
END.

/* @(#) rnproc-fromgetserial.i 1.7 03/06/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-fromgetserial.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE fromgetserial:
  DEFINE VARIABLE t-endkey    AS LOG NO-UNDO.
  DEFINE VARIABLE t-set-vsale AS LOG NO-UNDO.
  oMsg:msg-hide().
  ASSIGN
    recm  = ?
    s-rec = ?.

  HIDE FRAME brws-frame.  /* these 4 lines required for create of contract*/
  HIDE FRAME fr-total2.
  ENABLE e WITH FRAME f.
  HIDE FRAME f NO-PAUSE.
  /* return off of an entered serial number arrives here */
  IF p-rent-code = "School" OR p-rent-code = "BILLING" THEN
  DO:
    IF AVAILABLE order AND order.int-status <> "create" AND NOT is_exch THEN
    DO:
    END.
  END.

  RUN rn-getserial.p(INPUT-OUTPUT v-trans.serial-no, t-scanin, "RHCONTRACT",
    p-rent-code, INPUT-OUTPUT recm,
    OUTPUT s-rec, OUTPUT t-endkey).
  /* note: recm assigned on vlocrsl */

  t-scanin = NO.    /* clear scanner. */
  RUN reopenquery. /* required for create of contract */

  oMsg:msg-refresh().
  PAUSE 0 NO-MESSAGE. /* added jan 19/2006 */

  IF (t-endkey = NO AND s-rec = ?) OR LASTKEY = keycode("f4") THEN
  DO:
    ASSIGN
      recm              = ?
      s-rec             = ?     /* these are assigned in rn-getserial */
      v-trans.serial-no = ""
      e                 = "".
    RELEASE inv-master.

    PAUSE 0 NO-MESSAGE.
    PAUSE 1 NO-MESSAGE.    /* clear or it cycles */
    APPLY "entry" TO e IN FRAME f.
    RETURN.
  END.
  IF s-rec <> ? THEN
  DO:
    FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.

    IF NOT AVAILABLE inv-locsrl THEN
    DO:
      FIND vlocsrl WHERE RECID(vlocsrl) = s-rec NO-ERROR.
      IF AVAILABLE vlocsrl THEN
        RUN bufCopyVlocsrl.
      /* ALREADY RUN IN bufcopy
      run regularrent(output v-trans.extended).
       */
      RETURN.
    END.
    ELSE IF AVAILABLE inv-locsrl THEN
      DO:
        FIND inv-master NO-LOCK
          WHERE inv-master.sku-no = inv-locsrl.sku-no NO-ERROR.
        IF AVAILABLE inv-master THEN ASSIGN recm = RECID(inv-master).
      END.
  END.
  IF LASTKEY <> keycode("f4") THEN
  DO:
    FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.

    IF NOT AVAILABLE inv-locsrl THEN
    DO:
      FIND vlocsrl WHERE RECID(vlocsrl) = s-rec NO-ERROR.
      IF AVAILABLE vlocsrl THEN
      DO:   /* possible new item */

        FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
        BUFFER-COPY vlocsrl TO v-trans.
        ASSIGN
          vlocsrl.doc-ref      = order.order-no
          v-trans.qty          = 1
          v-trans.orig-value   = vlocsrl.origvalue
          v-trans.create-value = v-trans.orig-value
          v-trans.before-value = v-trans.orig-value
          v-trans.after-value  = v-trans.orig-value
          v-trans.avg-cost     = vlocsrl.origvalue.

        IF is-generic(v-trans.sku-no) AND AVAILABLE vlocsrl THEN
        DO:
          v-trans.product-no = vlocsrl.description.
        END.

        IF vlocsrl.description = "" THEN
          ASSIGN
            v-trans.product-no  = inv-master.product-no
            v-trans.description = inv-master.description.

        IF NOT t-funct-name = "r-own.create" THEN
        DO:

          IF is-generic(v-trans.sku-no)
            AND NOT AVAILABLE inv-locsrl THEN
          DO:
            RUN rentret(v-trans.sku-no).  /* call fromgetseria */
            RUN regularrent(OUTPUT v-trans.extended).
            /* if sku49 and estat "p" then undo sets extended wrong */
            v-trans.amt-received = v-trans.extended.
          END.
          /* VERSION 1.19 REQUIRES THIS */
          IF rentPackage(inv-master.sku-no) THEN
          DO:
            CREATE inv-locsrl.
            BUFFER-COPY vlocsrl TO inv-locsrl.
            IF NOT is-generic(inv-locsrl.sku-no) THEN
              inv-locsrl.over-retail = 0.
            IF AVAILABLE order THEN inv-locsrl.doc-ref = order.order-no.
            inv-locsrl.i-status = -1.
            DELETE vlocsrl.
            s-rec = RECID(inv-locsrl).
            FIND inv-locsrl NO-LOCK
              WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
            is-unravel = NO.
            /* CALLS VERSION 1.19  */
            RUN rn-unravel.p(s-rec, recm, t-dt-enter, s-link-order,
              v-trans.orig-value, v-trans.rent-rate,
              INPUT-OUTPUT itemnum, OUTPUT is-unravel).
          END.
        END.
        ELSE
        DO:
          RUN rentret(v-trans.sku-no). /* 1st call fromgetSer */
          IF NOT is_exch THEN
          DO:

            IF v-trans.estat = "" THEN
            DO:
              RUN newwtrans.
              RUN tAskAgain(INPUT-OUTPUT t-ask-again).
            END.
            ELSE
              RUN newwtrans.
          END.
          RUN reopenquery.
          PAUSE 1 NO-MESSAGE.   /* prevents cycling off return off used-u*/
          RETURN.
        END.
      END.
    END.      /* should fall thru for rto's */
    FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
    IF NOT AVAILABLE inv-master THEN
    DO:
      /* probably serial numbers were not created for this item ie pc-10*/
      /* but scan in might have produced inv-locsrl. */
      IF NOT AVAILABLE inv-locsrl THEN
      DO:

        ASSIGN
          v-trans.serial-no = ""
          e                 = ""
          s-rec             = ?.
        RETURN.
      END.
    END.
    DEFINE VARIABLE z-endkey AS LOG INIT NO NO-UNDO.
    duplicate-ran = NO.

    IF AVAILABLE inv-master AND AVAILABLE inv-locsrl THEN
    DO:
      RUN rn-duplicates.p(buffer inv-locsrl, buffer inv-master, buffer order,
        v-trans.item-no, OUTPUT z-endkey).
      IF z-endkey = NO THEN
      DO:
        ASSIGN
          v-trans.serial-no = ""
          e                 = ""
          recm              = ?
          s-rec             = ?.
        RETURN.
      END.
      ELSE duplicate-ran = YES.
    END.

    IF AVAILABLE inv-master THEN
    DO:
      RUN rn-chkrepair.p(v-trans.serial-no,
        inv-master.sku-no, OUTPUT z-endkey).
      IF z-endkey = NO THEN
      DO:
        v-trans.serial-no = "".
        e = "".
        RETURN.
      END.
    END.    
    IF AVAILABLE inv-locsrl AND inv-locsrl.description <> "" THEN
    DO:
      v-trans.product-no = inv-locsrl.description.
      v-trans.description = inv-locsrl.description.
    END.
    ELSE IF AVAILABLE inv-locsrl AND AVAILABLE inv-master THEN
      DO:
        v-trans.product-no = inv-master.product-no.
        v-trans.description = inv-master.description.
      END.
    RUN useskuno.
    /* Check if SKU already exists in this transaction. Display Rental Notes if it doesn't */
    IF AVAILABLE inv-master THEN DO:
      DEF VAR skuCount AS INT NO-UNDO INIT 0.
      FOR EACH v-trans WHERE
      v-trans.sku-no = inv-master.sku-no
      AND (v-trans.dt-rented = TODAY OR v-trans.dt-loan = TODAY)  /* Loan-Rentals store the return date under DT-RENTED */
      AND v-trans.dt-LastStatusChanged = ?:                       /* and their start date under DT-LOAN. */
        IF AVAIL v-trans THEN
          skuCount = skuCount + 1.
      END.
      
      IF skuCount = 1 THEN DO:
        t-rental-notes = GetInvNotes(inv-master.sku-no, "rentals").
        IF t-rental-notes <> "" THEN
          MESSAGE t-rental-notes VIEW-AS ALERT-BOX INFORMATION.
      END.
    END.
    /* Restore current v-trans record after checking for Rental Notes */
    IF v_rec <> ? OR v_rec <> 0 THEN
      FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.    
  END.
END PROCEDURE.

/* @(#) rnproc-used-rent.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-used-rent.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE used-rent: /* callers setF5, */
  DEFINE VARIABLE on-order    AS LOG INIT NO.
  DEFINE VARIABLE itemreset   AS LOG INIT NO.
  DEFINE VARIABLE z-endkey    AS LOG NO-UNDO.
  DEFINE VARIABLE t-set-vsale AS LOG NO-UNDO.
  IF p-rent-code = "School" OR p-rent-code = "BILLING" THEN
  DO:
    IF AVAILABLE order AND order.int-status <> "create" AND NOT is_exch THEN
    DO:

    END.
  END.


  HIDE FRAME brws-frame.
  ENABLE e WITH FRAME f.   /* seems necessary for following dec 04 */
  /* but should not enable after 'no match found...' message */
  HIDE FRAME f NO-PAUSE.   /* put in oct17/2000 */
  RUN sel-inv.w("overlay,row=8,start-model",OUTPUT recm).
  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.

  t-scanin = NO.
  HIDE FRAME f NO-PAUSE.           /* dec 04 */

  IF LASTKEY = keycode("f4") OR recm = ? THEN
  DO:
    ASSIGN
      e                 = ""
      v-trans.serial-no = "".
    IF is_exch THEN
    DO:
      FIND v-trans WHERE RECID(v-trans) = exchrec.
      v-trans.estat = "".
      v-trans.item-type = "RI".
      is_exch = NO.
      FIND v-trans WHERE RECID(v-trans) = v_rec.
    END.

    RETURN.
  END.
  ELSE IF LASTKEY <> keycode("f4") AND recm <> ? THEN
    DO:

      /* typed in coupon numbers are rejected as serial numbers */
      FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
      IF inv-master.sku-no = 351993 THEN
      DO:
        ASSIGN
          recm              = ?
          s-rec             = ?
          v-trans.serial-no = ""
          e                 = "".
        RELEASE inv-master.
        RETURN.
      END.

      RUN rn-holdtestskus.p(t-funct-name, INPUT-OUTPUT recm). /* validates recm*/

      /*TEST PRINTED MATTER SEPARATELY */
      IF recm = ? THEN
      DO:
        /* reset on exchange */
        ASSIGN
          e                 = ""
          v-trans.serial-no = "".
        RETURN.
      END.

      /* next check if item is serialized or not. If so, get the inv-locsrl */
      IF inv-master.serial-reqd <> "N" THEN
      DO:
        FIND FIRST inv-locsrl NO-LOCK WHERE inv-locsrl.sku-no = inv-master.sku-no
          AND inv-locsrl.serial-no = v-trans.serial-no NO-ERROR.

        IF NOT AVAILABLE inv-locsrl THEN s-rec = ?.  /* null pointer */
        ELSE s-rec = RECID(inv-locsrl).
        IF AVAILABLE inv-locsrl THEN
        DO:
          s-rec = RECID(inv-locsrl).
          RUN rn-chkrepair.p(v-trans.serial-no,
            inv-master.sku-no, OUTPUT z-endkey).
          IF z-endkey = NO THEN
          DO:
            v-trans.serial-no = "".
            RETURN.
          END.
        END.
        /* this is not accurate */
        IF AVAILABLE inv-locsrl AND inv-locsrl.i-status <> 0 THEN
        DO:
          FIND LAST sale-s NO-LOCK
            WHERE sale-s.serial-no = inv-locsrl.serial-no NO-ERROR.
          IF AVAILABLE sale-s THEN FIND sale-i OF sale-s
              WHERE sale-i.sku-no = inv-locsrl.sku-no AND NOT sale-i.void NO-ERROR.

          /* don't care if sale is voided as need to find order-i first */
          IF AVAILABLE sale-i THEN FIND sale OF sale-i NO-LOCK NO-ERROR.
          /* only useful in finding last open contract, previous arent found*/
          IF AVAILABLE sale THEN
          DO:
            FIND employee OF sale NO-LOCK NO-ERROR.
            FIND order OF sale WHERE order.int-status <> "picked up"
              NO-LOCK NO-ERROR.
            IF AVAILABLE order THEN
            DO:
              FIND customer OF order NO-LOCK NO-ERROR.
              FIND order-s OF order NO-LOCK
                WHERE order-s.serial-no = inv-locsrl.serial-no NO-ERROR.
              IF AVAILABLE order-s THEN FIND order-i OF order NO-LOCK
                  WHERE order-i.sku-no = inv-locsrl.sku-no
                  AND order-i.item-no = order-s.item-no NO-ERROR.
              IF AVAILABLE order-i AND order-i.item-type = "ri"
                AND order-i.item-status <> "OWING" THEN
              DO:
                itemreset = YES.
                MESSAGE
                  "Serial#"inv-locsrl.serial-no "is already on"
                  order.order-no
                  "with Custmer Number" order.cust-no
                  "There is no indication that this item was returned from"
                  "that order."
                  VIEW-AS ALERT-BOX.
              /* need to fix the f4 back on this */
              END.
            END.
          END.
        END.
      END.
      /* ----- End of section testing if item is on order **/
      FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
      FIND inv-locsrl NO-LOCK WHERE inv-locsrl.sku-no = inv-master.sku-no
        AND inv-locsrl.serial-no = v-trans.serial-no NO-ERROR.
      IF NOT AVAILABLE inv-locsrl THEN s-rec = ? .
      IF AVAILABLE inv-master THEN
        /* june27/12 found this was locking fr-inv.p */
        FIND bmast WHERE RECID(bmast) = recid(inv-master) NO-LOCK NO-ERROR.
      FIND b-inv WHERE RECID(b-inv) = s-rec NO-LOCK NO-ERROR .

      FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
      IF NOT itemreset AND inv-master.serial-reqd <> "n" THEN
      DO:


        /* task 5800 */
        IF (v-trans.estat = "p" AND inv-master.serial-reqd = "r") THEN
        DO:
          RUN usenonserial.  /* serial# not required */
        END.
        ELSE
        DO:
          RUN getitem(INPUT-OUTPUT s-rec). /* already buffer-copies */
          IF s-rec = ? OR LASTKEY = keycode("f4") THEN
          DO: /*f4 from  */
            ASSIGN
              v-trans.serial-no = ""
              s-rec             = ?
              recm              = ?
              v-trans.estat     = "".
            RETURN.
          END.
        END.
      END.
      /*  what if bmast is different from inv-master
      then inv-locsrl could be different item */
      ASSIGN
        recm  = RECID(bmast)
        s-rec = RECID(b-inv).
      FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.

      FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
      IF AVAILABLE inv-locsrl THEN
      DO:
        RUN rn-chkrepair.p(inv-locsrl.serial-no, inv-master.sku-no,
          OUTPUT z-endkey).
        IF z-endkey = NO THEN
        DO:
          v-trans.serial-no = "".
          e = "".
          RETURN.
        END.
      END.
    END.
  IF LASTKEY = keycode("f4") THEN
  DO:
    v-trans.serial-no = "" .
    IF is_exch THEN
    DO:
      FIND v-trans WHERE RECID(v-trans) = exchrec.
      v-trans.estat = "".
      v-trans.item-type = "RI".
      is_exch = NO.
    END.
    RETURN.
  END.

  VIEW FRAME brws-frame.
  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
  IF AVAILABLE inv-locsrl THEN
  DO:
    ASSIGN
      v-trans.serial-no = inv-locsrl.serial-no.
    IF AVAILABLE inv-locsrl THEN
      IF inv-locsrl.description <> "" THEN
        v-trans.product-no = inv-locsrl.description.
      ELSE
        v-trans.product-no = inv-master.product-no.
    v-trans.description = inv-master.description.
    v-trans.dept-code = inv-master.dept-code.
    RUN useskuno.
  END.
END PROCEDURE.

/* @(#) rnproc-getschool.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getschool.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE  getschool:
  DEFINE INPUT PARAMETER pf3 AS LOG NO-UNDO.
  DEFINE VARIABLE tHighDate AS DATE.
  DEFINE VARIABLE pnDue     AS DECIMAL.
  DEFINE VARIABLE p-endkey  AS LOGICAL NO-UNDO.

  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
  IF AVAILABLE order THEN
    ASSIGN p-orderid = RECID(order)
      chg-code  = order.charge-code.

  /* otherwise reset to current value */
  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"hide").
  oMsg:msg-hide().
  /*  if p-status = "create" then  */

  DEFINE VARIABLE sch-cust    AS RECID NO-UNDO.
  DEFINE VARIABLE sch_created AS LOG   NO-UNDO.

  /* DONT RELOAD FOR F3 KEY ***/
  IF (order.rent-code = "SCHOOL" OR order.rent-code = "Billing" )
    AND NOT pf3 THEN
  DO:
    tAcceptPass = NO. /* should be no on create */
    IF tSchoolAcct = "" THEN
    DO:
      /*FIND SCHOOL IN LAST SALE WHICH HAS THE SCHOOL INFO*/
      FOR EACH bsale OF order NO-LOCK WHERE NOT bsale.void AND
        NOT bsale.reg-no BEGINS "P"
        BY bsale.dt-trans DESCENDING:
        FIND FIRST bsale-i OF bsale WHERE bsale-i.sku-no = 9999993
          AND bsale-i.LINE-DESC[1] <> "" NO-LOCK NO-ERROR.
        IF NOT AVAILABLE bsale-i THEN NEXT.
        ELSE
        DO:
          /***FIND LAST bsale OF order NO-LOCK WHERE NOT bsale.void AND
           NOT bsale.reg-no BEGINS "P"  /* not PR OR PN */
          NO-ERROR.
          IF AVAIL bsale THEN DO:
            FIND sale-i OF bsale NO-LOCK WHERE sale-i.sku-no = 9999993 NO-ERROR.
            IF AVAIL sale-i THEN DO:***/
          ASSIGN
            tSchoolAcct = bsale-i.LINE-DESC[1]
            tTeacher    = bsale-i.LINE-DESC[2]
            tStudent    = bsale-i.LINE-DESC[3]
            tAcceptPass = IF bsale-i.line-desc[4] BEGINS "yes" THEN YES
                              ELSE NO.
          LEAVE.
        END.
      END.
    END.          /* change as of oct10 allow adds to existing schools */


    f9active = NO. /* DOES NOT GO THROUGH date_ret.w screen */
    RUN rn-getyearend.p("school", TODAY, OUTPUT year-end).
    /* tYears = 1.*/
    /* MAKE SURE ORDER.DT-DUE IS A VALID O6/30/20XX ***/
    /* display valid due dates in advance of this year-end */
    IF YEAR-END < ORDER.DT-DUE
      AND DAY(order.dt-due) = 30 AND MONTH(order.dt-due) = 6 THEN
      year-end = order.dt-due.
    chg-code = order.charge-code.
    RUN rs-SchoolRentInfo.p(buffer order,
      INPUT-OUTPUT tRental,
      INPUT-OUTPUT tSchoolAcct,
      INPUT-OUTPUT tTeacher,
      INPUT-OUTPUT tStudent,
      INPUT-OUTPUT tSchCostShare,
      INPUT-OUTPUT tSchCostShareValue,
      INPUT-OUTPUT year-end,
      INPUT-OUTPUT chg-code,
      INPUT-OUTPUT tAcceptPass,
      INPUT-OUTPUT tShipDirect,
      OUTPUT tYears).
    IF tAcceptPass = NO THEN
      ASSIGN tSchCostShare      = NO tSchCostShareValue = 0.
    IF t-funct-name <> "loan.create" THEN
    DO:
      IF order.charge-code <> chg-code
        AND order.int-status = "create" THEN
      DO TRANSACTION:
        order.charge-code = chg-code.
      END.
    END.
    RELEASE order.
    FIND order NO-LOCK
      WHERE order.link-order = s-link-order NO-ERROR.

    /***** tYears wont work once created it sees the due date first
      need to change it if you start to add items ******/
    IF order.int-status <> "create" THEN
    DO:
      IF order.dt-due = year-end AND tYears = 1
        AND order.dt-due - TODAY > 365 THEN tyears = tyears + 1.
    END.
    ELSE IF order.int-status = "create" THEN
      DO:
        IF order.dt-due = year-end THEN
        DO:
          IF order.dt-due - TODAY > 365 THEN tyears = tyears + 1.
        /*tYears = 2. */
        END.
      END.
    IF AVAILABLE order THEN
    DO:
      FIND customer NO-LOCK WHERE customer.cust-no = order.order-no NO-ERROR.
      RUN last-cust.p("set",buffer customer).
    END.
  END.

  /****    run schedit.p   ****/
  oMsg:msg-refresh().

  IF LASTKEY = keycode("f4") AND NOT pf3 THEN
  DO:
    FIND customer NO-LOCK WHERE RECID(customer) = r-cust NO-ERROR.
    RUN last-cust.p("set",buffer customer).
    oMsg:msg-refresh().
    RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
    /* back to browser br-order8.p */
    RETURN ERROR.
  END.
  oMsg:msg-refresh().
  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").

  FIND order NO-LOCK WHERE order.link-order = s-link-order.
END PROCEDURE.

/* @(#) rnproc-getcust.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getcust.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getcust:
  DEFINE VARIABLE chk-corr AS LOG.
  PAUSE 0 NO-MESSAGE.  /* req'd when code called from submenu off main */
  p-auth = "".
  tx-msg = NO.
  /* possible recid's not undone on return to customer display */
  ASSIGN
    recm       = ?
    s-rec      = ?
    exchrec    = ?
    newexchrec = ?.
  IF AVAILABLE inv-locsrl THEN RELEASE inv-locsrl.
  /* find order no-lock where order.link-order = s-link-order no-error. */

  IF AVAILABLE order AND s-link-order = order.link-order
    AND p-orderid = recid(order) THEN
  DO: /* task 5894 show overdue/ar screens*/
    FIND customer OF order NO-LOCK NO-ERROR.
    IF AVAILABLE customer THEN r-cust = RECID(customer).
    /********************************************************************
    *  GO DISPLAY CUSTOMER INFORMATION STATUS SCREEN(S).                   *
    *    -SPECIAL NOTES, CUSTOMER BALANCES, CONTRACT INFO ETC.             *
    ********************************************************************** */
    oMsg:msg-hide().
    RUN cust-i.w(INPUT r-cust,"",OUTPUT t-endkey).
    IF t-endkey THEN
    DO:
      r-cust = ?.
      RETURN ERROR.
    END.
  END.     /* end task 5894 */
  ELSE
    RUN sel-cust.w("Order#,read-notes", OUTPUT r-cust, OUTPUT cust_created).
  IF r-cust <> ?
    THEN FIND customer NO-LOCK WHERE RECID(customer) = r-cust NO-ERROR.
  /* set var for default of letter reminder */
  IF AVAILABLE customer THEN
  DO:
    t-reminder = customer.reminders.
    RUN ps/chk-custstat.p(buffer customer, OUTPUT p-auth, OUTPUT t-endkey).
    IF t-endkey THEN RETURN ERROR.
  END.
  ASSIGN
    s-dt-return        = ?
    t-dt-enter         = ?
    s-issue            = TODAY
    tSchoolAcct        = ""
    tTeacher           = ""
    tStudent           = ""
    tAcceptPass        = NO
    tSchCostShare      = NO
    tSchCostShareValue = 0
    chg-code           = 0
    tYears             = 1.
  RUN rn-getyearend.p("school", TODAY, OUTPUT year-end).
  IF LASTKEY = keycode("f4") THEN
    RETURN ERROR.
END PROCEDURE.

/* @(#) rnproc-displaycust.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-displaycust.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE displaycust:     /* has 4 calls to this procedure */
  FIND customer NO-LOCK WHERE RECID(customer) = r-cust NO-ERROR.
  RUN disp-cust.p(buffer customer).
  RUN last-cust.p("clear",buffer customer).  /* task 5106*/
  RUN last-cust.p("set",buffer customer).
END PROCEDURE.

/* @(#) rnproc-selectorder.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-selectorder.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE selectorder:
  DEFINE VARIABLE cnt    AS INTEGER   INIT 0.
  DEFINE VARIABLE s-no   AS CHARACTER INIT "" .
  DEFINE VARIABLE t-exit AS LOG       INIT YES.

  a-reply = YES.
  FIND customer NO-LOCK WHERE RECID(customer) = r-cust NO-ERROR.

  t-reminder = customer.reminders.
  dontbackout = NO.
  FOR EACH v-trans WHERE RECID(v-trans) <> v_rec AND NOT v-trans.void:
    IF v-trans.old-item = NO OR
      (v-trans.estat <> "" AND NOT v-trans.estat = "l"
      AND NOT v-trans.estat = "o") THEN dontbackout = YES.
    cnt = cnt + 1.
  END.
  a-reply = YES.
  /* whether or not you back out always re-initialize */

  FIND order WHERE order.link-order = s-link-order NO-ERROR.
  IF AVAILABLE order THEN FIND FIRST order-i OF order NO-LOCK NO-ERROR.

  DO TRANSACTION: /* mark new order as picked up */
    FIND order WHERE order.link-order = s-link-order NO-ERROR.
    IF AVAILABLE order THEN
      IF order.int-status = "create"
        AND order.terms = "create" AND NOT commit-sale
        THEN ASSIGN
          order.int-status         = "PICKed UP"
          order.invoice-comment[2] = "".
  END.
  /*

  */
  p-orderid = ?.
  s-link-order = ?.

  FOR EACH v-trans:
    DELETE v-trans.
  END.
  /* check to see if customer has overdue payments */
  IF AVAILABLE customer AND LASTKEY <> keycode("f4") AND p-auth = ""
    THEN RUN overdue-msg.p (INPUT customer.cust-no, OUTPUT s-no, OUTPUT t-exit).
  /* above returns yes if not overdue or if overdue and authorized */
  IF t-funct-name = "rent.create" OR t-funct-name = "loan.create" THEN
  DO:
    chg-code = 0.    /* might also work for schools but not yet tested. */
  END.
  oMsg:msg-hide().
  RUN br-order8.p
    (INPUT customer.cust-no, OUTPUT p-orderid, INPUT t-funct-name).
  IF LASTKEY = keycode("f4") OR t-exit = NO THEN RETURN ERROR.
  IF p-orderid <> ? THEN
  DO:
    FIND order NO-LOCK WHERE RECID(order) = p-orderid NO-ERROR.
    IF AVAILABLE order THEN
    DO:

      IF order.order-no BEGINS "RH" THEN
      DO:
        IF order.invoice-comment[1] <> "" THEN
        DO:
          DEFINE VARIABLE pickreplay AS LOG INIT NO NO-UNDO.
          MESSAGE
            order.invoice-comment[1] "IS AUTHORIZED TO PICK UP THIS RENTAL."
            SKIP
            "IS" order.invoice-comment[1] "THE PERSON PICKING UP THIS RENTAL?"
            VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE pickreplay.
          IF pickreplay = ? THEN pickreplay = NO.
          IF pickreplay
            THEN ASSIGN
              pickUpBy    = order.invoice-comment[1]
              custInStore = NO.
          ELSE IF pickreplay = NO OR pickreplay = ? THEN
            DO:
              FIND na-info OF customer NO-LOCK NO-ERROR.
              MESSAGE
                "IS " na-info.name "PICKING UP THIS RENTAL." VIEW-AS ALERT-BOX
                QUESTION BUTTONS YES-NO UPDATE pickreplay.
              IF pickreplay = ? THEN pickreplay = NO.
              IF pickreplay
                THEN pickUpBy = "".   /* set as customer picks up */
              ELSE
              DO:
                MESSAGE "AUTHORIZED PICKUP PERSON NOR CUSTOMER ARE PRESENT." SKIP
                  "PLEASE SEE ACCOUNT SERVICES OR MANAGER FOR DIRECTION ON COMPLETING"
                  SKIP
                  "THIS RENTAL TRANSACTION." VIEW-AS ALERT-BOX.
                pickUpBy = "".
                RETURN ERROR.     /* go no further as not cust nor assignee */
              END.
            END.
        END.
        ASSIGN
          t-hold-link = order.link-order
          t-hold      = YES.
        IF order.dt-due > TODAY THEN
          ASSIGN
            s-dt-return = order.dt-due
            t-dt-enter  = order.dt-due.
        ELSE t-dt-enter = TODAY + 1.
        IF p-auth BEGINS "write off" THEN
        DO:
          MESSAGE "NEW Contracts cannot be created for writeoff customers"
            VIEW-AS ALERT-BOX.
          RETURN ERROR.
        END.
      END.
      ELSE
      DO:
        s-link-order = order.link-order.
        t-reminder = order.reminders.
        chg-code = order.charge-code.
      /* run setup-tsale. */
      END.
    END.
  END.
  ELSE IF p-orderid = ? THEN
    DO:
      IF p-auth BEGINS "write off" THEN
      DO:
        MESSAGE "NEW Contracts cannot be created for writeoff customers"
          VIEW-AS ALERT-BOX.
        RETURN ERROR.
      END.
      IF t-funct-name = "rent.create" OR t-funct-name = "loan.create"
        THEN RUN get-next.p(INPUT "", INPUT "N", INPUT "N9999999",
          OUTPUT s-ordnum).
      ELSE IF t-funct-name = "rental.create" THEN RUN get-next.p
            (INPUT "", INPUT "RS", INPUT "RS999999",OUTPUT s-ordnum).
        ELSE IF t-funct-name = "r-own.create" THEN RUN get-next.p
              (INPUT "", INPUT "RO", INPUT "RO999999",OUTPUT s-ordnum).
      RUN createorder.
      IF t-funct-name = "loan.create" AND p-status = "create" THEN
      DO:
        RUN loanreason.p(INPUT s-link-order, INPUT t-empl-id,
          INPUT p-status, OUTPUT msg-create, OUTPUT loanreason, OUTPUT loantype).
        IF LASTKEY = keycode("f4") OR t-exit = NO THEN RETURN ERROR.
      /* if loanreason = "" then return error. */
      END.

    END.
  PAUSE 0 NO-MESSAGE.
  IF AVAILABLE order THEN
    ASSIGN s-ordnum = order.order-no.
  DISPLAY s-ordnum WITH FRAME fr-ord.
  RUN displaycust.
END PROCEDURE.

/* @(#) rnproc-itembrowser.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-itembrowser.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE itembrowser:

  RUN equipfailure.
  DEFINE FRAME zz.
  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
  IF NOT AVAILABLE order THEN RETURN.
  emplDisc = NO.
  FIND customer NO-LOCK WHERE RECID(customer) = r-cust.
  HIDE FRAME fr-total NO-PAUSE.
  IF NOT msg-create THEN
  DO:
    FIND ord-lywy OF order NO-LOCK NO-ERROR.
    IF AVAILABLE ord-lywy THEN
    DO:
      IF ord-lywy.comment[1] = "" AND ord-lywy.comment[2] = ""
        AND ord-lywy.comment[3] = "" AND ord-lywy.contact = "" THEN
      DO TRANSACTION:
        FIND ord-lywy EXCLUSIVE-LOCK OF order NO-ERROR.
        IF AVAILABLE ord-lywy AND NOT tShipDirect THEN DELETE ord-lywy.
      END.
      ELSE
        IF ord-lywy.comment[1] <> "" OR ord-lywy.comment[2] <> ""
          OR ord-lywy.comment[3] <> "" OR ord-lywy.comment[4] <> ""
          THEN
        DO:
          DISPLAY
            ord-lywy.comment[1] ord-lywy.comment[2]
            ord-lywy.comment[3] ord-lywy.comment[4]
            WITH FRAME zz AT ROW 8 COL 1 NO-LABELS TITLE "Special Notes".
          MESSAGE "Press Return to Continue...".
          PAUSE NO-MESSAGE.
          HIDE FRAME zz NO-PAUSE.
        END.
    END.
  END.
  VIEW FRAME fr-total.
  PAUSE 0 NO-MESSAGE.
  IF a-reply THEN
  DO:
    IF t-hold AND NOT recallsuspend THEN RUN loadvhold.
    ELSE
      RUN loadvtrans.

    IF t-hold THEN
    DO:    /* recalc the hold contract based on new dates */

      DEFINE VARIABLE t-tot-due    AS DECIMAL.
      DEFINE VARIABLE t-due-amount AS DECIMAL.
      DEFINE VARIABLE t-disc       AS DECIMAL.


      FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
      FOR EACH v-trans WHERE v-trans.product-no <> "" AND NOT v-trans.void:
        v-trans.dt-rented = TODAY.
        v-trans.extended = 0.
        v-trans.dt-return = ?.
        /* number 2 */
        RUN jacaltest.p(s-dt-return, INPUT s-link-order, INPUT
          v-trans.item-no, OUTPUT t-tot-due, OUTPUT t-disc, OUTPUT t-due-amount).
        ASSIGN
          tPartialRefund = v-trans.semester * - 1
          t-disc         = v-trans.taxrate2
          t-due-amount   = v-trans.taxrate1.
        v-trans.extended = t-tot-due.
      END.
    END.

  END.
  IF AVAILABLE order AND NOT t-hold THEN t-dt-enter = order.dt-due.
  IF t-dt-enter < TODAY AND p-status <> "create" THEN
  DO:
    /* could put a second message for rto when ready to buy out */
    MESSAGE
      "THIS ORDER WAS DUE " t-dt-enter " AND IS NOW OVERDUE."
      VIEW-AS ALERT-BOX.
  END.
  IF AVAILABLE order THEN
  DO:
    FIND FIRST tsale WHERE tsale.link-order = order.link-order NO-ERROR.
    IF NOT AVAILABLE tsale THEN
    DO:
      /* might have from previous order */
      FOR EACH tsale:
        DELETE tsale.
      END.
      FOR EACH tsalei:
        DELETE tsalei.
      END.
      RUN setup-tsale.
    END.
  END.

  IF a-reply THEN RUN newwtrans.
  ELSE
  DO:
    FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
  END.
  offset = 6.
  oMsg:msg-hide().
  oMsg:msg-refresh().
  STATUS INPUT
    "Enter Serial No# / or Return to Select Model / F12 to Complete.".
  RUN reopenquery.
  /* patch when user f4's back to select another order of customer */
  FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
  /* occurs after this setup */
  RUN setupframef(NO, YES).
  WAIT-FOR F12 ,f4 OF FRAME f FOCUS e.
  oMsg:msg-hide().
  RELEASE inv-locsrl.
  /** the following delete sales created and returns inventory on
      way back out of order **/
  IF LASTKEY = keycode("f4") AND commit-sale = NO THEN
  DO TRANSACTION:
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
    RETURN ERROR.
  END.
END PROCEDURE.

/* @(#) rnproc-searchnum.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-searchnum.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE searchnum:
  DEFINE VARIABLE suspendfound AS LOG INIT NO.
  loopz: REPEAT ON ERROR UNDO loopz, LEAVE loopz
    ON ENDKEY UNDO loopz, LEAVE loopz:
    MESSAGE "Enter the Order Number You Wish To Search For.".
    ASSIGN
      s-ordnum = "".
    ENABLE s-ordnum WITH FRAME fr-ord ROW 4 COL 1.
    WAIT-FOR RETURN, f4 OF s-ordnum IN FRAME fr-ord.
    IF LASTKEY = keycode("f4") THEN
    DO:
      ASSIGN
        s-ordnum = "".
      DISABLE s-ordnum WITH FRAME fr-ord.
      HIDE FRAME fr-ord NO-PAUSE.
      RETURN ERROR.
    END.
    IF s-ordnum:screen-value BEGINS "RH" THEN
    DO:
      IF t-funct-name <> "rent.create" THEN
      DO:
        ASSIGN
          s-ordnum = "".
        DISABLE s-ordnum WITH FRAME fr-ord.
        HIDE FRAME fr-ord NO-PAUSE.
        RETURN ERROR.
      END.
    END.
    /*DISPLAY T-FUNCT-NAME format "x(14)" s-ordnum:screen-value. PAUSE 54.*/
    IF t-funct-name = "rent.create" AND (s-ordnum:screen-value
      BEGINS "rs" OR s-ordnum:screen-value BEGINS "ro" OR
      s-ordnum:screen-value BEGINS "s"
      OR s-ordnum:screen-value BEGINS "o") THEN
    DO:
      IF s-ordnum:screen-value BEGINS "rs"
        OR s-ordnum:screen-value BEGINS "s"THEN
        MESSAGE "SCHOOL CONTRACTS SHOULD NOT BE ENTERED UNDER REGULAR RENTS"
          VIEW-AS ALERT-BOX .
      ELSE
        MESSAGE "RENT TO OWN CONTRACTS SHOULD NOT BE ENTERED" SKIP
          "UNDER REGULAR RENTS" VIEW-AS ALERT-BOX .
      HIDE FRAME fr-ord NO-PAUSE.
      RETURN ERROR.
    END.
    ELSE IF t-funct-name = "rental.create" AND (s-ordnum:screen-value
        BEGINS "rn" OR s-ordnum:screen-value BEGINS "ro"
        OR s-ordnum:screen-value
        BEGINS "n" OR s-ordnum:screen-value BEGINS "o")
        THEN
      DO:
        IF s-ordnum:screen-value BEGINS "rn"
          OR s-ordnum:screen-value BEGINS "n" THEN
          MESSAGE "REGULAR CONTRACTS SHOULD NOT BE ENTERED UNDER SCHOOL RENTS"
            VIEW-AS ALERT-BOX .
        ELSE MESSAGE "RENT TO OWN CONTRACTS SHOULD NOT BE ENTERED" SKIP
            "UNDER SCHOOL RENTS" VIEW-AS ALERT-BOX .
        HIDE FRAME fr-ord NO-PAUSE.
        RETURN ERROR.
      END.
      ELSE IF t-funct-name = "r-own.create" AND (s-ordnum:screen-value
          BEGINS "rn" OR s-ordnum:screen-value BEGINS "rs"
          OR s-ordnum:screen-value
          BEGINS "n" OR s-ordnum:screen-value BEGINS "s")

          THEN
        DO:
          IF s-ordnum:screen-value BEGINS "rn"
            OR s-ordnum:screen-value BEGINS "n" THEN
            MESSAGE
              "REGULAR CONTRACTS SHOULD NOT BE ENTERED UNDER RENT TO OWN CONTRACTS"
              VIEW-AS ALERT-BOX .
          ELSE MESSAGE " SCHOOL CONTRACTS SHOULD NOT BE ENTERED" SKIP
              "UNDER RENT TO OWN CONTRACTS" VIEW-AS ALERT-BOX .
          HIDE FRAME fr-ord NO-PAUSE.
          RETURN ERROR.
        END.

    IF LENGTH(s-ordnum:screen-value) < 8 THEN
    DO:
      ASSIGN s-ordnum.
      tempnum = SUBSTRING(s-ordnum,1,2) + " " + substring(s-ordnum,3,5).
      ASSIGN
        s-ordnum = tempnum.
      DISPLAY s-ordnum WITH FRAME fr-ord.
    END.

    ASSIGN s-ordnum.   /* in case it was typed in correctly first time */
    DISABLE s-ordnum WITH FRAME fr-ord.
    FOR EACH order NO-LOCK
      WHERE order.order-no = s-ordnum AND order.sale-type = "su"
      AND order.loc-code = t-loc-code
      AND order.int-status = '':
      suspendfound = YES.
    END.
    IF suspendfound THEN
    DO:
      MESSAGE " THIS CONTRACT IS CURRENTLY UNDER SUSPENSION AND CAN ONLY BE"
        SKIP
        "RETREIVED FROM RECALL SUSPENDED SALES." VIEW-AS ALERT-BOX.
      ASSIGN
        s-ordnum = "" .
      DISPLAY s-ordnum WITH FRAME fr-ord.
      RETURN.
    END.

    DEFINE VARIABLE cnt AS INTEGER NO-UNDO.
    FOR EACH order NO-LOCK
      WHERE order.order-no = s-ordnum
      AND (order.sale-type = "rn" OR order.sale-type = "rh")
      AND order.int-status <> "picked up"
      USE-INDEX ord-type:
      FIND FIRST sale OF order NO-LOCK WHERE NOT sale.void NO-ERROR.
      IF NOT AVAILABLE sale THEN NEXT.
      IF order.sale-type = "rh" AND order.loc-code <> t-loc-code THEN NEXT.
      cnt = cnt + 1.
    END.
    IF cnt >= 1 THEN
    DO:
      RUN br-order5.p(s-ordnum, t-funct-name, OUTPUT p-orderid).
      FIND order NO-LOCK WHERE RECID(order) = p-orderid NO-ERROR.
    END.

    IF AVAILABLE order THEN
    DO:
      IF t-funct-name = "loan.create" THEN
      DO:
        FIND FIRST order-i OF order NO-LOCK WHERE order-i.dt-loan <> ?
          AND order-i.extended = 0 AND order-i.dt-return = ? NO-ERROR.
        IF NOT AVAILABLE order-i THEN
        DO:
          p-orderid = ? .
          MESSAGE
            "No Open Loan exists with that number. Try again or F4 To Exit"
            VIEW-AS ALERT-BOX.
          ASSIGN
            s-ordnum = "" .
          DISPLAY s-ordnum WITH FRAME fr-ord.
          RETURN.
        END.
        FIND FIRST order-i OF order NO-LOCK  /* an exchange in */
          WHERE order-i.dt-return <> ? AND order-i.item-type = "RE" NO-ERROR.
        IF AVAILABLE order-i THEN
        DO:
          p-orderid = ? .
          MESSAGE
            "No Open Loan exists with that number. Try again or F4 To Exit"
            VIEW-AS ALERT-BOX.
          ASSIGN
            s-ordnum = "" .
          DISPLAY s-ordnum WITH FRAME fr-ord.
          RETURN.
        END.
      END.
      p-orderid = RECID(order).
      IF order.order-no BEGINS "rh" THEN
      DO:

        IF order.invoice-comment[1] <> "" THEN
        DO:
          DEFINE VARIABLE pickreplay AS LOG INIT NO NO-UNDO.
          MESSAGE
            order.invoice-comment[1] "IS AUTHORIZED TO PICK UP THIS RENTAL."
            SKIP
            "IS" order.invoice-comment[1] "THE PERSON PICKING UP THIS RENTAL?"
            VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE pickreplay.
          IF pickreplay = ? THEN pickreplay = NO.
          IF pickreplay THEN
          DO:
            ASSIGN
              pickUpBy    = order.invoice-comment[1]
              t-hold-link = order.link-order
              t-hold      = YES.
            IF order.dt-due > TODAY THEN
              ASSIGN
                s-dt-return = order.dt-due
                t-dt-enter  = order.dt-due.
            ELSE t-dt-enter = TODAY + 1.
            RETURN.
          END.
          ELSE IF pickreplay = NO OR pickreplay = ? THEN
            DO:
              FIND customer OF order NO-LOCK NO-ERROR.
              IF AVAILABLE customer THEN
                FIND na-info OF customer NO-LOCK NO-ERROR.
              MESSAGE
                "IS " na-info.name "PICKING UP THIS RENTAL." VIEW-AS ALERT-BOX
                QUESTION BUTTONS YES-NO UPDATE pickreplay.
              IF pickreplay = ? THEN pickreplay = NO.
              IF pickreplay THEN
              DO:
                ASSIGN
                  pickUpBy    = ""   /* set as customer picks up */
                  t-hold-link = order.link-order
                  t-hold      = YES.
                IF order.dt-due > TODAY THEN
                  ASSIGN
                    s-dt-return = order.dt-due
                    t-dt-enter  = order.dt-due.
                ELSE t-dt-enter = TODAY + 1.
                RETURN.
              END.
              ELSE
              DO:
                ASSIGN
                  s-ordnum = "" .
                DISPLAY s-ordnum WITH FRAME fr-ord.
                MESSAGE "AUTHORIZED PICKUP PERSON NOR CUSTOMER ARE PRESENT." SKIP
                  "PLEASE SEE ACCOUNT SERVICES OR MANAGER FOR DIRECTION ON COMPLETING"
                  SKIP
                  "THIS RENTAL TRANSACTION." VIEW-AS ALERT-BOX.

                RETURN ERROR.     /* go no further as not cust nor assignee */
              END.
            END.      /* END OF RH SOMEONE ELSE PICKING UP */
        END.

        ASSIGN
          t-hold-link = order.link-order
          t-hold      = YES.
        IF order.dt-due > TODAY THEN
          ASSIGN
            s-dt-return = order.dt-due
            t-dt-enter  = order.dt-due.
        ELSE t-dt-enter = TODAY + 1.
        RETURN.
      END.

      IF p-auth BEGINS "write off" THEN
      DO:
        MESSAGE "NEW Contracts cannot be created for writeoff customers"
          VIEW-AS ALERT-BOX.
        RETURN ERROR.
      END.
      ELSE
      DO:
        s-link-order = order.link-order.
        FIND customer NO-LOCK WHERE customer.cust-no = order.cust-no NO-ERROR.
        IF AVAILABLE customer THEN r-cust = RECID(customer).
        RETURN.
      END.
    END.
    ELSE
    DO:
      MESSAGE "No Open Order exists with that number. Try again or F4 To Exit".
      ASSIGN
        s-ordnum = "" .
      DISPLAY s-ordnum WITH FRAME fr-ord.
    END.
  END.
END PROCEDURE.

/* @(#) rnproc-getinvrent.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getinvrent.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getinvrent:
  /*********ONLY USED BY loadvhold and loadvtrans. *************/

  DEFINE VARIABLE t-rent-rate AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-rounder   AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-days      AS INTEGER NO-UNDO.
  DEFINE VARIABLE t-serial    LIKE inv-locsrl.serial-no NO-UNDO.
  /* -- Find the appropriate monthly rate for the item to rent -- */
  FOR EACH inv-rent NO-LOCK
    WHERE inv-rent.loc-code = ""
    AND inv-rent.sku-no   = v-trans.sku-no
    AND inv-rent.dt-start <=  TODAY  /*    v-trans.dt-rented  */
    AND inv-rent.dt-end   >= v-trans.dt-rented
    BY (inv-rent.dt-end - inv-rent.dt-start):
    ASSIGN
      v-trans.billing        = inv-rent.billing
      v-trans.yearly         = inv-rent.school
      v-trans.day-30         = inv-rent.day-30
      v-trans.rent-to-own    = inv-rent.rent-to-own
      v-trans.defauld        = 0
      v-trans.pInvRentExists = YES.
    BUFFER-COPY inv-rent TO v-trans.
  END.

  IF AVAILABLE INV-MASTER THEN
  DO:
    RUN rnGetDefaultMths.p(inv-master.sku-no,
      OUTPUT v-trans.defaultMonths).
  END.
  IF AVAILABLE inv-master AND p-rent-code = "regular" THEN
  DO:
    IF AVAILABLE inv-locsrl THEN t-serial = inv-locsrl.serial-no NO-ERROR.
    ELSE t-serial = "".
    v-trans.day-30 = get-rent-rate-30(inv-master.sku-no,
      t-loc-code, t-serial).
  END.
  /* -- If no rate available for item, use default rate -- */
  IF AVAILABLE inv-master THEN
    IF NOT AVAILABLE inv-rent OR v-trans.yearly = 0
      THEN
    DO:
      DEFINE VARIABLE t-avg-cost AS DECIMAL NO-UNDO.
      IF v-trans.old-item = NO THEN
        RUN testz.p(buffer inv-master, buffer inv-locsrl, t-avg-cost,
          OUTPUT v-trans.rent-rate).

      IF v-trans.serial-no BEGINS "sku#" AND v-trans.billing = 0
        AND v-trans.yearly = 0 AND v-trans.day-30 = 0
        AND NOT p-rent-code BEGINS "re" THEN v-trans.rent-rate = 0.
    END.
  /* at moment rent-to-own rate defaults to 8 percent */

  IF p-rent-code = "rentown" AND v-trans.old-item = NO
    THEN
    v-trans.rent-rate = v-trans.rent-to-own.

END PROCEDURE.

/* @(#) rnproc-getprice.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getprice.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getprice:               /* PRICE FINDING MACRO */
  DEFINE VARIABLE t-serial-no LIKE inv-locsrl.serial-no NO-UNDO.
  DEFINE VARIABLE t-type      AS cha NO-UNDO.

  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.

  FIND v-trans NO-LOCK WHERE RECID(v-trans) = v_rec.
  /** At the time of the exchange if the new product is older than
    the rental contract then calculate the price for the new item
    at the start of the contract. if the product is newer than
    the contract then use the new price. ***/

  IF AVAILABLE inv-locsrl THEN
    t-serial-no = inv-locsrl.serial-no.

  IF v-trans.old-item = NO THEN
  DO:
    IF AVAILABLE inv-locsrl THEN
    DO:
      v-trans.avg-cost = get-current-retail(inv-locsrl.sku-no,
        inv-locsrl.serial-no).
      v-trans.before-value = v-trans.avg-cost.
      v-trans.over-retail = v-trans.avg-cost.
    END.
    ELSE
    DO:     /* NO invlocsrl */
      IF v-trans.estat = "p" THEN
        RUN im/get-price.p
          (inv-master.sku,"",YES,OUTPUT v-trans.avg-cost,OUTPUT t-type).
      ELSE
        RUN im/get-price.p
          (inv-master.sku,"",NO,OUTPUT v-trans.avg-cost,OUTPUT t-type).
    END.   /* get-price fails for sku 28 always force it */
    IF v-trans.sku-no = 28 THEN
    DO:
      IF p-rent-code = "school" THEN v-trans.avg-cost = 10.
      ELSE v-trans.avg-cost = 1.
    END.
    /****** SPECIAL INSTANCE OF RENT TO OWN *******/
    IF p-rent-code = "rentown" AND v-trans.estat <> "P" THEN
    DO:
      IF AVAILABLE inv-locsrl THEN
      DO:
        IF AVAILABLE inv-rent
          OR (inv-master.sku-no = 39 OR inv-master.sku-no = 49) THEN
        DO:
          IF AVAILABLE v-trans AND
            (v-trans.avg-cost = ? OR v-trans.avg-cost = 0)
            THEN
          DO:
            v-trans.avg-cost = 0.
          END.
          DEFINE VARIABLE t-dum-value AS DECIMAL NO-UNDO.
          t-dum-value = v-trans.avg-cost.
          v-trans.over-retail = v-trans.avg-cost.
          IF v-trans.defaultMonths = 0 THEN
            v-trans.defaultmonths = 36.
          /* rto-cost will fix above to adds to rto's */
          /* yes mean new item , no means treat as used  */
          IF AVAILABLE inv-locsrl AND inv-locsrl.doc-ref BEGINS order.order-no THEN
          DO:  /* THIS SHOULD NOW NEVER HAPPEN *****/

            RUN rto-cost(YES, OUTPUT tz-endkey, t-dum-value, t-serial-no, NO).
            RUN regularrent(OUTPUT v-trans.extended).

          END.
          ELSE IF AVAILABLE inv-locsrl THEN
            DO:   /* USED */
              RUN rto-cost(NO, OUTPUT tz-endkey, t-dum-value, t-serial-no,NO).
              RUN regularrent(OUTPUT v-trans.extended).
              IF tz-endkey = NO THEN RETURN.
            END.
            ELSE
            DO: /* NO INV-LOCSRL */
              RUN rto-cost(YES, OUTPUT tz-endkey, t-dum-value, t-serial-no,NO).
              RUN regularrent(OUTPUT v-trans.extended).
              IF tz-endkey = NO THEN RETURN.
            END.

          IF tz-endkey = NO THEN
          DO:
            RETURN.
          END.

          ELSE IF tz-endkey = YES THEN
            DO:
            /* TRAP ADDITIONAL ERRORS HERE AND RESET V-TRANS RECORD */
            END.
        END.
        ELSE
        DO:
          v-trans.avg-cost = 0.
        END.
      END.
      ELSE
      DO:  /* still RTO but no inv-locsrl */
        IF v-trans.sku-no = 28 THEN v-trans.avg-cost = 1. /*patch */
        v-trans.orig-value = v-trans.avg-cost. /* non-serialized */
      /* force accessory price here */
      END.
    END.     /**** END OF RENT TO OWN TESTS ***/

    ELSE
    DO:
      ASSIGN
        v-trans.orig-value   = v-trans.avg-cost
        v-trans.before-value = v-trans.orig-value
        v-trans.after-value  = v-trans.orig-value.
      /* block over-write of multiple passes with f8 key on create of item */
      IF v-trans.create-value = 0 THEN
        v-trans.create-value = v-trans.orig-value.
    END.
  END.

  RUN screenrefresh.  /* added jan14/2013 */

  RUN rentret (inv-master.sku-no).   /* 1st call in getprice */
END PROCEDURE.

/* @(#) rnproc-roundup.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-roundup.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE roundup:
  DEFINE INPUT-OUTPUT PARAMETER p_amount AS DECIMAL.
  DEFINE VARIABLE z AS INTEGER.
  DEFINE VARIABLE i AS INTEGER.
  z = INTEGER(p_amount + .49).
  IF z > p_amount THEN p_amount = DECIMAL(z).
END.

/* @(#) rnproc-addquantity.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-addquantity.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE addquantity:
  DEFINE INPUT-OUTPUT PARAMETER thisamt AS DECIMAL. /* amt of one item not rounded */
  DEFINE INPUT PARAMETER z-qty AS DECIMAL. /* equivalent to v-trans.qty. */

  /* add to amount 1.00 for each qty when amount has cents */
  RUN roundup(INPUT-OUTPUT thisamt).
  thisamt = thisamt * z-qty.
END.

/******* CALLED IN SIX DIFFERENT INSTANCES ******/
/* bufCopyVlocsrl calls twice
   useskuno and fromgetserial calls twice each .   */
/* @(#) rnproc-RENTRET.i 1.4 03/27/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-RENTRET.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE RENTRET:    /* RENTAL CONTRACT RETAIL PRICE CALCULATE       */
  DEFINE INPUT PARAMETER p-sku-no     LIKE inv-master.sku-no.
  DEFINE VARIABLE t-rent-rate   AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-rounder     AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-days        AS INTEGER NO-UNDO.
  DEFINE VARIABLE rentamt       AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-serial      LIKE inv-locsrl.serial-no NO-UNDO.
  DEFINE VARIABLE found-invrent AS LOG     INIT NO NO-UNDO.
  /* -- Find the appropriate monthly rate for the item to rent -- */
  
  /*16316: For Costshare customers*/
  IF tSchCostShare AND v-trans.estat = "" THEN
  DO:
    IF tAcceptPass AND v-trans.old-item = NO
      AND inv-master.serial-reqd <> "N" THEN
      v-trans.rent-rate = tSchCostShareValue.
    ELSE
      v-trans.rent-rate = 0.
    RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
      v-trans.dt-rented, OUTPUT v-trans.percent).   /* NEED THE CALC HERE */
    IF tAcceptPass AND v-trans.old-item = NO THEN
      v-trans.percent = 1.
    IF TODAY >= date(06,30,YEAR(year-end)) AND
      TODAY <= date(10,31,YEAR(year-end)) AND tyears = 1 THEN
      v-trans.percent = 1.
    ELSE IF tyears = 1 AND year-end = TODAY AND order.dt-due = TODAY THEN
        v-trans.percent = 0.
    v-trans.extended = v-trans.rent-rate * v-trans.percent.
    ASSIGN
      v-trans.orig-rentrate = v-trans.rent-rate
      v-trans.after-rate    = v-trans.rent-rate
      v-trans.before-rate   = v-trans.rent-rate.
    v-trans.retail = v-trans.extended.
    RETURN.
  END.

  /*16316:Generic SKUs NOT RTO*/
  ELSE IF (is-generic(v-trans.sku-no) OR v-trans.isGeneric = YES)
  AND NOT order.rent-code = "rentown" THEN
  DO:
    /* handle vlocsrl */
    IF order.rent-code = "school" AND old-item = NO THEN
    DO:
      RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
        v-trans.dt-rented, OUTPUT v-trans.percent).
      IF tyears = 1 AND TODAY >= date(06,30,YEAR(year-end))
        AND TODAY <= date(10,31,YEAR(year-end))
        THEN v-trans.percent = 1.
      ELSE IF tyears = 1 AND year-end = TODAY AND order.dt-due = TODAY THEN
          v-trans.percent = 0.
      ASSIGN
        v-trans.rent-rate       = .30 * v-trans.orig-value
        v-trans.extended        = v-trans.rent-rate * v-trans.qty
        v-trans.est-repair-cost = v-trans.rent-rate / 8 .
    END.
    ELSE
    DO:  /* regular rent and billing contracts.*/
      v-trans.rent-rate = v-trans.orig-value * .08.
    END.
  END.  /**** END OF GENERICS EXCEPT FOR rent to own *****/

  /*16316: For SKUs which have an inv-rent record ie prefered rental*/
  FOR EACH inv-rent NO-LOCK
    WHERE inv-rent.loc-code = ""
    AND inv-rent.sku-no   = p-sku-no
    AND inv-rent.dt-start <= TODAY   /* v-trans.dt-rented  */
    AND inv-rent.dt-end   >= v-trans.dt-rented
    BY (inv-rent.dt-end - inv-rent.dt-start):
    ASSIGN
      v-trans.billing = inv-rent.billing
      found-invrent   = YES.
    /* school contracts require an non-zero billing when yearly is non-zero*/
    IF v-trans.billing = 0 THEN
    DO:
      DEFINE VARIABLE tempamount AS DECIMAL.
      IF inv-rent.school <> 0
        THEN tempamount = inv-rent.school.
      ELSE tempamount = v-trans.orig-value * .08.
      v-trans.billing = (tempamount / 300) * 1.35 * 30.
    END.
    ASSIGN
      v-trans.yearly         = inv-rent.school
      v-trans.day-30         = inv-rent.day-30
      v-trans.rent-to-own    = inv-rent.rent-to-own
      v-trans.pInvRentExists = YES.        /* SECTION ADDED JAN14/13   */
    BUFFER-COPY inv-rent TO v-trans.            /** END OF SECTION **/
    v-trans.est-repair-cost = v-trans.billing.
    RUN rnGetDefaultMths.p(inv-master.sku-no,
      OUTPUT v-trans.defaultMonths).
    IF p-rent-code = 'BILLING' THEN rentamt = inv-rent.billing. /*BILLING = School Monthly*/
    IF p-rent-code = 'SCHOOL'  THEN rentamt = inv-rent.school. /*SCHOOL = School Yearly*/
    IF p-rent-code = ''        THEN rentamt = inv-rent.day-30. /*DEFAULT*/  
    IF p-rent-code BEGINS "RE" THEN
    DO:
      IF p-rent-code = "REGULAR" THEN
        rentamt = inv-rent.day-30.
      ELSE rentamt = v-trans.rent-rate. /* rto's already assigned */
      v-trans.rent-rate = rentamt.
      RUN roundup(INPUT-OUTPUT rentamt).
      ASSIGN
        v-trans.orig-rentrate = rentamt
        v-trans.after-rate    = rentamt
        v-trans.before-rate   = rentamt.
      RUN regularrent(OUTPUT v-trans.extended).
      RETURN.
    END.

    /* Task 2245: New Costshare Item with New Serial */

    DEFINE VARIABLE t-rentamt AS DECIMAL NO-UNDO.
    IF (p-rent-code = "School") AND v-trans.extended = 0 THEN
    DO:
      /* add monthly amounts to a school contract ONLY */

      IF v-trans.old-item = YES THEN
      DO: /* may 12*/
        /* def var t-rentamt as dec no-undo. */
        RUN rs-calcmodule.p(buffer order, v-trans.yearly, v-trans.billing,
          v-trans.semester, order.dt-created, t-dt-enter, p-rent-code,
          v-trans.item-no, OUTPUT t-rentamt).

        IF tAcceptPass AND v-trans.old-item = NO
          AND inv-master.serial-reqd <> "N" THEN
        DO:
        END.
      END.
      ELSE
      DO:
        t-rentamt = v-trans.rent-rate * v-trans.qty * tyears. /* may 12 */

        /* -- Find the appropriate monthly rate for the item to rent -- */
        /* -- (this should be the only place where inv-rent is used) -- */
        RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
          v-trans.dt-rented, OUTPUT v-trans.percent).   /* NEED THE CALC HERE */

        IF tacceptpass AND tSchCostShareValue <> 0 THEN v-trans.percent = 1.
        IF tyears = 1 AND TODAY >= date(06,30,YEAR(year-end))
          AND TODAY <= date(10,31,YEAR(year-end))
          THEN v-trans.percent = 1.
        ELSE IF tyears = 1 AND year-end = TODAY AND order.dt-due = TODAY THEN
            v-trans.percent = 0.
          ELSE IF tyears = 2 AND TODAY >= date(06,30,YEAR(year-end))
              AND TODAY <= date(10,31,YEAR(year-end))
              THEN v-trans.percent = 2.

        /* rentamt = rentamt * v-trans.percent.  April 27-2015 add of item */
        /* Fix/Patch for "Charges double for newly added Contracts on Existing
          RS eg. check Task#2236 email" */
        /* if year-end > order.dt-due */
        IF year-end > order.dt-due AND v-trans.old-item
          THEN v-trans.percent = v-trans.percent + 1. /* may 12 */
        /* Task 2197: Assign Cost Share value instead
                  of default value for Cost share schools */
        IF tAcceptPass AND v-trans.old-item = NO
          AND inv-master.serial-reqd <> "N" THEN
          ASSIGN
            rentamt   = tSchCostShareValue
            t-rentamt = tSchCostShareValue.
      END.
    END.

    /* FROM new items already have extended filled in */
    IF v-trans.extended = 0 OR V-TRANS.sku-no = 28 OR v-trans.old-item = NO
      THEN
    DO:
      IF v-trans.old-item = NO AND v-trans.estat = ""
        THEN v-trans.extended = 0.  /* patch  may 12 */
      IF v-trans.est-repair-cost = 0 THEN  /* June 01-2015*/
        v-trans.est-repair-cost = v-trans.billing.
      IF v-trans.sku-no <> 28 THEN
      DO: /* patch june26-16 */
        IF v-trans.est-repair-cost <> 0
          AND MONTH(TODAY) = 6 AND NOT tschcostshare THEN
        DO:
          IF v-trans.rent-rate <> 0 THEN
            v-trans.percent = v-trans.est-repair-cost / v-trans.rent-rate.
          ELSE IF rentamt <> 0 THEN
              v-trans.percent = v-trans.est-repair-cost / rentamt.

          /* temp till sept 2016*/
          IF tyears = 1 AND TODAY >= date(06,30,YEAR(year-end))
            AND TODAY <= date(10,31,YEAR(year-end))
            THEN v-trans.percent = 1.
          ELSE IF tyears = 1 AND year-end = TODAY
              AND order.dt-due = TODAY THEN
              v-trans.percent = 0.
        END.
      END.

      IF order.rent-code = "billing" THEN v-trans.percent = 1.
      ASSIGN
        v-trans.rent-rate     = rentamt
        v-trans.orig-rentrate = rentamt
        v-trans.after-rate    = v-trans.rent-rate
        v-trans.before-rate   = v-trans.rent-rate
        v-trans.extended      = IF t-rentamt <> 0 THEN
          t-rentamt * v-trans.percent
        ELSE rentamt * v-trans.percent * v-trans.qty
        v-trans.retail        = v-trans.extended.
      /*   /* 10639 - This will change the due date for monthly rentals */
         RUN rn-getyearend.p(order.rent-code, today, output p-newdate).	
         FIND CURRENT b-order EXCLUSIVE-LOCK NO-ERROR.
         b-order.dt-due = p-newdate. */
		
      /* additional amount if more than one year */

      IF tYears > 1 THEN
      DO:
        IF v-trans.old-item THEN
        DO: /* may 12*/
          v-trans.extended = v-trans.extended
            + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 )).
          v-trans.retail = v-trans.extended.
        END.
        ELSE
        DO:
          IF TODAY > date(06,30,YEAR(year-end))
            AND TODAY <= date(10,31,YEAR(year-end)) AND
            tyears = 2 AND v-trans.old-item = NO THEN
            v-trans.extended = v-trans.rent-rate * v-trans.qty * tYears.
          ELSE
            v-trans.extended =  /* new item add remainder of year plus 1*/
              v-trans.rent-rate * v-trans.qty * v-trans.percent +
              ((v-trans.rent-rate * v-trans.qty) * (tYears - 1)).
        END.
      END.
      ELSE
      DO:   /* new item one year MAY 12 */
        IF order.rent-code = "billing" THEN
        DO:
          IF t-date-due = ? THEN t-date-due = order.dt-due.
          RUN effectdays.p(TODAY, t-date-due, OUTPUT t-days).
          ASSIGN
            v-trans.extended = v-trans.rent-rate / 30 * t-days
            v-trans.extended = v-trans.extended * v-trans.qty
            v-trans.extended = ROUND(v-trans.extended,2)
            v-trans.retail   = v-trans.extended.
        END.
        ELSE
        DO:
          v-trans.extended = v-trans.extended
            + ((v-trans.rent-rate * v-trans.qty)
            * (tYears - 1 )).
          v-trans.retail = v-trans.extended.
        END.
      END.
      IF NOT is_exch AND v-trans.rent-rate <> 0
        THEN s-extend = s-extend + v-trans.extended.
      IF v-trans.rent-rate <> 0 THEN
      DO:
        RETURN. /* otherwise fix rent-rate. */
      END.
    END.
    /* just overwrite everything if inv-rent exists and not Band item */
    FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
    IF AVAILABLE inv-master AND inv-master.dept <> "B" THEN
    DO:
      v-trans.billing = inv-rent.day-30.
      v-trans.est-repair-cost = v-trans.billing.
      v-trans.yearly  = inv-rent.day-30 * 8. /*confirmed email from Mklue.*/
    END.
  END.     /* END OF FOR EACH INV-RENT    ********/

   /*16316: For SKUs which do NOT have an inv-rent record*/
  /* WHEN NO INV-RENT EXISTS THEN  available for item, use default rate */
  IF v-trans.rent-rate = ? THEN v-trans.rent-rate = 0.
  IF NOT found-invrent OR v-trans.rent-rate = 0 THEN
  DO:
    /*16316: Regular rents with NO inv-rent*/
    IF p-rent-code = "regular" AND AVAILABLE inv-master THEN
    DO:
      IF is-generic(v-trans.sku-no) THEN     /* jan20/2015 */
        v-trans.rent-rate = v-trans.orig-value * .08.
      ELSE
      DO:
        IF NOT v-trans.serial-no BEGINS "SKU#" THEN
          t-serial = v-trans.serial-no.
        ELSE t-serial = "".
        rentamt = get-rent-rate-30(inv-master.sku-no,
          t-loc-code, t-serial).
        v-trans.rent-rate = rentamt.
      END.
    END.
    
    FIND syscust NO-LOCK WHERE syscust.type = "RN" NO-ERROR.
    
    /***  let school become same as regular rents for sku# **/
    IF (p-rent-code = "School" OR p-rent-code = "BILLING")
      AND v-trans.rent-rate = 0 THEN
    DO:
      /*Not allocated yet?*/
      IF v-trans.serial-no BEGINS "sku#"
        AND v-trans.yearly = 0
        AND v-trans.day-30 = 0 THEN v-trans.rent-rate = 0.
      
      /*16316: School Year with NO inv-rent*/
      ELSE IF p-rent-code = "school" THEN
      DO:
        v-trans.rent-rate = .30 * v-trans.orig-value.
        IF tSchCostShare AND tSchCostShareValue <> 0 THEN
          v-trans.rent-rate = tSchCostShareValue.
        /* gets skipped if no inv-rent exists. */
        RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
          v-trans.dt-rented, OUTPUT v-trans.percent). /* NEED THE CALC HERE */

        IF tacceptpass AND tSchCostShareValue <> 0 THEN v-trans.percent = 1.
        IF tyears = 1 AND TODAY >= date(06,30,YEAR(year-end))
          AND TODAY <= date(10,31,YEAR(year-end))
          THEN v-trans.percent = 1.
        ELSE IF tyears = 1 AND year-end = TODAY
            AND order.dt-due = TODAY THEN
            v-trans.percent = 0.
      END.
      
      /*16316: School Monthly with NO inv-rent*/
      ELSE IF p-rent-code = "BILLING" THEN 
        ASSIGN
          v-trans.rent-rate = .08 * v-trans.orig-value
          /*13528: Monthly contracts need these initializations, else ? is appearing
                   Not sure when this broke, or what broke this. If known
                   could have changed code at the broken spot. For now setting these
                   here seems to work when new monthly contract is created with items
                   NOT having rent rate*/
          t-date-due = IF t-date-due = ? THEN order.dt-due ELSE t-date-due
          v-trans.percent = 1
          .
        v-trans.extended = v-trans.rent-rate * v-trans.qty.
    END. /*IF (p-rent-code = "School" OR p-rent-code = "BILLING") AND v-trans.rent-rate = 0*/
    
    ELSE IF AVAILABLE syscust THEN
    DO:
      IF p-rent-code BEGINS "RE" THEN
      DO:  /* oct 25/99 covers PC-10 */
        RUN roundup(INPUT-OUTPUT v-trans.rent-rate).
        v-trans.orig-rentrate = rentamt.
        v-trans.after-rate = v-trans.rent-rate.
        v-trans.before-rate = v-trans.rent-rate.
        RUN regularrent(OUTPUT v-trans.extended).
        /*run chkEmplDisc. may-04*/
        RETURN.
      END.
      IF v-trans.rent-rate = ? THEN
      DO:
        MESSAGE "SYS-CUST FLAG[3] HAS NOT BEEN SET".
        MESSAGE "DOUBLE CHECK THE RENT RATE FOR THIS ITEM".
        PAUSE 5 NO-MESSAGE.
        /* determine rent-rate for billing if yearly rate available. */
        IF p-rent-code = "BILLING" THEN
          IF v-trans.yearly <> 0
            THEN v-trans.rent-rate = (v-trans.yearly / 300 ) * 1.35 * 30.
          ELSE v-trans.rent-rate = (syscust.dec-flag[1] / 100)
              * v-trans.orig-value.
        ASSIGN
          v-trans.rent-rate = t-rounder * syscust.dec-flag[3]
          v-trans.extended  = v-trans.rent-rate
          * v-trans.percent * v-trans.qty.
        v-trans.orig-rentrate = rentamt.
        v-trans.before-rate = v-trans.rent-rate.
        v-trans.after-rate = v-trans.rent-rate.
        IF tYears > 1 THEN
        DO:
          v-trans.extended = v-trans.extended
            + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 )).
          v-trans.retail = v-trans.extended.
        END.
      END.
    END. /*ELSE IF AVAILABLE syscust THEN*/
  END.   /* override all prev attempts to calc if rent-rate = 0 */
  
  IF v-trans.orig-value = 0 THEN
  DO:
    PAUSE 0 NO-MESSAGE.    /* since we stopped here we should display */
    RUN screenrefresh.
    IF v-trans.estat = "P" THEN
      RETURN. /* we will retry elsewhere */
    IF v-trans.item-status = "BUY" OR v-trans.estat = "P"
      THEN MESSAGE "Change This Amount to Match the Buy Amount You Want.".
    ELSE IF v-trans.orig-value = 0
        THEN
        IF NOT p-status BEGINS "re" THEN
          MESSAGE "Item must have a Net Value applied. Enter a Value.".
        ELSE
          MESSAGE "Item(s) must have a Total Value applied. Enter a Value.".

      ELSE MESSAGE "Change The Original Value Amount Recorded on Contract".
    PAUSE 0 NO-MESSAGE.

    IF v-trans.old-item = NO THEN
    DO:
      v-trans.create-value = v-trans.orig-value.
      v-trans.before-value = v-trans.create-value.
      v-trans.after-value = v-trans.create-value.
    END.
    ENABLE v-trans.orig-value WITH FRAME jkus OVERLAY
      NO-BOX NO-LABELS ROW bl-row + offset COL 45.
    APPLY "entry" TO v-trans.orig-value IN FRAME jkus.
    WAIT-FOR RETURN OF v-trans.orig-value IN FRAME jkus.
    HIDE MESSAGE NO-PAUSE.
    ASSIGN v-trans.orig-value.
    v-trans.after-value = v-trans.orig-value.
    DISABLE v-trans.orig-value WITH FRAME jkus.
    HIDE FRAME jkus NO-PAUSE.
  END.
  IF NOT p-rent-code BEGINS "RE" THEN
  DO:     /* dont handle regulars here */
    IF v-trans.rent-rate = 0 THEN
    DO:
      IF v-trans.day-30 = 0
        AND NOT v-trans.serial-no BEGINS "sku#" THEN
        v-trans.rent-rate = v-trans.orig-value * (syscust.dec-flag[1] / 100).

      v-trans.orig-rentrate = v-trans.rent-rate.
      v-trans.before-rate = v-trans.rent-rate.
      v-trans.after-rate = v-trans.rent-rate.
      /* no message on rent-rate set to no */
      IF v-trans.estat <> "P" AND v-trans.rent-rate <> 0 THEN
      DO:
        IF v-trans.rent-rate <> 0 THEN
          rentratemessage = YES.
        v-trans.percent = 1.
        v-trans.extended = v-trans.rent-rate
          * v-trans.percent * v-trans.qty.
        v-trans.retail = v-trans.extended.
        IF tYears > 1 THEN
        DO:
          v-trans.extended = v-trans.extended
            + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 )).
          v-trans.retail = v-trans.extended.
        END.
        RETURN.     /* this ret prevents next two lines from executing */
      END.
    END.
  END.

  v-trans.extended = v-trans.rent-rate
    * v-trans.percent * v-trans.qty.
  v-trans.retail = v-trans.extended.
  IF tYears > 1 THEN
  DO:
    v-trans.extended = v-trans.extended
      + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 )).
    v-trans.retail = v-trans.extended.
  END.
END.

/* @(#) rnproc-fixpaid.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-fixpaid.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE fixpaid:
  DEFINE VARIABLE jm AS INTEGER NO-UNDO.
  /* def var klm as int. */
  DEFINE VARIABLE x  AS INTEGER.

  DO x = 1 TO cust-browse:down IN FRAME brws-frame.
    IF cust-browse:is-row-selected(x) THEN LEAVE.
  END.
  rwpos = x.


  IF RECID(v-trans) = v_rec THEN
  DO:
    MESSAGE "There is nothing to fix on this blank line." VIEW-AS ALERT-BOX.
    RETURN.
  END.
  IF v-trans.estat <> "" THEN
  DO:
    MESSAGE "You must first undo any return, exchange or purchase on this item
before fixing this field." VIEW-AS ALERT-BOX.
    RETURN.
  END.
  proc-block: DO ON ERROR UNDO proc-block, LEAVE proc-block
    ON ENDKEY UNDO proc-block, LEAVE proc-block:
    PAUSE 0 NO-MESSAGE.
    v-trans.finalextend = v-trans.extended.
    DISPLAY v-trans.extended WITH FRAME ayu.
    ENABLE v-trans.extended WITH FRAME ayu OVERLAY
      NO-BOX NO-LABELS ROW rwpos + offset + 1 /* bl-row + offset - 1 */ COL 68.
    APPLY "entry" TO v-trans.extended  IN FRAME ayu.
    WAIT-FOR RETURN, f4 OF FRAME ayu.  /* changes meaning of f4 to GO */
    HIDE FRAME ayu NO-PAUSE.
    HIDE MESSAGE NO-PAUSE.
    IF LASTKEY <> keycode("f4") THEN
    DO:
      ASSIGN v-trans.extended
        v-trans.finalextend = v-trans.extended - v-trans.finalextend.
      v-trans.retail = v-trans.extended.   /* must assign */
      RUN correcttotal.
      status-ok = cust-browse:refresh() IN FRAME brws-frame.
      /* cust-browse:hidden = false.  */
      PAUSE 0 NO-MESSAGE.
      IF v-trans.extended = ? THEN RETURN ERROR.
    END.
    ELSE v-trans.finalextend = 0.
  END.
END.

/* @(#) rnproc-paidoff.i 1.7 03/06/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-paidoff.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE paidoff:
  DEFINE VARIABLE jm           AS INTEGER NO-UNDO.
  /* def var klm as int. */
  DEFINE VARIABLE t-orig-value AS DECIMAL NO-UNDO.
  DEFINE VARIABLE x            AS INTEGER.
  DEFINE VARIABLE new-qty      AS INTEGER INIT 0 VIEW-AS FILL-IN SIZE 5 BY 1.
  DEFINE VARIABLE x-qty        AS INTEGER INIT 0 VIEW-AS FILL-IN SIZE 5 BY 1.
  DO x = 1 TO cust-browse:down IN FRAME brws-frame.
    IF cust-browse:is-row-selected(x) THEN LEAVE.
  END.
  rwpos = x.
  HIDE MESSAGE NO-PAUSE.

  IF v-trans.sku-no = 0351993 OR v-trans.sku-no = 0422888 THEN RETURN.
  proc-block: DO ON ERROR UNDO proc-block, LEAVE proc-block
    ON ENDKEY UNDO proc-block, LEAVE proc-block:
    IF v-trans.estat = "P" THEN   /* make it a buy instead of a rental */
      ASSIGN v-trans.amt-received = v-trans.extended
        v-trans.extended     = v-trans.qty * v-trans.orig-value.
    ELSE  IF NOT p-rent-code BEGINS "RE" THEN
        v-trans.extended = v-trans.qty * v-trans.rent-rate * v-trans.percent.
    IF SUBSTRING(v-trans.serial-no,1,4) = "SKU#" AND
      v-trans.serial-no <> "SKU# 0000040" THEN
    DO:

      PAUSE 0 NO-MESSAGE.
      loopxA: DO ON ERROR UNDO loopxA, LEAVE loopxA
        ON ENDKEY UNDO loopxA, LEAVE loopxA:
        RUN screenrefresh.
        PAUSE 0 NO-MESSAGE.
        FIND inv-master NO-LOCK
          WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
        IF AVAILABLE inv-master AND v-trans.estat = "p"
          AND (inv-master.serial-reqd = "r"
          OR neverUsed(inv-master.sku-no) = YES) THEN
        DO:
          RUN rn-qtynew.p(INPUT-OUTPUT x-qty,
            bl-row, offset, OUTPUT t-endkey).
          v-trans.qty-new = x-qty.
          IF LASTKEY = keycode("f4") OR t-endkey THEN
          DO:
          END.
          IF x-qty > 0 THEN v-trans.qty = x-qty.
          v-trans.extended = v-trans.orig-value * v-trans.qty.
        END.
        ELSE IF v-trans.sku-no = 28
            AND t-funct-name = "rental.create" THEN
          DO:
            IF v-trans.orig-value = 0 THEN v-trans.orig-value = 10.
            v-trans.avg-cost = v-trans.orig-value.
            IF v-trans.extended = ? THEN v-trans.extended = 10.
            IF v-trans.percent = ? THEN v-trans.percent = 1.
            RUN rsSchoolProrate.p("school", v-trans.sku-no,
              v-trans.dt-rented, OUTPUT v-trans.percent).
            IF tschCostShareValue > 0 AND tschCostShare THEN
              v-trans.percent = 1.
            IF tyears = 1 AND TODAY >= date(06,30,YEAR(year-end))
              AND TODAY <= date(10,31,YEAR(year-end))
              THEN v-trans.percent = 1.

            ELSE IF tyears = 1 AND year-end = TODAY
                AND order.dt-due = TODAY THEN
                v-trans.percent = 0.
            RUN rn-qty.p(INPUT-OUTPUT x-qty,
              INPUT-OUTPUT v-trans.qty-new,
              bl-row, offset, OUTPUT t-endkey).
            IF x-qty > 0 THEN v-trans.qty = x-qty.
            IF LASTKEY = keycode("f4") OR t-endkey THEN
            DO:
            END.
          END.
          ELSE
          DO:
            IF v-trans.sku-no <> 28 AND v-trans.sku-no <> 61 THEN
            DO:
              RUN rn-qty.p(INPUT-OUTPUT x-qty,
                INPUT-OUTPUT v-trans.qty-new,
                bl-row, offset, OUTPUT t-endkey).
              IF x-qty > 0 THEN v-trans.qty = x-qty.
              IF LASTKEY = keycode("f4") OR t-endkey THEN
              DO:
                DELETE v-trans. /* if its the first line then re-create blank*/
                PAUSE 0 NO-MESSAGE.
                /* delete this line does not crash screen */
                RETURN.
              END.
            END.
            IF LASTKEY <> keycode("f4") THEN PAUSE 0 NO-MESSAGE.
          END.  /* of v-trans.estat = "p" */
        IF v-trans.description = "" THEN
        DO:
          FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no
            NO-ERROR.
          IF AVAILABLE inv-master THEN
            v-trans.description = inv-master.description.
        END.
        IF p-rent-code BEGINS "re" THEN
        DO:     /* oct 29/99 */
          v-trans.avg-cost = v-trans.orig-value.
          IF v-trans.estat <> "p" THEN
            RUN regularrent(OUTPUT v-trans.extended).
        END.
      END.

      FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
      DO:
        /* but also need for school as well */
        IF (v-trans.orig-value = 0  /* allow entry into orig value field */
          AND v-trans.estat = "" ) OR v-trans.estat = "P" THEN
        DO:
          IF v-trans.sku-no = 28 THEN
          DO:
            DEFINE VARIABLE t-28 AS DECIMAL.
            IF p-rent-code = "school" THEN t-28 = 10.
            IF p-rent-code = "billing" THEN t-28 = 1.
            ASSIGN
              v-trans.orig-value  = t-28
              v-trans.sorig-value = orig-value
              v-trans.avg-cost    = v-trans.sorig-value
              v-trans.after-value = v-trans.orig-value.
            v-trans.rent-rate = t-28.
          END.
          ELSE
          loopv: DO ON ERROR UNDO loopv, LEAVE loopv
            ON ENDKEY UNDO loopv, LEAVE loopv:
            IF v-trans.orig-value = ? THEN v-trans.orig-value = 0.
            t-orig-value = v-trans.orig-value.
            DISPLAY v-trans.orig-value WITH FRAME jvu OVERLAY.
            ENABLE v-trans.orig-value WITH FRAME jvu OVERLAY
              NO-BOX NO-LABELS ROW bl-row + offset COL 45.
            APPLY "entry" TO v-trans.orig-value IN FRAME jvu.
            WAIT-FOR RETURN OF v-trans.orig-value IN FRAME jvu.
            HIDE MESSAGE NO-PAUSE.

            /**** prevent entering a ? in the orig-value field*/
            IF v-trans.orig-value:screen-value = ?
              OR v-trans.orig-value:screen-value = "?" THEN
            DO:
              v-trans.orig-value:screen-value = STRING(v-trans.orig-value).
              DISPLAY v-trans.orig-value WITH FRAME jvu OVERLAY.
            END.
            IF (v-trans.estat = "p" AND inv-master.serial-reqd = "r")
              OR (v-trans.qty-new <> 0 AND v-trans.serial-no BEGINS "sku#")
              THEN
            DO:
              IF dec(v-trans.orig-value:screen-value) <> t-orig-value THEN
              DO:
                DEFINE VARIABLE px-endkey AS LOG NO-UNDO.
                IF inv-master.serial-reqd = "r" AND v-trans.qty-new = 0 THEN
                  v-trans.qty-new = 1.
                RUN rn-disc(OUTPUT px-endkey).
                IF px-endkey  THEN
                DO:
                  ASSIGN
                    v-trans.orig-value:screen-value = STRING(t-orig-value).
                  PAUSE 0 NO-MESSAGE.
                END.
              END.
            END.
            ASSIGN v-trans.orig-value.
            DISABLE v-trans.orig-value WITH FRAME jvu.
            ASSIGN v-trans.orig-value
              v-trans.sorig-value = orig-value
              v-trans.avg-cost    = v-trans.sorig-value
              v-trans.after-value = v-trans.orig-value.
            /* patch for cartage */
            IF v-trans.estat = "p" AND v-trans.sku-no = 61 THEN
            DO:
              v-trans.extended = v-trans.orig-value * v-trans.qty.
            END.
            IF v-trans.estat = "p" AND inv-master.serial-reqd = "r" THEN.
            ELSE
            DO:
              IF v-trans.rent-rate = ? THEN v-trans.rent-rate = 0.
              DISPLAY v-trans.rent-rate WITH FRAME ljku OVERLAY.
              ENABLE v-trans.rent-rate WITH FRAME ljku OVERLAY
                NO-BOX NO-LABELS ROW bl-row + offset  COL 57.
              APPLY "entry" TO v-trans.rent-rate IN FRAME ljku.
              WAIT-FOR RETURN OF v-trans.rent-rate IN FRAME ljku.
              DISABLE v-trans.rent-rate WITH FRAME ljku.
              IF v-trans.rent-rate:screen-value = ?
                OR v-trans.rent-rate:screen-value = "?" THEN
              DO:
                v-trans.rent-rate:screen-value = STRING(v-trans.rent-rate).
                DISPLAY v-trans.rent-rate WITH FRAME ljku OVERLAY.
              END.
              ASSIGN
                v-trans.rent-rate = ROUND(dec(v-trans.rent-rate:screen-value),0).
              v-trans.after-rate = v-trans.rent-rate.
            END.
            HIDE FRAME ajku NO-PAUSE.
            HIDE FRAME pyu NO-PAUSE.
            HIDE FRAME ljku NO-PAUSE.
            HIDE FRAME jvu NO-PAUSE.
            IF v-trans.sku-no <> 61 THEN
              RUN regularrent(OUTPUT v-trans.extended).
            /* above gets all the calcs in case purchase below is undone */
            IF v-trans.estat = "p" THEN
            DO:
              v-trans.extended = v-trans.orig-value * v-trans.qty.
            END.
            HIDE FRAME jvu NO-PAUSE.
            t-total = t-total - v-trans.extended.
            DISPLAY t-total WITH FRAME fr-total2.
            RETURN. /* no point to entering the paid field. */
          END.  /* end of handling sku22 types in regular rents */
        END.
      END.
      HIDE FRAME ajku NO-PAUSE.
      HIDE FRAME pyu NO-PAUSE.
      
      
      /* Display any existing Rental Notes for NON-Serialized products */
      IF AVAILABLE inv-master THEN DO:
        t-rental-notes = GetInvNotes(inv-master.sku-no, "rentals").
    
        IF t-rental-notes <> "" THEN
          MESSAGE t-rental-notes VIEW-AS ALERT-BOX INFORMATION.
      END.
      
      t-total = t-total - v-trans.extended.
      DISPLAY t-total WITH FRAME fr-total2.
      IF v-trans.estat = "P" THEN
      DO:
        /* IDEALLY WE SHOULD APPLY F8 TRIGGER INSTEAD OF RECOPY */
        IF v-trans.orig-value = 0 THEN
        DO:
          loopx: DO ON ERROR UNDO loopx, LEAVE loopx
            ON ENDKEY UNDO loopx, LEAVE loopx:
            DISPLAY v-trans.orig-value WITH FRAME jku OVERLAY.
            ENABLE v-trans.orig-value WITH FRAME jku OVERLAY
              NO-BOX NO-LABELS ROW bl-row + offset COL 45.
            APPLY "entry" TO v-trans.orig-value IN FRAME jku.
            IF v-trans.item-status = "BUY" OR v-trans.estat = "P" THEN
              MESSAGE "Change This Amount to Match the (unit) Buy Amount.".

            WAIT-FOR RETURN OF v-trans.orig-value IN FRAME jku.
            HIDE MESSAGE NO-PAUSE.
            ASSIGN v-trans.orig-value.
            DISABLE v-trans.orig-value WITH FRAME jku.
            ASSIGN v-trans.orig-value
              v-trans.sorig-value = orig-value
              v-trans.extended    = v-trans.orig-value * v-trans.qty.
            v-trans.after-value = v-trans.orig-value.
            /* hide frame pyu no-pause. */
            HIDE FRAME jku NO-PAUSE.
            RETURN. /* no point to entering the paid field. */
          END.
        END.
        v-trans.extended = v-trans.qty *  v-trans.orig-value.
      END.
      ELSE IF NOT p-rent-code BEGINS "RE" THEN
          v-trans.extended = v-trans.qty * v-trans.rent-rate.
      RUN screenrefresh.
      IF LASTKEY = keycode("f4") OR LASTKEY = KEYCODE("endkey") THEN
      DO:

        PAUSE 0 NO-MESSAGE.

        MESSAGE "Please Complete This Line First. Then Use F4 to Back Out".
        PAUSE 201 NO-MESSAGE .
      END.
    END.
    /* SHOULD HANDLE F4 OFF EXTENSION FROM HERE */
    PAUSE 0 NO-MESSAGE.
    IF NOT p-rent-code BEGINS "re" THEN
      RUN getprice.
  END.
END.

/* @(#) rnproc-correcttotal.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-correcttotal.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE correcttotal:
  DEFINE VARIABLE holdrec AS RECID NO-UNDO.
  holdrec = RECID(v-trans).
  DEFINE VARIABLE isOneOnly AS INTEGER NO-UNDO.
  t-total = 0.
  t-tot2 = 0.
  t-month = 0.
  FOR EACH v-trans WHERE v-trans.item-type <> "RR"  AND
    v-trans.item-type <> "RE" AND NOT v-trans.void:
    t-total = t-total + v-trans.extended.
    IF v-trans.sku-no <> 28 THEN
    DO: /* dont divide by protection */
      IF v-trans.estat = "P" OR v-trans.estat = "B" THEN NEXT.
      IF NOT v-trans.serial-no BEGINS "sku#"  THEN
        isOneOnly = isOneOnly + 1.
      t-month = t-month + v-trans.rent-rate * v-trans.qty.
      IF v-trans.estat <> "O" THEN
      DO:
        t-tot2 = t-tot2 + v-trans.orig-value * v-trans.qty.
      END.
    END.
  /* each time a new item is totaled we set its status in inventory */
  END.
  IF holdrec <> ? THEN
    FIND v-trans WHERE RECID(v-trans) = holdrec.
END.

/* @(#) rnproc-displayTotal.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-displayTotal.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE displayTotal:
  DISPLAY t-tot2 t-length t-total WITH FRAME fr-total2  ROW 15 COL 46.
END.

/* @(#) rnproc-totdeposits.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-totdeposits.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE totdeposits:
  RUN rn-deposit.p(buffer order, OUTPUT t-deposit).
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
END.

/* @(#) rnproc-cal_renttots.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-cal_renttots.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE cal_renttots:
  RUN totdeposits. /* get total deposits */
  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.

  s-co-complete = YES.
  FOR EACH v-trans WHERE RECID(v-trans) <> v_rec AND v-trans.item-no <> 903
    AND NOT v-trans.void AND v-trans.item-no <> 905:
    IF v-trans.estat = "" OR v-trans.estat = "E" OR v-trans.estat = "L"
      OR v-trans.estat = "C" /* school f8 key in May */
      THEN s-co-complete = NO. /* order not closed */
  END.
  RUN credit_deposit.
END.

/* @(#) rnproc-undoexch.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-undoexch.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE undoexch:
  DEFINE VARIABLE olditemno   AS INTEGER.
  DEFINE VARIABLE t-oldamount AS DECIMAL NO-UNDO.
  olditemno = v-trans.link-rent.

  IF recallsuspend THEN
    t-oldamount = v-trans.extended.
  DELETE v-trans.
  FIND v-trans WHERE v-trans.item-no = olditemno NO-ERROR.
  ASSIGN
    v-trans.item-type = "RI"  /* next set old item back out on rent */
    v-trans.estat     = "". /* oct 13/99 */

  IF recallsuspend THEN
    v-trans.extended = t-oldamount.
  ELSE
    v-trans.extended = v-trans.origextend.         /* re-instate old amount */
  IF order.order-no BEGINS "ro" THEN
  DO:
    ASSIGN
      t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
      /*t-rto-tot = v-trans.orig-value*/
      t-rto-mth = v-trans.orig-value / v-trans.rent-rate.
  END.
END.

/* @(#) rnproc-rentexch.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-rentexch.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE rentexch:
  DEFINE VARIABLE t-valid    AS LOG   INIT YES NO-UNDO.  /* assume valid*/
  DEFINE VARIABLE nrec       AS RECID NO-UNDO.
  DEFINE VARIABLE p-rentrate LIKE order-i.rent-rate NO-UNDO.
  nrec = RECID(v-trans).

  HIDE FRAME fr-descrip NO-PAUSE.
  IF order.rent-code = "School" THEN
    RUN rnSchoolExch.p(exchrec, newexchrec,
      tSchCostShare, tSchCostShareValue,OUTPUT t-valid).
  ELSE
    RUN rn-exchange.p(exchrec, newexchrec, OUTPUT t-valid). /* new */
  IF t-valid AND order.order-no BEGINS "ro" THEN
  DO:
    ASSIGN
      t-rto-tot = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
      /*t-rto-tot = v-trans.orig-value*/
      t-rto-mth = v-trans.orig-value / v-trans.rent-rate.
  END.
  VIEW FRAME fr-descrip.
  IF NOT t-valid THEN
  DO:
    FIND b-trans WHERE RECID(b-trans) = exchrec NO-ERROR.
    ASSIGN
      b-trans.item-type = "RI"  /* next set old item back out on rent */
      b-trans.estat     = ""
      s-rec             = ?
      recm              = ?.    /* JAN16/13 set to re-use */
    PAUSE 0 NO-MESSAGE.  /* should clear an f4 condition */
    FIND v-trans WHERE RECID(v-trans) = nrec NO-ERROR.
    IF AVAILABLE v-trans THEN
    DO:
      FIND vlocsrl WHERE vlocsrl.serial-no = v-trans.serial-no
        AND vlocsrl.sku-no = v-trans.sku-no NO-ERROR.
      IF AVAILABLE vlocsrl THEN DELETE vlocsrl.
      DELETE v-trans.
    END.
    IF AVAILABLE inv-locsrl THEN RELEASE inv-locsrl.
    IF order.rent-code <> "p-rent-code" THEN RELEASE inv-master.
  END.
  RUN newwtrans.
  is_exch = NO.
END.

/* @(#) rnproc-undoreturn.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-undoreturn.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE undoreturn:
  DEFINE BUFFER b-trans FOR v-trans.

  IF v-trans.serial-no BEGINS string("SKU#") THEN
  DO:
    IF v-trans.link-rent = v-trans.item-no THEN
      v-trans.estat = "".
    ELSE
    DO:
      FIND b-trans WHERE b-trans.item-no = v-trans.link-rent
        AND b-trans.sku-no = v-trans.sku-no NO-ERROR.
      IF AVAILABLE b-trans THEN
      DO:
        b-trans.qty = b-trans.qty + v-trans.qty.
        b-trans.disc-amt = b-trans.disc-amt + v-trans.disc-amt.
        b-trans.extended = b-trans.origextend + v-trans.origextend.
        b-trans.rntrefund = 0.  /* patch july24 */
        b-trans.retail = 0.
        IF b-trans.estat = "B" THEN
        DO:
          /*undo a buyout if occurs after a partial return mar2015*/
          ASSIGN
            b-trans.estat     = ""
            b-trans.rent-owed = 0.
        END.
        DELETE v-trans.
        FIND v-trans WHERE v-trans.item-no = b-trans.item-no.
        FIND order-i OF order NO-LOCK
          WHERE order-i.item-no = v-trans.item-no NO-ERROR.
        IF AVAILABLE order-i THEN v-trans.origextend = order-i.extended.
      END.
      RUN reopenquery.
      DISPLAY e WITH FRAME f.
      APPLY "entry" TO e IN FRAME f.
    END.
  END.
  ELSE
  DO :
  END.
  ASSIGN
    v-trans.extended    = v-trans.origextend
    v-trans.item-status = IF v-trans.item-status = 'LRETURN' THEN 'LOAN'
                         ELSE  ''
    v-trans.estat       = ""
    v-trans.item-type   = 'RI'
    v-trans.rntrefund   = 0
    v-trans.retail      = 0
    v-trans.finalextend = 0.
  RUN correcttotal.
  /* on protection after suspend it resets to zero; aug 2015 */
  IF p-rent-code = "school" THEN
    v-trans.amt-received = v-trans.origextend.
END.

/* @(#) rnproc-partialreturn.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-partialreturn.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE partialreturn:
  DEFINE INPUT PARAMETER skyqty AS INTEGER.
  DEFINE BUFFER b-trans FOR v-trans.
  DEFINE VARIABLE corig    AS DECIMAL.
  DEFINE VARIABLE cextend  AS DECIMAL.
  DEFINE VARIABLE cdiscamt AS DECIMAL.
  DEFINE VARIABLE tretail  AS DECIMAL.
  DEFINE VARIABLE tposdisc AS DECIMAL.
  FIND order-i OF order NO-LOCK
    WHERE order-i.item-no = v-trans.item-no NO-ERROR.
  /* reassign important fields */
  IF AVAILABLE order-i THEN
    ASSIGN
      v-trans.extended = order-i.extended
      v-trans.disc-amt = order-i.disc-amt.
  IF order.dt-due > TODAY THEN
  DO:
    RUN rentirtn.
    ASSIGN
      tposdisc = v-trans.pos-disc / v-trans.qty
      tretail  = v-trans.retail / v-trans.qty.
    RUN undoreturn.
  END.

  cextend = v-trans.extended / v-trans.qty.
  cdiscamt = v-trans.disc-amt / v-trans.qty.
  corig = v-trans.orig-value.
  v-trans.origextend = v-trans.extended.
  IF v-trans.extended <> 0 THEN
    ASSIGN    /* partamt used in jacaltest.p */
      v-trans.partamt  = v-trans.extended - (cextend * (v-trans.qty - skyqty))
      v-trans.extended = cextend * (v-trans.qty - skyqty).
  IF v-trans.disc-amt <> 0 THEN
    v-trans.disc-amt = cdiscamt * (v-trans.qty - skyqty).
  IF v-trans.orig-value <> 0 THEN
    v-trans.orig-value = corig /* * (v-trans.qty - skyqty)*/ .
  v-trans.origextend = v-trans.extended.  /* regtot p uses origextend */
  v-trans.amt-received = v-trans.extended.
  v-trans.qty = v-trans.qty - skyqty.
  v-trans.pos-disc = 0.

  FIND b-trans WHERE b-trans.item-no = v-trans.item-no.
  FIND v-trans WHERE RECID(v-trans) = v_rec.
  BUFFER-COPY b-trans EXCEPT b-trans.item-no TO v-trans.
  ASSIGN
    v-trans.origextend = cextend * skyqty
    v-trans.QTY        = skyqty
    v-trans.DISC-AMT   = IF b-trans.disc-amt = 0 THEN b-trans.disc-amt
                       ELSE cdiscamt * skyqty
    v-trans.POS-DISC   = tposdisc * skyqty
    v-trans.retail     = tretail  * skyqty
    v-trans.EXTENDED   = IF b-trans.EXTENDED = 0 THEN b-trans.extended
                       ELSE cextend * skyqty
    v-trans.ORIG-VALUE = IF b-trans.ORIG-VALUE = 0 THEN b-trans.orig-value
                        ELSE corig
    v-trans.LINK-RENT  = b-trans.item-no.
END.

/* @(#) rnproc-rentirtn.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-rentirtn.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE rentirtn: /* Set Status, calculate cost of rental to today */
  DEFINE VARIABLE pt-amt AS DECIMAL.
  IF v-trans.old-item = NO THEN RETURN.
  ASSIGN
    v-trans.estat       = "R"
    v-trans.item-type   = 'RR'
    v-trans.item-status = IF v-trans.item-status = 'LOAN' THEN 'LRETURN'
                        ELSE 'RETURN'
    v-trans.retail      = 0
    v-trans.messages    = ""
    t-total             = t-total - v-trans.extended.  /* take off current amount */
  RUN regularrent(OUTPUT v-trans.extended).
END.

/* @(#) rnproc-backoffrent.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-backoffrent.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE backoffrent:
  /* Calculate rental cost of an item up to today */
  DEFINE VARIABLE t-tot-due    AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-due-amount AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-disc       AS DECIMAL NO-UNDO.

  DEFINE VARIABLE t-rt-days    AS INTEGER NO-UNDO.
  DEFINE VARIABLE dum_l        AS LOG.     /* is a new business day chosen */
  DEFINE VARIABLE addqty       AS DECIMAL.
  FOR EACH v-trans WHERE v-trans.product-no <> "" AND NOT v-trans.void
    AND v-trans.sku-no > 0 AND v-trans.sku-no < 9999990:
    IF v-trans.estat = "p" OR v-trans.estat = "b" THEN NEXT.

    /* if the due date was not a business day, and the item was returned
       on the next business day, do not charge extra rent     */
    IF t-funct-name = "loan.create" THEN is-loan = YES.
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
    IF AVAILABLE order THEN
      t-date-due = s-dt-return.   /* is the date set in back office */
    /* find the next business day */
    s-dt-return = t-date-due.       /* if not assigned then it keeps old date */
    RUN jacaltest.p(INPUT t-date-due, INPUT s-link-order,
      INPUT v-trans.item-no, OUTPUT t-tot-due,
      OUTPUT t-due-amount, OUTPUT t-disc).
    v-trans.retail = t-tot-due.
    v-trans.rntrefund = v-trans.retail.
    v-trans.rent-credit = v-trans.retail * - 1.
    FIND order-i OF order WHERE order-i.item-no = v-trans.item-no
      AND order-i.item-type = "ri" NO-ERROR.
    IF v-trans.date-code = "" AND v-trans.old-item = NO THEN
    DO:
      FIND inv-locsrl NO-LOCK
        WHERE inv-locsrl.serial-no = v-trans.serial-no
        AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
      IF AVAILABLE inv-locsrl THEN v-trans.date-code = inv-locsrl.date-code.
    END.

    IF NOT AVAILABLE order-i THEN
    DO:
      CREATE order-i.
      IF v-trans.disc-amt = ? THEN v-trans.disc-amt = 0.
    END.

  END.
END PROCEDURE.

/* @(#) rnproc-regularrent.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-regularrent.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE regularrent:
  /* Calculate rental cost of an item up to today */
  DEFINE OUTPUT PARAMETER t-tot-due AS DECIMAL.
  DEFINE VARIABLE t-due-amount AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-disc       AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-rt-days    AS INTEGER NO-UNDO.
  DEFINE VARIABLE addqty       AS DECIMAL.
  DEFINE VARIABLE testdate     AS DATE    NO-UNDO.

  IF v-trans.estat = "p" OR v-trans.estat = "B" THEN
  DO:
    t-tot-due = v-trans.extended.
    RETURN.
  END.
  IF NOT p-rent-code BEGINS "re" AND NOT p-rent-code BEGINS "billing" THEN
  DO:
    /* rentirtn will set up school and billing as if return today */
    FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
    v-trans.amt-received = v-trans.extended.  /* need original amt for void. */

    IF order.rent-code = "SCHOOL" THEN
    DO:
      /**** Does not go through here on create or add ****/
      RUN newSchTestCalcsAug12.p( buffer order, v-trans.item-no,
        order.dt-due, tSchCostShare, tSchCostShareValue, OUTPUT t-tot-due).
      RETURN.
    END.
  END.

  IF v-trans.estat = "p" OR v-trans.estat = "B" THEN RETURN.

  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  IF AVAILABLE order THEN
    IF order.dt-created = TODAY THEN
    DO:
      IF p-status = "create" THEN
        t-date-due = s-dt-return.
      ELSE IF order.dt-due >= TODAY THEN /* could revisit order same day */
          t-date-due = order.dt-due.
      IF t-hold THEN t-date-due = t-dt-enter.
    END.
    ELSE IF order.dt-due > TODAY THEN
        t-date-due = order.dt-due.
      ELSE IF order.dt-due <= TODAY THEN
          t-date-due = TODAY.
  /* find the next business day */
  ASSIGN
    testdate = t-date-due.

  IF v-trans.estat = "r" THEN testdate = TODAY. /* should also work for X */
  /* Partial returns processed here AND ALSO estat = "e"**/
  FIND order-i OF order NO-LOCK
    WHERE order-i.item-no = v-trans.item-no NO-ERROR.
  IF NOT AVAILABLE order-i THEN
  DO:
    /* this is not reached until f4 back from next screen so not used **/
    IF v-trans.estat = "e" THEN
    DO:
      FIND b-trans WHERE b-trans.item-no = v-trans.link-rent NO-ERROR.
      IF AVAILABLE b-trans THEN
      DO:
        DEFINE VARIABLE p-endkey AS LOG.
        RUN rnExchCalc.p(v-trans.item-no, testdate,
          OUTPUT t-tot-due ,OUTPUT t-due-amount, OUTPUT t-disc, OUTPUT p-endkey).
        v-trans.extended = t-tot-due - v-trans.retail.  /*N.B.*/
      END.
    END.
    ELSE
    DO:  /** Partial returns land here and return ***/
      IF order.dt-created = TODAY AND testdate = TODAY
        AND v-trans.old-item = NO THEN
      DO:
        RUN jacaltest.p(INPUT testdate + 1 , INPUT s-link-order,
          INPUT v-trans.item-no, OUTPUT t-tot-due,
          OUTPUT t-due-amount, OUTPUT t-disc).
      END.
      ELSE
        RUN jacaltest.p(INPUT testdate, INPUT s-link-order,
          INPUT v-trans.item-no, OUTPUT t-tot-due,
          OUTPUT t-due-amount, OUTPUT t-disc).
      /* Partial returns now use full return off line item  */
      IF v-trans.estat = "r" /** and v-trans.link-rent <> v-trans.item-no ***/
        AND v-trans.serial-no BEGINS "SKU#" THEN
      DO:
        RETURN.
      /*  run rnRollBack.p(buffer order, today, v-trans.item-no).
     /*t-tot-due = v-trans.origextend - v-trans.pos-disc.*/
     return.  */
      END.

      ASSIGN
        v-trans.retail    = t-disc
        v-trans.rntrefund = v-trans.retail.
      IF v-trans.estat = "r" THEN v-trans.pos-disc = v-trans.disc-amt.
    /* task ms-206 */
    END.
    RETURN.
  END.
  IF v-trans.estat = "r" THEN
  DO:
    /* SPECIAL CASE OF CHARGE FOR THE FIRST DAY */
    RUN jacaltest.p(INPUT testdate, INPUT s-link-order,
      INPUT v-trans.item-no, OUTPUT t-tot-due,
      OUTPUT t-due-amount, OUTPUT t-disc).
    v-trans.retail = t-due-amount.
    v-trans.rntrefund = v-trans.retail.
    IF order.rent-code <> "billing" THEN
    DO: /* not tested band monthly*/
      RUN rnRollBack.p(buffer order, TODAY, v-trans.item-no).
      /* special case where extended = .21% of the first day */		
      IF v-trans.extended < t-tot-due AND v-trans.disc-amt <> 0
        AND t-tot-due < v-trans.extended + v-trans.disc-amt THEN
        t-tot-due = v-trans.extended.
    END.
    /* MUST INCLUDE ALL EARLY PARTIAL RETURN HERE, INCL. FINAL LINE RETURN*/

    /**** FINISHES HERE FOR EARLY RETURNS INCLUDING BAND "billing *******/
    IF v-trans.estat = "r" AND order.dt-due >= TODAY THEN RETURN.
    /* discount was 100% **/
    /* DEAL WITH SPECIAL CASE OF THE BUYOUT OF
       THE REMAINDER OF A LINE AFTER A PARTIAL RETURN HAS BEEN MADE **/
    IF AVAILABLE order-i AND order-i.qty <> v-trans.qty
      AND v-trans.serial-no BEGINS "sku#" THEN
    DO:
      /* Full not partial return of sku qty lands here
        also the remainder which prior to being purchased */
      ASSIGN
        v-trans.retail    = t-due-amount
        v-trans.rntrefund = v-trans.retail.
      RETURN. /* return needed for remainder being purchased
               imtiredcalc throws it out below */
    END.
    IF v-trans.disc-amt >= t-tot-due + t-disc THEN
      t-tot-due = v-trans.extended.
    IF v-trans.disc-amt <> 0    /* task 2359*/
      AND TODAY = v-trans.dt-rented THEN t-tot-due = v-trans.extended.
    ASSIGN  /* N1206634 refund bal of month then */
      v-trans.retail    = t-due-amount
      /*v-trans.retail = t-disc*/
      v-trans.rntrefund = v-trans.retail.
    IF v-trans.dt-rented = TODAY THEN
    DO:
      RETURN.
    END.
    /* JACALTEST DOES NOT HANDLE RENT CREDIT */
    DEFINE VARIABLE p-adj       AS DECIMAL.
    DEFINE VARIABLE p-adjOwed   AS DECIMAL.
    DEFINE VARIABLE pTotRentAdj AS DECIMAL.

    /**** can only use with pre-existing items *****/
    RUN ImTiredCalc.p(buffer order, TODAY, v-trans.item-no,
      v-trans.item-no, OUTPUT pTotRentAdj ,OUTPUT p-adjOwed, OUTPUT p-adj).
    /* rto back office has rent-credit task 2782*/
    IF order.order-no BEGINS "ro" AND order.loc-code = "lw21" AND
      v-trans.rent-credit < 0 THEN
    DO:
      IF v-trans.estat = "r" THEN
      DO:
        IF order.dt-due < TODAY THEN
          p-adjOwed = pTotRentAdj + v-trans.rent-credit.
        ELSE
          ASSIGN  /* early return and rollback rto entered back office */
            p-adjOwed = MAXIMUM((pTotRentAdj + p-adj) * - 1,
                v-trans.rent-credit - p-adj).
        IF v-trans.disc-amt > 0 THEN /*patch for early return with disc*/
          p-adjOwed = 0.
      END.
      pTotRentAdj = pTotRentAdj + v-trans.rent-credit.
      t-tot-due = pTotRentAdj.
      v-trans.retail = p-adjOwed.
      v-trans.rntrefund = v-trans.retail.
    END.
    IF t-due-amount = 0 THEN ASSIGN
        p-adjowed = 0.
    pTotRentAdj = t-tot-due - t-disc.
    /* that part of a partial not returned when overdue falls here ***/
    ASSIGN
      v-trans.retail    = p-adjOwed
      v-trans.rntrefund = v-trans.retail
      /* credit comes from rto back office entries */
      t-tot-due         = pTotRentAdj + v-trans.rent-credit.
    /* patch because cal-rent always charges for one day.*/
    IF v-trans.disc-amt >= t-tot-due + t-disc THEN
      t-tot-due = 0.

    IF v-trans.estat = "r" THEN
    DO:
      RETURN.
    END.
  END.
  /* patch coming back from calcs */
  IF t-funct-name = "loan.create" THEN
  DO:
    IF t-tot-due = ? THEN t-tot-due = 0.
    IF t-due-amount = ? THEN t-due-amount = 0.
  END.
  ASSIGN /* COUPONS */
    tPartialRefund = v-trans.semester * - 1
    t-disc         = v-trans.billing
    t-due-amount   = v-trans.yearly.
  IF NOT f9active THEN
    s-dt-return = t-date-due.    /* if not assigned then it keeps old date */
  IF s-issue = ? THEN s-issue = TODAY.  /* nov 29 */
END PROCEDURE.

/* @(#) rnproc-emplBuyValue.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-emplBuyValue.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE emplBuyValue:
  DEFINE INPUT-OUTPUT PARAMETER t-unit AS DECIMAL NO-UNDO.
  FIND customer OF order NO-LOCK NO-ERROR.

  IF AVAILABLE customer AND customer.discount-level = 3 THEN
  DO:
    FIND inv-locsrl WHERE inv-locsrl.serial-no = v-trans.serial-no
      AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
    IF AVAILABLE inv-locsrl THEN
      t-unit = get-retail(v-trans.sku-no
        ,v-trans.serial-no,"U",YES).
    ELSE t-unit = get-retail(v-trans.sku-no
        ,v-trans.serial-no,"",YES).
    IF t-unit <> 0 THEN
      ASSIGN
        v-trans.extended    = t-unit * v-trans.qty
        v-trans.sorig-value = v-trans.orig-value
        v-trans.orig-value  = t-unit.
  END.
END.

/* @(#) rnproc-buynewitem.i 1.3 03/07/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-buynewitem.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE buynewitem:
  DEFINE VARIABLE recpur    AS RECID.
  DEFINE VARIABLE vserec    AS RECID.
  DEFINE VARIABLE p-rentrfd AS DECIMAL.
  ASSIGN
    recpur = RECID(v-trans).
  DEFINE VARIABLE t-unit AS DECIMAL NO-UNDO.
  FIND v-trans WHERE RECID(v-trans) = buyrec.
  DEFINE VARIABLE t-retail-warr AS DECIMAL NO-UNDO.
  vserec = RECID(v-trans).
  IF v-trans.estat = "p" THEN
  DO:
    FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
    IF AVAILABLE inv-master AND inv-master.serial-reqd = "y"
      OR inv-master.serial-reqd = "r" THEN
    DO:
      HIDE FRAME brws-frame NO-PAUSE.
      HIDE FRAME f NO-PAUSE.

      IF AVAILABLE order AND order.rent-code = "school"
        THEN
        IF v-trans.origextend = 0 THEN
          v-trans.origextend = v-trans.extended.

      IF v-trans.rent-rate <> 0 THEN
      DO:
        IF v-trans.retail = 0 THEN ASSIGN
            v-trans.retail = v-trans.orig-value * v-trans.qty.
        RUN warranty1("auto,single",OUTPUT t-endkey).
        FIND v-trans WHERE RECID(v-trans) = buyrec.
        IF t-endkey = YES THEN
        DO:
          IF inv-master.serial-reqd <> "r" THEN
          DO:
            ASSIGN
              v-trans.estat    = ""
              v-trans.extended = v-trans.origextend.
            IF AVAILABLE order AND p-rent-code = "billing"
              AND order.int-status = "create" THEN
            DO:
              ASSIGN
                v-trans.extended  = v-trans.est-repair-cost
                v-trans.retail    = v-trans.extended
                v-trans.rntrefund = v-trans.retail.
            END.
          END.
          /* following fixes f4 off warranty on sm58 when f7 is last */
          ELSE
            v-trans.extended = v-trans.orig-value * v-trans.qty.
          IF inv-master.serial-reqd = "r" THEN
          DO:
            FIND FIRST v-trans WHERE v-trans.product-no = ""
              AND v-trans.orig-value = 0 AND v-trans.rent-rate = 0
              AND v-trans.old-item = NO NO-ERROR.
            IF NOT AVAILABLE v-trans THEN
              RUN newwtrans.
          END.
          ELSE
          DO: /* warranty forces an endkey of "NO" */
            IF (v-trans.sku-no = 59 OR v-trans.sku-no = 29
              OR v-trans.sku-no = 31) AND v-trans.estat = "P" THEN
              v-trans.extended = v-trans.orig-value * v-trans.qty.
            ELSE IF v-trans.estat = "P" THEN
                v-trans.extended = v-trans.orig-value * v-trans.qty.
          END.
          RUN reopenquery.
          RETURN.
        END.
        ELSE
        DO:
          IF v-trans.serial-no BEGINS "sku#"
            AND v-trans.rglr-warranty = 0 THEN
          DO:
            FIND FIRST v-trans WHERE v-trans.product-no = ""
              AND v-trans.orig-value = 0 AND v-trans.rent-rate = 0
              AND v-trans.old-item = NO NO-ERROR.
            IF NOT AVAILABLE v-trans THEN
            DO:
              RUN newwtrans. RUN reopenquery.
              RETURN.
            END.
          END.
        END.
      END.
      ELSE IF AVAILABLE order AND order.order-no BEGINS "rs" THEN
        DO:
          v-trans.extended = v-trans.orig-value * v-trans.qty. /*patch aug2009*/
          FIND v-trans NO-LOCK WHERE v-trans.product-no = "" NO-ERROR.
          IF NOT AVAILABLE v-trans THEN
            RUN newwtrans.
          RUN reopenquery.
          RETURN.
        END.
    END.
  END.
  IF v-trans.estat = "B" THEN
  DO:

    HIDE FRAME brws-frame NO-PAUSE.
    HIDE FRAME f NO-PAUSE.
    HIDE FRAME fr-descrip NO-PAUSE.  /* jul18 when not warranty item */
    IF v-trans.rent-rate <> 0 THEN
    DO:
      RUN warranty1("auto,single", OUTPUT t-endkey).
      FIND v-trans WHERE RECID(v-trans) = buyrec.
      IF t-endkey = YES THEN
      DO:
        v-trans.estat = "".
        RUN reopenquery.
        RETURN.
      END.
    END.
    FIND v-trans WHERE RECID(v-trans) = buyrec.
    /*REASSIGN */
    v-trans.orig-amount = v-trans.extended.

    RUN rentirtn. /* A QUICK WAY OF GETTING REFUND AMOUNT */
    /* above sets extended with total owed and rntrefund */
    p-rentrfd = v-trans.rntrefund.

    IF t-funct-name = "loan.create" THEN p-rentrfd = 0.
    RUN undoreturn.
    v-trans.amt-received = v-trans.extended.
    v-trans.estat = "B".
    v-trans.item-type = "RB".
    v-trans.item-status = IF item-status = "LOAN" THEN "LBUY"
    ELSE "BUY".
    v-trans.rntrefund = p-rentrfd.
    v-trans.finalextend = v-trans.rntrefund.
    v-trans.extended = v-trans.origextend.
    FIND v-trans WHERE RECID(v-trans) = buyrec.
    HIDE FRAME brws-frame NO-PAUSE.
    v-trans.pos-disc = 0. /* patch cause prev disc are picked off ord-i*/
    oMsg:msg-hide().
    
    IF p-rent-code = "rentown" THEN
    DO:

      RUN ro-rentiby.p
        (INPUT-OUTPUT vserec,
        INPUT-OUTPUT recpur, OUTPUT t-buys, OUTPUT t-disc,
        INPUT totalbuy, INPUT t-purchase, INPUT v-trans.rntrefund,
        INPUT s-by-amt).
    END.
    ELSE
    DO:
      v-trans.amt-received = v-trans.extended.
      /********************************************* COUPONS ****/
      IF p-rent-code = "regular" OR p-rent-code = "billing" THEN
      DO:
        RUN rentiby.p(INPUT-OUTPUT vserec,
          INPUT-OUTPUT recpur, OUTPUT t-buys, OUTPUT t-disc,
          INPUT totalbuy, INPUT t-purchase, INPUT v-trans.rntrefund,
          INPUT s-by-amt, INPUT-OUTPUT tx-msg).
      END.
    END.


    IF order.rent-code = "School" THEN
    DO:
      RUN SchRentiBy.p(tSchCostShare,tSchCostShareValue, INPUT-OUTPUT vserec,
        INPUT-OUTPUT recpur, OUTPUT t-buys, OUTPUT t-disc,
        INPUT totalbuy, INPUT t-purchase, INPUT v-trans.rntrefund,
        INPUT s-by-amt, INPUT-OUTPUT tx-msg).
    END.

    oMsg:msg-refresh().
    FIND v-trans WHERE RECID(v-trans) = buyrec.
    IF v-trans.rntrefund <> v-trans.finalextend THEN /* update rntrefnd*/
      v-trans.finalextend = v-trans.rntrefund.


    VIEW FRAME brws-frame.
    PAUSE 0 NO-MESSAGE.
    IF LASTKEY = keycode("f4") THEN
    DO:
      v-trans.extended = v-trans.amt-received.
      DEFINE VARIABLE t-orig-no AS INTEGER NO-UNDO.
      t-orig-no = v-trans.item-no.
      FIND v-trans WHERE v-trans.warranty-link = t-orig-no NO-ERROR.
      IF AVAILABLE v-trans THEN
      DO:
        v-trans.void = YES.
      END.
      FIND v-trans WHERE RECID(v-trans) = buyrec.
      RUN undobuynewitem.
      RETURN.
    END.
  END.  /*** end of v-trans.estat = "B" **/
  /* below for a buy. amt-received contains rent paid.
  for a purchase it contains the purchase price. */
  /* on a regular rent where item is purchased it contains Extended amt*/

  FIND v-trans WHERE RECID(v-trans) = buyrec NO-ERROR.
  ASSIGN
    v-trans.amt-received = v-trans.extended
    t-buys               = t-buys - t-retail-warr.  /* subtract the warranty amount. */

  /* next line should update screen with estat. this is a patch to a bug */
  ASSIGN
    v-trans.item-type   = "RB"
    v-trans.info-item   = YES     /* yes   */
    v-trans.retail      = IF v-trans.estat = "B" THEN t-disc
                              ELSE v-trans.orig-value * v-trans.qty
    v-trans.extended    = IF v-trans.estat = "B" THEN t-buys
       ELSE v-trans.orig-value * v-trans.qty

    v-trans.old-item    = IF v-trans.estat = "B" THEN YES
                         ELSE v-trans.old-item
    s-by-amt            = s-by-amt + v-trans.extended
    t-total             = t-total + v-trans.extended
    totalbuy            = totalbuy + s-by-amt.
  
  /* Change the item-status for purchase UNLESS purchasing from a Loan. */
  /* The undobuynewitem.i program uses "LBUY" to change the item-status */ 
  /* back to "LOAN" if the customer changes their mind */
  IF v-trans.item-status <> "LBUY" THEN DO:
    IF v-trans.estat = "B" THEN 
      v-trans.item-status = "BUY".    /* BUY  - Product purchased off an existing Rental contract and has */
                                      /* Rental Credit (line-item has "B" flag) */
    ELSE 
      v-trans.item-status = "BUYS".   /* BUYS - Product purchased during Rental Create (line-item has "P" flag) */
  END.

  IF p-rent-code BEGINS "re" THEN
  DO:
    v-trans.retail = IF v-trans.estat = "B" THEN t-disc ELSE
      v-trans.orig-value.
    v-trans.after-value = v-trans.retail. /* suspend sale ?? */
  /* pause 2000 above should it not be times v-trans.qty */
  END.
  RUN correcttotal.
  IF v-trans.serial-no BEGINS string("SKU#") THEN
  DO:
  END.
  IF v-trans.sku-no = 28 THEN RUN undobuynewitem. /* patch dont buy ins */
END.

/* @(#) rnproc-undobuynewitem.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-undobuynewitem.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE undobuynewitem:
  DEFINE VARIABLE t-recid         AS RECID   NO-UNDO.
  DEFINE VARIABLE t-old-item      AS INTEGER NO-UNDO.
  DEFINE VARIABLE t-extend        AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-warranty-link AS INTEGER NO-UNDO.

  IF AVAILABLE v-trans THEN
  DO:

    FIND order NO-LOCK WHERE order.link-order = v-trans.link-order NO-ERROR.
    /* remove printed matter */
    IF t-funct-name <> "loan.create" THEN
    DO:
      FIND inv-master NO-LOCK
        WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
      IF AVAILABLE inv-master AND (inv-master.group-no >= 8500
        AND inv-master.group-no <= 8522)
        OR (AVAILABLE inv-master
        AND (inv-master.group-no > 8523 AND inv-master.group-no <= 8999))
        THEN
      DO:
        MESSAGE "Purchase of item cannot be made into a Rentable item." SKIP
          "It will be deleted." VIEW-AS ALERT-BOX.
        DELETE v-trans.
        FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
        /* ENSURE THAT v_rec sSTILL EXISTS **/
        RUN reopenquery.
        RUN showdipfield.
        RETURN.
      END.
    END.

    IF v-trans.warranty-link <> 0 THEN
    DO:  /* undoing extended warranty */
      t-warranty-link = v-trans.warranty-link.
      DELETE v-trans.
      FIND v-trans WHERE v-trans.item-no = t-warranty-link NO-ERROR.
      IF AVAILABLE v-trans THEN   /* remove info from purchase item */
        ASSIGN
          v-trans.rglr-warranty     = 0 v-trans.extended-warranty = 0.
      FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
      RUN reopenquery.
      RUN showdipfield.
      RETURN.
    END.
    ASSIGN
      v-trans.rglr-warranty     = 0
      v-trans.extended-warranty = 0.

    IF NOT order.rent-code BEGINS "re" AND v-trans.estat = "P" THEN
      IF v-trans.old-item = NO THEN
        t-extend = v-trans.rent-rate * v-trans.qty.
      ELSE
        t-extend = v-trans.amt-received.

    IF v-trans.old-item THEN
    DO:
      FIND order-i OF order NO-LOCK
        WHERE order-i.item-no = v-trans.item-no NO-ERROR.
      IF AVAILABLE order-i THEN t-extend = order-i.extended.
      v-trans.amt-received = t-extend.
      /* non-serialized with prior return will be wrong so reduce */
      IF order-i.qty <> v-trans.qty THEN
      DO:
        /*find b-trans where b-trans.link-item = v-trans.item-no no-error.
        if avail b-trans then
          t-extend = t-extend - b-trans.origextend. task 7001****/
        t-extend = order-i.extended / order-i.qty. /* THE ORIGINAL*/
        t-extend = t-extend * v-trans.qty. /* THE NEW REMAINDER */
      END.
      v-trans.amt-received = t-extend.   /* for both cases */
    END.
    ELSE RELEASE order-i. /* should not have if item is new item */

    ASSIGN
      v-trans.item-status       = IF v-trans.item-status = "LBUY" THEN "LOAN"
                             ELSE ""
      v-trans.item-type         = "RI"
      v-trans.info-item         = YES
      v-trans.orig-recid        = 0
      v-trans.rent-owed         = 0
      v-trans.pos-mkdn          = 0
      v-trans.extended-warranty = 0
      v-trans.rglr-warranty     = 0
      /*    should not have to deal with this. but buynewitem does set it!!!
      v-trans.old-item = if v-trans.estat = "P" and is-loan
         and v-trans.dt-loan = today then no else if v-trans.estat = "p" and
         not is-loan and v-trans.dt-rented = today then no
      else yes
      */
      v-trans.estat             = ""
      v-trans.retail            = IF AVAILABLE order AND p-rent-code = "billing"
        AND order.int-status = "create" THEN t-extend
        ELSE 0
      v-trans.extended          = t-extend  /* only solution */
      v-trans.orig-value        = IF AVAILABLE order-i THEN order-i.orig-value
           ELSE IF v-trans.sorig-value <> 0.00 THEN
           v-trans.sorig-value ELSE v-trans.orig-value
      v-trans.sorig-value       = 0
      v-trans.rent-credit       = 0 /* affects an exchange */
      s-by-amt                  = s-by-amt - v-trans.extended.

    /* this is a weird line */
    IF v-trans.disc-per <> 0 THEN v-trans.estat = "*".
    RUN correcttotal.
    /* show inventory that unbought item is out on rent.  */
    IF v-trans.serial-no BEGINS string("SKU#") THEN
    DO:
    END.
    ELSE
    DO:
    END.
    t-recid = RECID(v-trans).
    t-old-item = v-trans.item-no.
    FIND v-trans WHERE v-trans.warranty-link = t-old-item NO-ERROR.
    IF AVAILABLE v-trans THEN
    DO:    /* delete any warranty. */
      DELETE v-trans.
      FIND v-trans WHERE RECID(v-trans) = t-recid NO-ERROR.
      RUN reopenquery.
      RUN showdipfield.
    END.          /* refind the item being undone. */
    ELSE IF NOT AVAILABLE v-trans THEN
        FIND v-trans NO-LOCK WHERE RECID(v-trans) = t-recid NO-ERROR.
  END.
  RELEASE inv-locsrl.
END.

/* @(#) rnproc-warranty1.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-warranty1.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE warranty1:
  DEFINE INPUT PARAMETER pFlag AS CHARACTER NO-UNDO.
  DEFINE OUTPUT PARAMETER pz-endkey AS LOG INIT NO NO-UNDO.

  DEFINE VARIABLE lastitem AS INTEGER NO-UNDO.
  FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
  IF AVAILABLE v-trans THEN lastitem = v-trans.item-no.
  FIND v-trans WHERE RECID(v-trans) = buyrec NO-ERROR.
  IF AVAILABLE v-trans AND (v-trans.sku-no = 19 OR v-trans.sku-no = 29
    OR v-trans.sku-no = 39 OR v-trans.sku-no = 59 OR v-trans.sku-no = 31)
    THEN
  DO:
    RETURN.
  END.
  RUN rn-get-extwarr.p(pFlag,v-trans.item-no,
    INPUT-OUTPUT lastitem, INPUT-OUTPUT buyrec, OUTPUT pz-endkey).
  IF AVAILABLE order AND order.order-no BEGINS "RO" THEN
    v-trans.extended-warranty
    = v-trans.extended-warranty + v-trans.rglr-warranty.
  FOR EACH v-trans:
    lastitem = v-trans.item-no.
    /* patch for recovering suspended sale-i */
    IF v-trans.estat = "P" THEN v-trans.line-desc[4] = "Buys".
  END.
  itemnum = lastitem.
  FIND v-trans WHERE v-trans.sku-no = 0 AND v-trans.product-no = "" NO-ERROR.
  IF AVAILABLE v-trans THEN
    v_rec = RECID(v-trans) .
  ELSE
    RUN newwtrans.
END.

/* @(#) rnproc-usenonserial.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-usenonserial.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE usenonserial:
  /* 3 callers are in dof5 */
  IF LASTKEY = keycode("f4") THEN RETURN.

  IF AVAILABLE inv-master AND inv-master.sku-no = 351993
    AND t-hold THEN
  DO:
    MESSAGE
      "RENTAL COUPONS CANNOT BE USED ON THE CREATE " SKIP
      "OF A RENTAL FROM A HOLD CONTRACT." VIEW-AS ALERT-BOX.
    ASSIGN
      recm              = ?
      s-rec             = ?
      v-trans.serial-no = ""
      e                 = "".
    RELEASE inv-master.
    RETURN.
  END.

  RUN rn-holdtestskus.p(t-funct-name, INPUT-OUTPUT recm). /* validates recm */
  IF recm = ? THEN RETURN.

  /* TEST PRINTED MATTER SEPARATELY */
  FIND v-trans WHERE RECID(v-trans) = v_rec.
  ASSIGN
    v-trans.product-no = inv-master.product-no
    v-trans.sku-no     = inv-master.sku-no
    v-trans.qty        = 1
    v-trans.serial-no  = STRING("SKU# ") +
      string(inv-master.sku-no,"9999999")
    v-trans.item-type  = "RI".
  /* DO IF A DESCRIPTION IS REQUIRED ON THE PRODUCT */
  FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
  FIND sysrectp NO-LOCK WHERE sysrectp.rec-type = inv-master.rec-type NO-ERROR.
  IF AVAILABLE sysrectp THEN
    IF sysrectp.desc-req THEN
    DO:
      loopec: DO ON ERROR UNDO loopec, LEAVE loopec
        ON ENDKEY UNDO loopec, LEAVE loopec:
        status-ok = cust-browse:refresh() IN FRAME brws-frame.
        RUN getdescription.
        /* END KEY BOUNCES COMPLETELY OUT. */
        IF v-trans.description = "" AND
          v-trans.sku-no = 0351993 AND
          (v-trans.serial-no = "SKU# 0351993" OR v-trans.serial-no = "" )
          THEN
        DO:
          DELETE v-trans.
          RUN newwtrans.
          RETURN.
        END.
      END.
      IF v-trans.sku-no = 28 AND p-rent-code = "school"
        AND v-trans.old-item = NO THEN
        ASSIGN v-trans.orig-value = 10
          v-trans.rent-rate  = 10
          v-trans.extended   = 10.

      IF AVAILABLE inv-master THEN /* aug25 add avail inv-master */
        RUN paidoff. /* oct25/99 example sks-11b didnt land on qty field. */


      IF AVAILABLE v-trans THEN
      DO:
        ASSIGN
          t-total = t-total + v-trans.extended
          t-tot2  = t-tot2 + v-trans.orig-value.
        DISPLAY t-tot2 t-total WITH FRAME fr-total2 .
        VIEW FRAME brws-frame.
        IF v-trans.estat = "p" AND inv-master.serial-reqd = "r" THEN
        DO:
          ASSIGN
            buyrec = RECID(v-trans).
          RUN buynewitem.
        END.
        ELSE
          RUN newwtrans.
        RETURN.
      END.
      ELSE
      DO:  /* v-trans got deleted */
        RUN newwtrans.  /* to be tested aug06/2013 */
        RETURN .

      END.
    END.  /* END OF DESCRIPTION REQUIRED FOR NON-SERIAL TYPES */
  RUN getprice. /* mar21 */
  /* AGAIN IT HITS rentret from getprice. */

  ASSIGN
    t-total = t-total + v-trans.extended
    t-tot2  = t-tot2 + v-trans.orig-value .
  DISPLAY t-tot2 t-total WITH FRAME fr-total2 .
  VIEW FRAME brws-frame.
  IF NOT midexch THEN
  DO:
    IF AVAILABLE v-trans AND v-trans.old-item = NO AND v-trans.sku-no = 28
      AND p-rent-code = "school" THEN
      ASSIGN
        v-trans.orig-value = 10
        v-trans.rent-rate  = 10
        v-trans.extended   = 10.

    IF AVAILABLE inv-master THEN
      RUN paidoff.
    IF AVAILABLE v-trans AND v-trans.sku-no = 28 AND p-rent-code = "school" THEN
      ASSIGN
        v-trans.orig-value = 10
        v-trans.rent-rate  = 10.

    IF LASTKEY = keycode("f4") THEN
      FIND inv-master NO-LOCK WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.

    IF AVAILABLE v-trans AND
      v-trans.estat = "p" AND inv-master.serial-reqd = "r" THEN
    DO:
      ASSIGN
        buyrec = RECID(v-trans).
      RUN buynewitem.   /* this will recover from above condition */
    END.
    ELSE IF AVAILABLE v-trans
        AND v-trans.estat = "p" THEN
      DO:
        v-trans.extended = v-trans.orig-value * v-trans.qty.
        RUN newwtrans.
      END.
      ELSE
        RUN newwtrans.
    RUN reopenquery.
  END.
END.

/* @(#) rnfunc-get-loc.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-get-loc.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION get-loc RETURNS CHARACTER():
  IF sale.sale-type = "rn" THEN
  DO:
    FIND order OF sale NO-LOCK NO-ERROR.
    IF AVAILABLE order THEN RETURN TRIM(order.loc-code).
  END.
  RETURN sale.loc-code.
END.

/* @(#) rnfunc-get-taxcode.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnfunc-get-taxcode.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

FUNCTION get-taxcode RETURNS CHARACTER():
  DEFINE VARIABLE t-loc AS CHARACTER NO-UNDO.
  t-loc = get-loc().
  FIND location
    WHERE location.loc-code = t-loc NO-LOCK.
  RETURN REPLACE(location.tax-collect,"/",",")
    + (IF location.tax-collect = ""
    THEN ""
    ELSE "," + location.tax-collect).
END FUNCTION.

/* @(#) rnproc-finalsale.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-finalsale.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE finalsale:
  DEFINE OUTPUT PARAMETER p-endkey AS LOG INIT NO.
  DEFINE VARIABLE is-valid AS LOG.
  DEFINE VARIABLE t-list   AS CHARACTER NO-UNDO.
  HIDE FRAME fr-display NO-PAUSE.

  IF (order.order-no BEGINS "rs"
    OR order.order-no BEGINS "s") AND p-status <> "create"
    THEN
  DO:
    t-deposit = t-deposit * - 1.
    FOR EACH v-trans WHERE v-trans.estat = "" AND v-trans.sku-no <> 0
      AND NOT v-trans.void:
      t-deposit = 0.   /* contract is not closing */
    END.
  END.
  s-amtdue = t-pay-enter. /* s-total. */
  IF NOT f9active THEN RUN total.
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  IF LASTKEY = keycode("f4") THEN
  DO:
    p-endkey = YES.
    RETURN.
  END.
  s-amtdue = s-total.

  IF salerec = "" THEN RUN createsale.
  ELSE
  DO TRANSACTION:     /* needed for ps-tendval.p aug12/04 */
    FIND sale EXCLUSIVE-LOCK WHERE sale.link-sale = salerec NO-ERROR.
    IF AVAILABLE sale THEN sale.link-order = order.link-order.
  END.
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
  /**   task 7263 **/
  IF p-rent-code = "school" THEN
  DO:
    /*IF tShipDirect THEN
        RUN ps/get-lywy-shipto.p(order.link-order
            ,order.cust-no
            ,"update,picked-up-by,shipInsure,OnHold"
            ,OUTPUT p-endkey).*/
    FIND FIRST v-trans WHERE v-trans.sku-no > 0 AND v-trans.sku-no < 9999990 AND v-trans.sku-no <> 28 AND v-trans.old-item = NO AND v-trans.estat = ""       NO-ERROR.
    IF AVAILABLE v-trans THEN
    DO:
      DEFINE VARIABLE pEndkey AS LOG NO-UNDO.
      RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
      oMsg:msg-hide().
      RUN ps/do-reviews.p(sale.link-sale, sale.cust-no,
        "fromRnNewp2,lRentalAdd",
        OUTPUT pEndkey).
      RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
      IF pEndKey = YES THEN
      DO:
        is-school = YES.
        p-endkey = YES.
        VIEW FRAME fr-display.
        RETURN.
      END.
    END.
  END.
  HIDE FRAME fr-display.
  /* we already have a sale so delete it and start over */
  /* do on "f4" undo, return: */
  RUN createsalei.  /* recreate if necessary */
  RUN create_transact.
  RUN createsaleitax.
  RUN rn-setacct.p(INPUT salerec).
  IF p-status = "create" THEN
  DO:
    IF chg-code <> 0 THEN
      s-amtdue = s-amtdue + t-deposit.
    RUN createsaleipd.
  END.
  ELSE IF s-co-complete THEN
      RUN createsaleipd.
    ELSE IF t-deposit <> 0 THEN
      DO:
        RUN createsaleipd.
        s-deposit = t-deposit.
        s-chargex = TRUE.
        s-security = NO.
        s-amtdue = s-amtdue + s-deposit.
      END.
  ASSIGN
    s-item-no = 1.
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
  salrec = RECID(sale). /* used by sale-end.p . */
  IF NOT f9active THEN
  DO:
    /* special case : force p-orderid to this order. */
    FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
    p-orderid = RECID(order).
    oMsg:msg-hide().
    RUN rn-postmsg.p(s-co-complete).
    DO TRANSACTION:
      FIND order EXCLUSIVE-LOCK
        WHERE order.link-order  = s-link-order NO-ERROR.

      IF AVAILABLE order THEN
      DO:  /* BLOCK LOANS GETTING ON EASYPAY */
        IF t-funct-name = "loan.create" AND p-status = "create"
          THEN ASSIGN chg-code          = 0 order.charge-code = 0.
        ELSE IF p-status = "create" THEN
            ASSIGN order.charge-code = chg-code.
      END.
    END.
    FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
    /* patch for sale keeping old cust-no */
    IF sale.cust-no <> order.cust-no THEN
    DO TRANSACTION:
      FIND sale EXCLUSIVE-LOCK WHERE sale.link-sale = salerec NO-ERROR.
      IF AVAILABLE sale THEN sale.cust-no = order.cust-no.
    END.
    FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
    p-endkey = NO.
    DEFINE VARIABLE t-suspend AS LOG NO-UNDO    .

    IF order.rent-code = "SCHOOL" OR order.rent-code = "billing" THEN
    DO:
      schoolblk-tender: REPEAT:
        RUN rsF3Code.p(buffer sale, s-deposit, t-loc-code, OUTPUT t-suspend,
          OUTPUT p-endkey).
        IF (KEYFUNCTION(LASTKEY) = "end-error" OR p-endkey)
          AND NOT t-suspend THEN
        DO:
          F3BANDATTENDER = NO. /* back to item screen */
          IF order.rent-code = "BILLING"  THEN
          DO:
            FOR EACH v-trans:
              IF v-trans.old-item = NO THEN
              DO: /* impacts new item exchange */
                IF V-TRANS.ESTAT <> "E" AND v-trans.estat <> "P" THEN
                  v-trans.extended = v-trans.amt-received.
                /***** when f9 active do this *****/
                v-trans.retail = v-trans.retail + v-trans.pos-disc.
                v-trans.pos-disc = 0.
                v-trans.mkdn-amt = 0.
                /* bug sku28 amt-received not set */
                IF v-trans.sku-no = 28 THEN
                  v-trans.extended = v-trans.rent-rate * v-trans.qty.
              END.
              ELSE IF v-trans.estat = "O" OR v-trans.estat = "r" THEN
                DO:
                  FIND order-i OF order NO-LOCK
                    WHERE order-i.item-no = v-trans.item-no NO-ERROR.
                  IF AVAILABLE order-i AND order-i.item-status = ""
                    AND ORDER-I.dt-return = ? THEN
                    ASSIGN v-trans.estat       = "r" v-trans.item-type   = "RR"                            v-trans.dt-return   = ? v-trans.item-status = "Return".
                  /* direct f4 back needs to reset pos-disc from f9 **/
                  v-trans.retail = v-trans.retail + v-trans.pos-disc.
                  v-trans.pos-disc = 0.
                  v-trans.mkdn-amt = 0.
                END.
            END.
            RETURN.
          END.
          IF order.rent-code = "SCHOOL"  THEN
          DO:
            FOR EACH v-trans:
              IF v-trans.old-item = NO THEN
              DO: /* impacts new item exchange */
                IF V-TRANS.ESTAT <> "E" AND v-trans.estat <> "P" THEN
                  v-trans.extended = v-trans.amt-received.
                /* when f9 active do this */
                v-trans.retail = v-trans.retail + v-trans.pos-disc.
                v-trans.pos-disc = 0.
                /* bug sku28 amt-received not set */
                IF v-trans.sku-no = 28 THEN
                DO:
                  IF tyears = 1
                    AND year-end = TODAY AND order.dt-due = TODAY THEN.
                  ELSE IF tyears = 1 THEN
                      v-trans.extended =
                        v-trans.rent-rate * v-trans.qty.
                /*else if tyears = 2 then
                    v-trans.extended = v-trans.rent-rate * v-trans.qty
                    * 2. */
                END.
              END.
              ELSE IF v-trans.estat = "O" OR v-trans.estat = "r" THEN
                DO:
                  FIND order-i OF order NO-LOCK
                    WHERE order-i.item-no = v-trans.item-no NO-ERROR.
                  IF AVAILABLE order-i AND order-i.item-status = ""
                    AND ORDER-I.dt-return = ? THEN
                    ASSIGN v-trans.estat       = "r" v-trans.item-type   = "RR"                           v-trans.dt-return   = ? v-trans.item-status = "Return".
                  /* direct f4 back needs to reset pos-disc from f9 **/
                  v-trans.retail = v-trans.retail + v-trans.pos-disc.
                  v-trans.pos-disc = 0.
                END.
            END.
          END.
          RETURN.  /*Replace F4 HIT*/
        END.
        /*if t-suspend = no and p-endkey then F3BANDATTENDER = NO.  F4 HIT*/
        ELSE IF t-Suspend AND p-Endkey THEN
          DO:  /*** the F3 KEY WAS HIT ****/
            t-suspend = NO.
            F3BANDATTENDER = YES.
            LEAVE schoolblk-tender.
          END.
          ELSE IF NOT p-endkey THEN
            DO:
              IF sale-invoice-req(sale.link-sale)
                AND NOT tShipDirect THEN
                RUN ps/get-lywy-shipto.p(sale.link-sale
                  ,sale.cust-no
                  ,"sale,update,picked-up-by,shipInsure,OnHold"
                  ,OUTPUT p-endkey).
              /* DEAL WITH p-endkey off of ship-to HERE */
              IF p-endkey THEN NEXT schoolblk-tender.
              LEAVE schoolblk-tender.
            END.
        IF CAN-FIND(order OF sale WHERE order.sale-type = "su") THEN
        DO:
          is_suspend = YES.
          LEAVE schoolblk-tender.
        END.
      END.
      IF t-suspend THEN is_suspend = YES.
      IF is_suspend = NO AND AVAILABLE order AND p-endkey = NO
        AND chg-code <> order.charge-code THEN
      DO TRANSACTION:
        FIND order EXCLUSIVE-LOCK
          WHERE order.link-order = s-link-order NO-ERROR.
        IF AVAILABLE order THEN
          order.charge-code = chg-code.
        FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
      END.
    END.

    ELSE
    DO:
      blk-tender: REPEAT:
        RUN ps/disp-total.p PERSISTENT SET t-ph(buffer sale).
        IF s-deposit <> 0 AND NOT order.rent-code BEGINS "re" THEN
          RUN get-deposit IN t-ph.
        /***   dont delete saletend here ***/
        IF t-loc-code <> order.loc-code THEN
          /* suspend not allowed on other stores contracts */
          RUN ps/sale-tend.p(buffer sale, "", OUTPUT t-suspend, OUTPUT p-endkey).
        ELSE
          RUN ps/sale-tend.p(buffer sale, "suspend", OUTPUT t-suspend,
            OUTPUT p-endkey).
        PAUSE 0 NO-MESSAGE.
        RUN destroy IN t-ph.
        /**** find order of sale no-error. /* RESET FROM RECOVERY */
        if order.CUST-ORDER-REF = "recover" then assign
          order.CUST-ORDER-REF = "".
        IF ORDER.ORDER-NO BEGINS "RH" THEN
          order.sale-type = "RH".
        ELSE order.sale-type = "RN".
          find order no-lock of sale no-error.  ****/
        IF NOT p-endkey THEN
        DO:

          IF sale-invoice-req(sale.link-sale)
            AND NOT tShipDirect THEN
            RUN ps/get-lywy-shipto.p(sale.link-sale
              ,sale.cust-no
              ,"sale,update,picked-up-by,shipInsure,OnHold"
              ,OUTPUT p-endkey).
          /* DEAL WITH p-endkey off of ship-to HERE */
          IF p-endkey THEN NEXT blk-tender.
          LEAVE blk-tender.
        END.
        ELSE IF (KEYFUNCTION(LASTKEY) = "end-error" OR p-endkey)
            AND NOT t-suspend THEN RETURN.
        IF CAN-FIND(order OF sale WHERE order.sale-type = "su") THEN
        DO:
          is_suspend = YES.
          LEAVE blk-tender.
        END.
      END. /* blk-tender */
      IF is_suspend = NO AND AVAILABLE order AND chg-code <> order.charge-code
        AND t-funct-name <> "loan.create" AND p-status <> "create"
        THEN
      DO TRANSACTION:
        FIND order EXCLUSIVE-LOCK WHERE order.link-order = s-link-order NO-ERROR.
        IF AVAILABLE order THEN order.charge-code = chg-code.
      END.

    END. /* NON-SCHOOL SCREEN task 6493*/

    FIND order OF sale NO-LOCK NO-ERROR.

    FIND FIRST saletend NO-LOCK OF sale WHERE saletend.tend-no = 19 NO-ERROR.
    IF AVAILABLE saletend THEN
    DO:
      t-taxcollect = saletend.tend-id[4].
      IF t-taxcollect = "" THEN
        t-taxcollect =  get-taxcode().
    END.
    IF CAN-FIND(order OF sale WHERE order.sale-type = "su") THEN
      is_suspend = YES.
    IF (KEYFUNCTION(LASTKEY) = "end-error" OR p-endkey) AND NOT is_suspend
      THEN RETURN. /* FROM ship info this will send back to reg tot.p */
  END.
  IF NOT is_suspend THEN
  DO:
    IF t-funct-name = "loan.create" THEN
    DO:
      /* section to return items back to new inventory ---- */
      DEFINE VARIABLE z-endkey AS LOG NO-UNDO.
      RUN rn-loanret.p(INPUT-OUTPUT p-list, OUTPUT z-endkey).
    END.
    IF LASTKEY = keycode("f4") OR z-endkey THEN
    DO:
      PAUSE 1 NO-MESSAGE.  /* clear any f4 off selection list */
    END.
    /* 9870 */
    DEFINE BUFFER sale-i     FOR sale-i.
    DEFINE BUFFER inv-locsrl FOR inv-locsrl.
    FOR EACH sale-i OF sale NO-LOCK :
      FIND inv-locsrl NO-LOCK
        WHERE inv-locsrl.sku-no = sale-i.sku-no
        AND inv-locsrl.serial-no = sale-i.serial-no NO-ERROR.
      IF AVAILABLE inv-locsrl
        THEN
      DO:
        RUN web/MarkWebItemSold.p(inv-locsr.sku-no,inv-locsrl.serial-no, 'Rented').
      END.
    END. /* FOR EACH sale-i */

    RUN finishrental.
    IF LASTKEY <> keycode("f4") THEN
    DO:
      HIDE FRAME fr-descrip NO-PAUSE.
      ENABLE e WITH FRAME f.
      APPLY "f12" TO FRAME f.
      HIDE FRAME f NO-PAUSE.
      CLOSE QUERY cust-qry.
      HIDE FRAME brws-frame NO-PAUSE.
    END.

    ELSE RETURN.
  END.   /* end of - if not suspended */

  ELSE
  DO:   /* if suspended */
    RUN createsu.
    RUN setregister.
    DISABLE s-ordnum WITH FRAME fr-ord.
    HIDE FRAME fr-descrip NO-PAUSE.
    ENABLE e WITH FRAME f.
    APPLY "f12" TO FRAME f.   /* already applied */
    HIDE FRAME f NO-PAUSE.
    CLOSE QUERY cust-qry.
    HIDE FRAME brws-frame NO-PAUSE.
    oMsg:msg-hide().
    RETURN.
  END.
END PROCEDURE.

/* @(#) rnproc-finishrental.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-finishrental.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE finishrental:
  DEFINE VARIABLE ordstatus AS CHARACTER.
  DEFINE VARIABLE t-round   AS LOG       INIT NO NO-UNDO.
  DEFINE VARIABLE t-stat    AS INTEGER   INIT 0.

  IF order.int-status = "create"
    AND t-funct-name = "r-own-create" THEN
  DO:
  END.

  IF NOT f9active OR order.order-no BEGINS "rs" THEN
  DO TRANSACTION :

    DEFINE VARIABLE t-item-no AS INTEGER INIT 0. /* keep a cnt on number of saletends. */
    t-item-no = s-item-no.
    FIND FIRST customer-r NO-LOCK
      WHERE customer-r.cust-no = sale.cust-no NO-ERROR.

    FIND sale EXCLUSIVE-LOCK WHERE sale.link-sale = salerec .
    IF AVAILABLE sale THEN
    DO:
      sale.cust-loc = customer-r.loc-code.
      RUN get-custbal.p("balance", buffer customer,
        OUTPUT sale.cust-prev-bal).
    END.
    /* if available sale then sale.ar-no = customer-r.ar-no. */
    IF TRIM(sale.authorized) <> ""
      THEN RUN ps/remove-duplicates.p (INPUT "",BUFFER sale).
    IF sale.ar-no = 0 THEN sale.dt-credit-agreement = ?.
    FIND customer OF sale NO-LOCK NO-ERROR.
    IF (sale.dt-credit-agreement <> ?)
      OR (sale.ar-no = 1 AND AVAILABLE customer
      AND customer.charge-cust = NO) THEN
    DO:
      FIND customer OF sale EXCLUSIVE-LOCK.
      ASSIGN
        customer.charge-cust    = YES
        /*4593: assign address review date if customer.chargecust
           changed from no to yes. */
        customer.addrreviewdate = IF customer.charge-cust = NO THEN TODAY
          ELSE customer.addrreviewdate
        customer.sec-agree-dt   = sale.dt-credit-agreement
        customer.equi-fax       = IF customer.sec-agree-dt = ? THEN NO ELSE YES.
      IF sale.dt-credit-agreement = ? THEN sale.dt-credit-agreement = TODAY.
    END.
    FOR EACH saletend OF sale WHERE NOT saletend.void
      AND saletend.tend-no = 25.
      saletend.tend-no = 22.  /*** change 90 day tender to revolving ***/
      saletend.internal = saletend.internal + ",90day".
    END.

    RUN ps/chg-custtype1.p(buffer sale).
    /* must follow chg-custtype1.p for 90day to work. */
    FIND FIRST saletend NO-LOCK OF sale WHERE NOT saletend.void AND
      saletend.tend-no = 22 NO-ERROR.
    IF AVAILABLE saletend AND INDEX(saletend.internal,"90day") <> 0 THEN
    DO:
      FIND customer-r EXCLUSIVE-LOCK
        WHERE customer-r.cust-no = sale.cust-no NO-ERROR.
      IF AVAILABLE customer-r THEN customer-r.cal-int-type = NO.
    END.
    RUN ps/updt-custbal.p(buffer sale).
    FIND customer OF sale NO-LOCK NO-ERROR.
    RUN sl/cr-saledue.p(buffer sale).
    RUN ps/upd-giftcert.p(buffer sale).
    IF sale-invoice-req(sale.link-sale) OR tShipDirect THEN   /** for new shipto info ***/
      RUN ps/set-lywy-shipto.p(sale.link-sale).
    RUN ps/unvoid-sa.p(buffer sale).
    IF sale.credit-limit <> 0  /*** UPDATE CUSTOMER'S CREDIT/RENT LIMIT ***/
      OR sale.rent-limit <> 0 THEN RUN ps/update-limits.p (BUFFER sale).
    RUN ps/special-flags.p(sale.link-sale). /* UPDATE customer-d FLAGS */
    DEFINE VARIABLE t-tndamt AS DECIMAL.
    DEFINE VARIABLE tendnum  LIKE saletend.tend-no INIT 0.
    FIND sale WHERE sale.link-sale = salerec NO-ERROR.
    IF AVAILABLE sale THEN sale.dt-due = t-dt-enter.
    salrec = RECID(sale).

    /* AR Charge on a Installment or Interest Free customer with
      previous balance of zero should reset to Revolving */
    IF is-archarge(sale.link-sale) = YES
      THEN RUN ps/reset-to-revo.p (INPUT sale.link-sale).

    FIND order WHERE order.link-order  = s-link-order NO-ERROR.
    IF order.order-no BEGINS "rs" OR order.order-no BEGINS "ro" THEN
    DO:
      IF order.rent-code = "school" AND order.dt-due < TODAY THEN
      DO:
        /**** fully discounted should allow advance of due date ***/
        FIND FIRST saletend OF sale NO-LOCK WHERE NOT saletend.void
          AND saletend.tend-amt > 0 NO-ERROR.
        IF NOT AVAILABLE saletend THEN
        DO:
          DEFINE VARIABLE tlamt  AS DECIMAL.
          DEFINE VARIABLE tldisc AS DECIMAL.
          FOR EACH sale-i OF sale NO-LOCK
            WHERE sale-i.sku-no > 0 AND sale-i.sku-no < 9999990
            AND sale-i.item-type = "RP":
            tlamt = tlamt + sale-i.retail.
            tldisc = tldisc + sale-i.disc-amt.
          END.
          IF tlamt <> 0 AND abs(tldisc) = tlamt THEN
            order.dt-due = t-dt-enter.
          ELSE t-dt-enter = order.dt-due.
        END.
        /* take school contract off EasyPay if left owing task 7330
       and set sku-9999999 reason-code = 0 to indicate this transaction*/
        FIND sale-i OF sale WHERE sale-i.sku-no = 9999999 NO-ERROR.
        IF AVAILABLE sale AND sale-i.after-value > 0 THEN
        DO:
          /* contract is partially or fully wheeled so check v-trans */
          FIND FIRST v-trans WHERE v-trans.sku-no > 0
            AND v-trans.sku-no < 9999990 AND v-trans.rent-rate <> 0
            AND v-trans.estat <> "O" NO-ERROR.
          IF NOT AVAILABLE v-trans THEN  /* fully wheeled  */
            ASSIGN
              chg-code           = 0 /* from entry"*/
              order.charge-code  = 0
              sale-i.reason-code = STRING(order.charge-code).
        END.
      END.
      order.dt-due = t-dt-enter.
    END.
    FIND customer NO-LOCK WHERE customer.cust-no = order.cust-no.

    IF order.int-status = "create" THEN
    DO:
      IF t-funct-name = "loan.create" THEN
        ASSIGN
          chg-code          = 0
          order.charge-code = 0
          order.loc-receive = "".
      IF s-issue = ? THEN s-issue = TODAY.
      ASSIGN
        ordstatus         = order.int-status
        order.int-status  = ""
        order.dt-created  = s-issue

        order.dt-due      = s-dt-return
        order.dt-due      = IF f9active AND p-rent-code BEGINS "re"
                          THEN s-dt-return
                          ELSE t-dt-enter
        order.cust-no     = customer.cust-no
        order.reminders   = t-reminder
        order.tax-collect = t-taxcollect.
      IF order.order-no BEGINS "RO" THEN /* task 2144 */
        order.dt-prepaymt = t-dt-enter.
    END.
    /* NEVER STORE A DEFERRED EASYPAY STATUS IN loc.receive */
    IF chg-code <> 0 THEN
    DO:
      FIND cust-charge NO-LOCK
        WHERE cust-charge.cust-no = order.cust-no
        AND cust-charge.charge-code = chg-code NO-ERROR.
      IF AVAILABLE cust-charge AND cust-charge.tend-code <> "DEF" THEN
      DO:
        tloc-receive = chg-code.
        order.loc-receive = STRING(tloc-receive, "9999").
      END.
    END.
    ASSIGN
      order.rent-code   = p-rent-code
      order.charge-code = chg-code
      order.terms       = "change"
      order.reminders   = t-reminder
      order.tax-collect = t-taxcollect
      order.shipDirect  = tShipDirect.
    /* if prepayday > 0 and prepayday < 31
      and prepayday <> int(day(order.dt-prepaymt)) then
      order.dt-prepaymt = date(month(today),prepayday,year(today)). *****/
    /*Restrict to only if tracking isnt available, else can use rental inquiry*/
    IF order.shipDirect AND NOT CAN-FIND(FIRST OrderTracking OF order)
      THEN RUN ps/ship-to-tracking.p(order.link-order).
    FIND saleinfo NO-LOCK
      WHERE saleinfo.link-sale = string(RECID(register)) NO-ERROR.
    FIND sale-i OF sale WHERE sale-i.sku-no = 9999999 NO-ERROR.
    IF AVAILABLE saleinfo THEN
      ASSIGN
        order.cust-order-no      = saleinfo.po-no
        order.invoice-comment[1] = saleinfo.comment[1].
    IF order.cust-order-no = "" AND order.po-no <> "" THEN
      order.cust-order-no = order.po-no. /* some EasyPay not receiving */
    IF AVAILABLE sale-i AND NOT t-hold THEN
    DO:
      IF order.cust-order-no <> "" THEN
        ASSIGN
          sale-i.line-desc[4] = order.invoice-comment[1] + "   " + order.cust-order-no.
      ELSE sale-i.line-desc[4] = order.invoice-comment[1].
    END.
    ELSE IF t-hold AND AVAILABLE sale-i THEN
      DO:
        sale-i.line-desc[4] = pickUpBy.
      END.
    /* may come back with a changed due date undoing status of order by
       leaving an item with money still owed , so check items ***/
    DEFINE VARIABLE tempdiscount AS DECIMAL INIT 0 NO-UNDO.
    IF NOT order.order-no BEGINS "rs" THEN
      FOR EACH v-trans WHERE RECID(v-trans) <> v_rec AND NOT v-trans.void:
        tempdiscount = tempdiscount + v-trans.retail.
        /* is this a problem line ??? */
        IF v-trans.item-status = "OWING" OR
          (v-trans.rent-owed <> 0 AND v-trans.estat <> "B" AND
          NOT order.rent-code BEGINS "re")
          THEN s-co-complete = NO.
        /* reset item-type when item finally returned */
        IF v-trans.item-status = "RETURN" THEN v-trans.item-type = "RR".
      END.
    ELSE IF order.order-no BEGINS "rs" THEN
      DO:
        FIND FIRST v-trans WHERE v-trans.item-status = "OWING" NO-ERROR.
        IF AVAILABLE v-trans THEN
        DO:
          s-co-complete = NO.
        END.
        FOR EACH v-trans WHERE v-trans.estat = "C":
          v-trans.estat = "".
        END.
      END.
    IF order.discount > 0 THEN
    DO:  /* use trans to reduce remaining discount*/
      IF tempdiscount >= 0 THEN
        order.discount = order.discount - tempdiscount.
      IF order.discount < 0 THEN order.discount = 0.
    END.
    IF order.rent-code BEGINS "re" THEN
      t-round = YES.
    IF s-co-complete THEN ASSIGN
        order.invoice-comment[2] = ""
        order.int-status         = "picked up".
    IF t-hold THEN
    DO:
      FIND hold-order WHERE hold-order.link-order = t-hold-link NO-ERROR.
      IF AVAILABLE hold-order THEN
        ASSIGN
          hold-order.int-status = "picked up"
          hold-order.close-flag = YES.
      FIND order WHERE order.link-order  = s-link-order NO-ERROR.
    END.

    /* before assigning dt-due, reset fields if dt-due will change. */

    IF NOT f9active AND order.dt-due <> t-dt-enter THEN
    DO:
      ASSIGN
        order.last-notice#   = 0
        order.dt-last-notice = ?.
    END.
    ASSIGN
      order.dt-due    = IF f9active AND p-rent-code BEGINS "re"
      THEN s-dt-return ELSE t-dt-enter
      order.rent-code = p-rent-code.


    FIND sale WHERE sale.link-sale = salerec NO-ERROR.
    IF AVAILABLE sale THEN ASSIGN sale.dt-due     = order.dt-due
        /* may have picked up another order. */
        sale.link-order = order.link-order.
    /* we do not create an order-i for paid items like drum sticks */
    FIND v-trans WHERE v-trans.sku-no = 0000098 NO-ERROR.
    IF AVAILABLE v-trans THEN order.nsf-fee = order.nsf-fee - v-trans.retail.

    /* if t-allprotect then close protection  */
    /* BUT MIGHT BE wheeled with a partial amount paid */

    IF t-allprotect OR s-co-complete THEN
    DO:
      t-allprotect = closeProtect(order.order-no, order.cust-no).
    END.
    ELSE
    DO:
      FIND FIRST sale-i OF sale NO-LOCK WHERE sale-i.sku-no = 23 AND
        sale-i.item-type = "rb" NO-ERROR.
      IF AVAILABLE sale-i THEN
      DO:
        IF assignProtect (order.order-no, order.cust-no, sale-i.retail) THEN.
      END.
    END.

    FOR EACH v-trans WHERE RECID(v-trans) <> v_rec
      AND v-trans.item-type <> "tx" AND NOT v-trans.void
      AND v-trans.sku-no < 9999990:
      FIND order-i OF order WHERE order-i.item-no = v-trans.item-no
        AND order-i.item-type = "ri" NO-ERROR.
      /* need cleaner code here */
      IF v-trans.estat = "B" OR v-trans.estat = "P" THEN
        IF NOT AVAILABLE order-i AND v-trans.estat = "p" THEN NEXT.
      IF v-trans.item-type = "rb" AND v-trans.estat = "p"
        AND (v-trans.sku-no = 23 OR v-trans.sku-no = 28) THEN NEXT.
      /* patch to get the date code */
      IF v-trans.date-code = "" AND v-trans.old-item = NO THEN
      DO:
        FIND inv-locsrl NO-LOCK
          WHERE inv-locsrl.serial-no = v-trans.serial-no
          AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
        IF AVAILABLE inv-locsrl THEN v-trans.date-code = inv-locsrl.date-code.
      END.

      IF NOT AVAILABLE order-i THEN
      DO:
        CREATE order-i.   /* patch 0 rent rate exchange in schools */
        IF v-trans.disc-amt = ? THEN v-trans.disc-amt = 0.
      END.
      /**** NEW *****/
      IF order.rent-code = "school" AND v-trans.dayrate > v-trans.retail
        AND v-trans.estat = "O" THEN
        ASSIGN v-trans.item-status = "OWING" v-trans.item-type   = "ri".
      IF order.rent-code = "billing" AND v-trans.item-status = "RETURN" THEN
        V-TRANS.ITEM-TYPE = "RR".

      v-trans.pos-disc = 0. /* oct 28-15 */
      BUFFER-COPY v-trans TO order-i.
      IF order-i.link-rent = 0 THEN order-i.link-rent = order-i.item-no.
      ASSIGN
        order-i.PRODUCT-NO   = IF v-trans.product-no = "Returned/Owed" THEN
                             order-i.product-no ELSE v-trans.product-no
        order-i.LINE-DESC[1] = IF v-trans.LINE-DESC[1] BEGINS "RH" THEN ""
                             ELSE v-trans.LINE-DESC[1]
        order-i.ITEM-TYPE    = IF v-trans.item-status = "OWING" THEN "RI"
                             ELSE IF v-trans.item-status = "lreturn" THEN "rr"
                             ELSE v-trans.ITEM-TYPE
        order-i.DT-RENTED    = IF is-loan AND f9active THEN s-dt-return
                                 /* 1st payment is under loan system. */
                             ELSE IF is-loan AND order-i.extended = 0 AND
                               v-trans.retail <> 0 THEN TODAY
                             ELSE IF is-loan THEN order.dt-due
        ELSE v-trans.dt-rented  /*void needs to reinstate*/
        order-i.dt-loan      = v-trans.dt-loan
        order-i.DT-RETURN    = IF order-i.dt-return <> ? THEN order-i.dt-return
                             ELSE IF v-trans.estat = "" THEN ?
                             ELSE IF v-trans.estat <> ""
                             AND v-trans.estat <> "e"
                               AND v-trans.estat <> "l"  THEN TODAY
                             ELSE order.dt-due
        order-i.ITEM-STATUS  = IF v-trans.item-status = "LBUY" THEN "BUY"
                           ELSE IF v-trans.item-status = "LRETURN" THEN
                             "RETURN"
                           ELSE IF v-trans.item-type = "re" THEN "EXCHANGE"
                           ELSE v-trans.ITEM-STATUS
        order-i.AMT-RECEIVED = IF v-trans.estat = "b" OR v-trans.estat = "r"
                             THEN v-trans.AMT-RECEIVED
                             ELSE 0.   /* dont record usage in exchanges */
      /* except now for school contracts. */
      IF order.order-no BEGINS "rs" AND order-i.item-status = "owing" THEN
      DO:
        order-i.rent-owed = order-i.rent-owed - v-trans.retail.
      END.

      /***** NEW ITEMS ADDED ON CONTRACT ***/
      IF v-trans.old-item = NO THEN
      DO:
        IF v-trans.estat = "e" THEN
        DO:
          IF order.rent-code = "school" THEN
          DO:
            FIND b-trans WHERE b-trans.item-no = v-trans.link-rent NO-ERROR.
            IF AVAILABLE b-trans THEN ASSIGN
                order-i.extended     = b-trans.extended + v-trans.retail
            + v-trans.summer-chg
                order-i.amt-received = order-i.extended.
          END.
          ELSE
          DO:
            /* case testrollback exchange rolls back before start of old item
              this section works perfectly for a full rollback earlier then
              new item start date FEB-26-2016 */

            FIND sale-i OF sale NO-LOCK
              WHERE sale-i.link-rent = order-i.item-no NO-ERROR.
            order-i.extended
            = order-i.extended + sale-i.retail + sale-i.disc-amt.
            order-i.disc-amt = order-i.disc-amt - sale-i.disc-amt.
            order-i.amt-received = order-i.extended .
          END.
        /******** temporary block while testing rollback
                 /* case of same day exchange task mar 11th 2015 */
         find b-trans where b-trans.item-no = v-trans.link-rent no-error.
         if avail b-trans and b-trans.dt-rented = v-trans.dt-rented
         and b-trans.disc-amt <> 0 then

         assign
           v-trans.disc-amt = b-trans.disc-amt
           v-trans.pos-disc = v-trans.pos-disc - b-trans.disc-amt
           order-i.disc-amt = v-trans.disc-amt.
         if order-i.disc-amt = ? then order-i.disc-amt = 0.
         assign
           order-i.extended = v-trans.extended + v-trans.retail
           + v-trans.pos-disc + order-i.rent-credit
           order-i.amt-received = order-i.extended .


       end. *******/
        END.
        ELSE
        DO:
          FIND sale-i OF sale NO-LOCK
            WHERE sale-i.link-rent = order-i.item-no NO-ERROR.
          IF AVAILABLE sale-i THEN
            ASSIGN
              order-i.EXTENDED = sale-i.retail + sale-i.disc-amt.
          /* block already set in v-trans.disc-amt. */
          order-i.disc-amt = order-i.disc-amt - sale-i.disc-amt.
        END.
        /* all cases patch for create value. */
        IF order-i.create-value = 0 AND order-i.orig-value <> 0 THEN
        DO:
          FIND sale-i OF sale NO-LOCK
            WHERE sale-i.link-rent = order-i.item-no NO-ERROR.
          IF AVAILABLE sale-i AND sale-i.before-value <> 0
            AND sale-i.before-value <> order-i.orig-value THEN
            order-i.create-value = sale-i.before-value.
          ELSE IF AVAILABLE sale-i THEN
              order-i.create-value = order-i.over-retail.
        END.
      END.
      ELSE IF v-trans.old-item = YES THEN
        DO:
          FIND sale-i OF sale NO-LOCK
            WHERE sale-i.link-rent = order-i.item-no NO-ERROR.
          /* SHOULD ALWAYS WORK GOING FORWARD */
          IF sale-i.item-type = "rb" THEN
            ASSIGN order-i.extended = sale-i.retail.
          ELSE IF sale-i.item-type = "rr"
              AND order-i.item-status = "return" THEN
            DO:
              IF  order.rent-code = "school" THEN
              DO:

                IF sale-i.retail = 0    /* mar 18 task 2575 */
                  AND v-trans.extended <> v-trans.amt-received THEN
                  v-trans.extended = v-trans.amt-received.
                ASSIGN
                  order-i.extended = v-trans.extended.
              END.
              ELSE
              DO:   /* task 2358*/
                ASSIGN
                  order-i.extended = v-trans.origextend + sale-i.retail + sale-i.disc-amt
                  order-i.disc-amt = order-i.disc-amt - sale-i.disc-amt.
                /*partial*/
                IF order-i.serial-no BEGINS "sku#" /* ms206 mar24-2015*/
                  AND order-i.link-rent <> order-i.item-no THEN
                DO:
                  order-i.amt-received = order-i.orig-amount.
                  order-i.orig-amount = v-trans.origextend. /* should fix ps-void*/
                  IF t-funct-name = "loan.create" AND sale-i.item-type = "rr" AND
                    sale-i.qty-from-new < 0 THEN
                  DO:  /* task 5840 */
                    FIND b-sale-i OF sale
                      WHERE RECID(b-sale-i) = recid(sale-i) NO-ERROR.
                    IF AVAILABLE b-sale-i THEN b-sale-i.link-item = order-i.link-rent.
                    RELEASE b-sale-i.
                  END.
                END.
              END.
            END.
            ELSE ASSIGN        /* add summ-chg for yearly contracts */
                order-i.extended = order-i.extended + sale-i.retail + sale-i.disc-amt
        + sale-i.summer-chg
                order-i.disc-amt = order-i.disc-amt - sale-i.disc-amt.
          /* loan n205840 */
          IF v-trans.item-status = "owing" THEN
          DO: .
            ASSIGN
              order-i.EXTENDED = v-trans.origextend
        + v-trans.retail + v-trans.pos-disc
              order-i.dayrate  = v-trans.dayrate - v-trans.retail + v-trans.pos-disc.
            IF order-i.mthRate = 0 THEN order-i.mthRate = order-i.dayrate.
            ELSE
              order-i.mthRate = v-trans.mthRate - v-trans.retail. /* School only*/
          END.
        END.
      /* patch for all rentals *****/
      order-i.orig-amount = v-trans.extended.

      IF v-trans.old-item = NO THEN
      DO:
        order-i.create-value = v-trans.create-value.
        order-i.orig-rentrate = v-trans.orig-rentrate.
        order-i.over-retail = v-trans.over-retail.
      END.

      IF order-i.item-type = "rb" AND v-trans.estat = "p" THEN
        order-i.item-status = "BUYS".

      ELSE IF order-i.item-type = "rb" AND v-trans.estat = "B" THEN
          order-i.item-status = "BUY".
      FIND order-s OF order-i WHERE order-s.item-no = order-i.item-no NO-ERROR.
      IF NOT AVAILABLE order-s THEN
      DO:
        CREATE order-s.
        ASSIGN
          order-s.link-order = order.link-order
          order-s.item-no    = v-trans.item-no
          order-s.serial-no  = v-trans.serial-no
          order-s.line-no    = v-trans.qty-new.
      END.
      /***************/
      /* patch */
      IF order-i.item-type = "RI" AND order-i.item-status <> "owing"
        THEN order-i.dt-return = ?.
      IF p-rent-code BEGINS "re" THEN
      DO:
        IF f9active AND NOT is-loan THEN
        DO:
          ASSIGN
            order-i.dt-rented = order.dt-created
            order-i.dt-return = ?.
        /* order-i.rent-credit = order-i.extended * - 1  TASK 4663
         order-i.extended = 0.   /* leave blank order.dt-due. */ */
        END.
      END.
      ELSE IF NOT p-rent-code BEGINS "re" THEN
          IF p-status = "create" THEN order-i.dt-rented = s-issue.
      order-i.dt-LastStatusChanged = NOW.
    END.

    FIND sale NO-LOCK WHERE RECID(sale) = salrec NO-ERROR.
    IF AVAILABLE sale THEN
    DO:
      DEFINE VARIABLE t-num AS INTEGER INIT 1.
      /* order-i.int-status has been now set to "" */
      FOR EACH sale-i OF sale :           /* re-number the sale-i. */
        /* this is a patch when f4 out of exchange across departments.
          The problem is that I don't no how problem occurred and whether
          or not it affects 'owing' status of an item */
        /* why the find without a no-lock */
        FIND sale-s OF sale-i NO-ERROR.
        FIND order-i NO-LOCK OF order
          WHERE order-i.item-no = sale-i.link-rent
          AND NOT order-i.void NO-ERROR.
        IF AVAILABLE order-i AND order-i.dt-return <> ?
          AND sale-i.dt-return = ? THEN
        DO:
          sale-i.dt-return = order-i.dt-return.

          IF order-i.item-type = "rr" AND
            sale-invoice-req(sale.link-sale) = YES
            THEN sale-i.invoice-no =
              get-last-unapplied-invoice(sale.link-sale, sale.link-order,
              OUTPUT sale-i.pd-link-sale).

        END.

        IF AVAILABLE order-i AND order-i.item-type = "rb" THEN
        DO:
          IF sale-i.used-flag = "" AND sale-i.item-type = "rb" THEN
          DO:
            sale-i.used-flag = "U".
          END.
        END.
        ELSE IF NOT AVAILABLE order-i AND sale-i.item-type = "rb" AND
            (sale-i.qty-from-new = 0 OR sale-i.qty > sale-i.qty-from-new)
            THEN sale-i.used-flag = "U".
        /* process from a hold contract */
        /* INVENTORY CHANGES FROM A HOLD CONTRACT  */
        IF sale-i.item-no = 903 THEN NEXT.

        RUN RentUpdateInventory.p(buffer sale-i, order.link-order, t-holdit).
        FIND v-trans WHERE v-trans.item-no = sale-i.item-no NO-ERROR.
        IF AVAILABLE v-trans AND v-trans.void AND
          v-trans.line-desc[1] BEGINS "rh" THEN sale-i.info-item = YES.
        /* task 5681 */
        IF p-status = "create" AND p-rent-code = "billing" THEN
        DO:
          IF sale-i.sku-no = 28 THEN sale-i.after-rate = 1.
          ELSE IF sale-i.after-rate <> 0 THEN
              sale-i.after-rate = sale-i.retail / sale-i.qty.
        END.

        IF NOT sale-i.serial-no BEGINS "sku#" AND sale-i.item-type = "rr"
          AND (INDEX(p-list,sale-i.serial-no) <> 0
          OR INDEX(p-list, "ALL") <> 0 ) THEN
        DO:
          sale-i.qty-from-new = 1.
          RUN rn-del-invloc.p(buffer sale-i, order.loc-code).
        END.
        ELSE IF sale-i.serial-no BEGINS "sku#" AND sale-i.item-type = "rr"
            AND (INDEX(p-list,sale-i.serial-no) <> 0
            OR INDEX(p-list, "ALL") <> 0 ) THEN
          DO:
            sale-i.qty-from-new = abs (v-trans.qty).
            RUN rn-del-invloc.p(buffer sale-i, order.loc-code).
          END.
        IF sale-i.item-no = 903 THEN
        DO:
          sale-i.sku-no = 23.
          sale-i.serial-no = "SKU#00000023".
          IF AVAILABLE sale-s AND sale-s.item-no = 903 THEN
            sale-s.serial-no = sale-i.serial-no.
          IF sale-i.retail = 0 THEN
          DO:
            IF AVAILABLE sale-s THEN
              DELETE sale-s.
            IF AVAILABLE sale-i THEN
              DELETE sale-i.
          END.
        END.
      END. /* END OF INVENTORY UPDATE BY SALE-I **/

      FIND sale EXCLUSIVE-LOCK WHERE RECID(sale) = salrec NO-ERROR.
      IF AVAILABLE sale THEN
      DO:
        ASSIGN
          sale.void    = NO
          sale.void-by = 0.
        FIND customer OF sale NO-LOCK NO-ERROR. /* update discount-level */
        IF AVAILABLE customer AND customer.discount-level <> 0 THEN
          sale.CustDiscountLevel = customer.discount-level.
        RUN rn-authorized.p(buffer sale).
        /* 9220# Moved ps-pos-cus.p from line 8312 to here. ps-pos-cus.p
           must be called after the sale is unvoided. */
        IF AVAILABLE customer
          THEN RUN ps-pos-cus.p(RECID(sale), RECID(customer), "rental"). /* task 7464*/

      END.
      FIND sale NO-LOCK WHERE RECID(sale) = salrec NO-ERROR.

      FIND customer  WHERE customer.cust-no = order.cust-no NO-ERROR.
      IF AVAILABLE customer
        THEN RUN sl/customer-tn.p(buffer customer, INPUT "rn").
      RUN ps/xfer-sale.p(buffer sale).
      FIND order WHERE order.link-order = s-link-order NO-ERROR.
      RELEASE customer.

      IF order.order-no BEGINS "ro" OR order.order-no BEGINS "o" THEN
      DO:
        RUN ro-createinfo.p(buffer order, buffer sale).
        /* no longer needed if stored in order-i.over-retail
         but what should be stored is the origvalue from which rto-orig-value
         is derived not what is on the inv-locslr.
         Should never be re-run again */
        RUN rnUpdtRtoCost.p(buffer order, buffer sale).
      END.
    END.
    /* test if left in an owing state and close protection if it is */
    DEFINE VARIABLE testowing AS LOG INIT NO NO-UNDO.
    IF AVAILABLE order AND order.rent-code = "regular" THEN
    DO:
      FOR EACH order-i OF order NO-LOCK WHERE NOT order-i.void:
        IF order-i.item-type = "ri" AND order-i.rent-rate <> 0
          AND order-i.item-status <> "owing" THEN testowing = YES.
      /* one item exists to allow charges against */
      END.
      IF testowing = NO THEN
        testowing = closeProtect(order.order-no, order.cust-no).
    END.

    IF AVAILABLE sale THEN
      FIND sale-i OF sale WHERE sale-i.sku-no = 9999999
        USE-INDEX link-sale NO-ERROR.
    IF AVAILABLE sale-i THEN
    DO:
      IF order.charge-code <> 0 AND order.rent-code BEGINS "re" THEN
        sale-i.reason-code = STRING(order.charge-code).
      sale-i.pd-dt-due = order.dt-prepaymt.  /* easypay prepayment date */
      /* calculate the wheel amount if it exists and store it. */
      DEFINE VARIABLE t-dt-due  AS DATE    NO-UNDO.
      DEFINE VARIABLE t-owed    AS DECIMAL NO-UNDO.
      DEFINE VARIABLE t-tax     AS DECIMAL NO-UNDO.
      DEFINE VARIABLE t-wheel   AS LOG.
      DEFINE VARIABLE t-sum-chg AS DECIMAL NO-UNDO.

      t-dt-due = TODAY. /* added this line as t-dt-due when ? calculates
           until due date which does not include late charge and deposit ***/
      RUN rent-due.p(buffer order, INPUT-OUTPUT t-dt-due,  YES, "",
        OUTPUT t-owed, OUTPUT t-tax, OUTPUT t-wheel, OUTPUT t-sum-chg).
      /* should include late charge and deposit refund as of 03/15/05 */
      IF t-owed > 0 THEN sale-i.after-value = t-owed.
      IF order.rent-code = "school" THEN
      DO:
        IF CAN-FIND(FIRST order-i OF order NO-LOCK WHERE NOT order-i.void
          AND order-i.item-type = "ri" AND order-i.rent-rate <> 0
          AND order-i.item-status = "owing") THEN
        DO:
          t-owed = 0.
          FOR EACH order-i OF order NO-LOCK WHERE NOT order-i.void:
            IF order-i.item-type = "ri" AND order-i.rent-rate <> 0
              AND order-i.item-status = "owing" THEN
              t-owed = t-owed + order-i.dayrate.
          END.
        END.
        IF sale-i.after-value <> t-owed THEN sale-i.after-value = t-owed.
      END.
      IF sale-i.dt-return <> ? THEN
      DO:
        FIND promises WHERE promises.cust-no = order.cust-no
          AND promises.link-order = order.link-order NO-ERROR.
        IF AVAILABLE promises
          THEN promises.exp-dt = ?. /* set as promise is fulfilled */
      END.
    END.
    RUN TotalCoupons.p(buffer sale,"Update").
    RUN chk-totalrents.p(order.cust-no).
    RUN chkOpenHoldChrge.p(order.cust-no, order.order-no, buffer sale).
    RUN chkRnStatus.p(buffer order, buffer sale).
    RUN setregister.
  END.
END.

/* @(#) rnproc-setregister.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-setregister.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE setregister:
  DO TRANSACTION:
    FIND register exclusive
      where register.reg-no = gwkreg
      and register.loc-code = t-loc-code no-error.
    IF AVAILABLE register THEN
      ASSIGN register.last-tran# = t-transno.
  END.
  RELEASE register.
  FIND register NO-LOCK WHERE register.reg-no = gwkreg  /* flushes buffer */
    AND register.loc-code = t-loc-code NO-ERROR.
END.

/* @(#) rnproc-createsu.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-createsu.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE createsu:
  DEFINE VARIABLE ordstatus AS CHARACTER.
  FIND sale WHERE sale.link-sale = salerec NO-ERROR.
  IF AVAILABLE sale THEN
  DO TRANSACTION:
    FOR EACH saletend OF sale :
      saletend.void = YES.
    END.
    FOR EACH sale-i OF sale:
      sale-i.void = YES.
      sale-i.info-item = YES.
      IF sale-i.warranty-link <> 0 THEN sale-i.link-item = sale-i.warranty-link.
      /* if a hold exists then store contract number */
      /*** ONLY WORKS ON FIRST SUSPEND must re-instate ***/
      IF t-hold AND sale-i.sku-no = 9999999 THEN
      DO:
        FIND order NO-LOCK WHERE order.link-order = t-hold-link NO-ERROR.
        IF AVAILABLE order THEN ASSIGN
            sale-i.line-desc[1] = order.order-no
            sale-i.line-desc[4] = order.invoice-comment[1].
      END.
    END.
    sale.void = YES.
  END.
  FIND order WHERE order.link-order = s-link-order NO-ERROR.
  DO TRANSACTION:    /* since a loan can be brought over to reg rents */
    order.rent-code = p-rent-code.
    /* order.charge-code = chg-code. task 6493*/
    IF order.int-status = "create" AND t-funct-name = "loan.create" THEN
      ASSIGN order.terms = "lcreate".
    ELSE IF t-funct-name = "loan.create" THEN ASSIGN order.terms = "l".
      ELSE IF order.int-status = "create" AND t-funct-name <> "loan.create" THEN
          ASSIGN order.terms = "create".
    IF order.int-status = "create" THEN
    DO:
      IF s-issue = ? THEN s-issue = TODAY.
      ASSIGN
        ordstatus        = order.int-status
        order.int-status = ""
        order.dt-created = s-issue
        order.dt-due     = t-dt-enter
        order.cust-no    = customer.cust-no.
    END.
    order.cust-order-ref = t-funct-name.
    order.rent-code = p-rent-code.
    IF p-rent-code <> "school" THEN
      order.charge-code = chg-code. /* task 6493 */
  END.
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  /******* BECAUSE V-TRANS MAY HAVE BEEN CHANGED AT THE DATE SCREEN THE VERSION
         COPIED AT THE END OF THE ITEM SCREEN IS RE-INSTATED. ***********/
  FOR EACH v-trans :
    DELETE v-trans.
  END.
  FOR EACH item-scr:    /* this copy was made before the date screen */
    CREATE v-trans.
    BUFFER-COPY item-scr TO v-trans.
  END.
  /* we do not create an order-i for paid items like drum sticks */
  FOR EACH sale-i OF sale :
    FIND v-trans WHERE v-trans.item-no = sale-i.item-no NO-ERROR.
    IF AVAILABLE v-trans THEN BUFFER-COPY v-trans
        EXCEPT v-trans.description TO sale-i.
    IF AVAILABLE v-trans AND v-trans.old-item = YES THEN
      ASSIGN  /* item is from old exchange */
        sale-i.link-rent = v-trans.item-no
        sale-i.link-item = v-trans.item-no.
    IF AVAILABLE v-trans AND
      v-trans.sku-no <> 9999999 AND v-trans.sku-no > 0 THEN
    DO:
      sale-i.description = v-trans.description.
      IF v-trans.old-item = NO AND v-trans.dt-loan <> ? THEN
        sale-i.dt-loan = v-trans.dt-loan.
    END.
  END.
END PROCEDURE.

/* @(#) rnproc-setupframef.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-setupframef.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE setupframef:   /* sets up browser view and edit frame on top */
  DEFINE INPUT PARAMETER p-refresh AS LOG NO-UNDO.
  DEFINE INPUT PARAMETER p-enable AS LOG NO-UNDO.
  VIEW FRAME brws-frame.
  APPLY "entry" TO cust-browse IN FRAME brws-frame.
  IF p-refresh THEN RUN screenrefresh.
  RUN reopenquery.
  HIDE FRAME fr-descrip NO-PAUSE.
  DISPLAY e WITH FRAME f.
  IF p-enable THEN ENABLE e WITH FRAME f ROW bl-row + offset COL 4.
  ELSE ENABLE e WITH FRAME f.
  APPLY "entry" TO e IN FRAME f.
END.

/* @(#) rnproc-createsale.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-createsale.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE createsale:

  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
  FIND customer NO-LOCK WHERE customer.cust-no  = order.cust-no NO-ERROR.
  FIND FIRST customer-r OF customer NO-LOCK NO-ERROR.
  IF AVAILABLE customer-r THEN ASSIGN arno = customer-r.ar-no.
  ELSE ASSIGN arno = 0.  /* set to 0 for non-charge */
  IF s-issue < TODAY AND p-status = "create"
    AND NOT p-rent-code BEGINS "re" THEN f9active = YES.
  FIND sale EXCLUSIVE-LOCK
    WHERE sale.link-sale = salerec NO-ERROR.
  IF AVAILABLE sale THEN sale.void = YES. /* delete sale. */
  DEFINE VARIABLE t-tran AS INTEGER.
  IF f9active THEN
  DO:
    FIND LAST sale WHERE sale.loc-code = t-loc-code
      AND sale.reg-no = "back" USE-INDEX loc-reg-tran NO-LOCK NO-ERROR.
    IF AVAILABLE sale  THEN t-tran = sale.trans-no + 1.
    ELSE t-tran = 1.
  END.
  CREATE sale.
  ASSIGN
    sale.loc-code     = t-loc-code
    sale.dt-trans     = TODAY
    sale.cust-no      = order.cust-no
    sale.link-order   = order.link-order
    sale.link-sale    = t-linkno
    sale.dt-due       = IF f9active AND p-rent-code BEGINS "re" THEN s-dt-return
                   ELSE IF f9active THEN t-dt-enter
                   ELSE t-dt-enter
    sale.source-loc   = t-loc-code
    sale.ar-no        = 0   /* was  arno  */
    sale.tm-trans     = TIME
    /* integer(substring(order.order-no,3,8)) */
    sale.sale-type    = "RN"
    sale.co-code      = "l"
    sale.trans-no     = IF f9active THEN t-tran ELSE t-transno
    sale.reg-no       = IF f9active THEN "BACK" ELSE gwkreg
    sale.void         = IF f9active THEN NO ELSE YES
    sale.void-by      = IF f9active THEN 0 ELSE sale.trans-no
    sale.jrnl-control = "l"
    sale.empl-no      = t-empl-id
    sale.custInStore  = custInStore
    sale.authorized   = IF f9active THEN STRING(s-journal) + string(gwkreg)
                      ELSE ""
    sale.ar-discount  = YES
    salerec           = sale.link-sale.
  sale.journal-no = IF F9ACTIVE THEN ? ELSE s-journal.
  IF t-hold THEN ASSIGN
      sale.cashier = sale.empl-no
      sale.empl-no = t-holdEmpl.
/* global as journal incremented */
END.

/* @(#) rnproc-createsalei.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-createsalei.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE createsalei:
  DEFINE VARIABLE renum          AS INTEGER INIT 1.
  DEFINE VARIABLE t-cost         AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-datecode     LIKE inv-locsrl.date-code.
  DEFINE VARIABLE t-qty-from-new AS INTEGER NO-UNDO.
  DEFINE VARIABLE t-use          AS LOG     NO-UNDO.
  DEFINE VARIABLE t-yorkville    AS LOG     NO-UNDO.

  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
  FIND sale OF order NO-LOCK WHERE sale.link-sale = salerec.
  FIND FIRST sale-i OF sale NO-LOCK NO-ERROR.
  IF AVAILABLE sale-i THEN
  DO:
    FOR EACH sale-i OF sale:
      DELETE sale-i.
    END.
    FOR EACH sale-s OF sale:
      DELETE sale-s.
    END.
  END.
  IF order.int-status = "create" AND order.order-no BEGINS "ro" THEN
  DO:
    FOR EACH v-trans WHERE v-trans.rent-rate <> 0 :
      IF v-trans.old-item = NO AND v-trans.rent-rate <> 0 THEN
        v-trans.after-rate = v-trans.rent-rate.
    END.
  END.

  FOR EACH v-trans WHERE v-trans.item-status <> "RE":
    IF v-trans.sku-no = 28 AND (v-trans.estat = "P"
      OR v-trans.item-type = "rb") THEN NEXT. /*don't print here */
    IF v-trans.sku-no = 9999995 AND v-trans.retail = 0 THEN NEXT.
    IF v-trans.sku-no = 9999994 AND v-trans.retail = 0 THEN NEXT.
    IF v-trans.void AND NOT v-trans.line-desc[1] BEGINS "RH" THEN NEXT.
    IF RECID(v-trans) = v_rec AND v-trans.sku-no = 0 THEN NEXT.
    t-use = NO.
    t-datecode = "".
    t-cost = 0.
    t-qty-from-new = 0.
    IF NOT v-trans.serial-no BEGINS "SKU#" THEN
    DO:
      FIND inv-locsrl NO-LOCK
        WHERE inv-locsrl.serial-no = v-trans.serial-no
        AND inv-locsrl.sku-no = v-trans.sku-no NO-ERROR.
      IF NOT AVAILABLE inv-locsrl THEN
      DO:
        FIND vlocsrl WHERE vlocsrl.sku-no = v-trans.sku-no
          AND vlocsrl.serial-no = v-trans.serial-no NO-ERROR.
        IF AVAILABLE vlocsrl THEN
        DO:
          RUN im/get-cost.p(INPUT vlocsrl.sku-no, NO, OUTPUT t-cost).
          ASSIGN
            vlocsrl.cost   = t-cost /* assign backwards */
            t-datecode     = vlocsrl.date-code
            t-qty-from-new = 1.
        END.
      END.
      ELSE IF AVAILABLE inv-locsrl THEN
        DO:
          t-cost = get-current-cost(inv-locsrl.sku-no, inv-locsrl.serial-no).
          t-datecode = inv-locsrl.date-code.
          IF inv-locsrl.i-status = -1 AND inv-locsrl.doc-ref
            BEGINS order.order-no THEN
            t-qty-from-new = 1.
        END.
    END.
    ELSE
      RUN im/get-cost.p(INPUT v-trans.sku-no, NO, OUTPUT t-cost).
    /* patch code */

    IF order.rent-code = "school" AND v-trans.item-status = "owing"
      AND v-trans.finalextend = 0
      AND v-trans.rent-rate <> 0 THEN
      ASSIGN v-trans.item-type   = "rr" v-trans.item-status = "RETURN".
    IF v-trans.item-status = "owing" AND v-trans.rent-rate = 0
      AND v-trans.item-type = "rr" THEN v-trans.item-status = "return".
    /* patch because discount can occur on item screen or on buy screen */
    IF v-trans.estat = "p" THEN v-trans.item-type = "rb".
    IF v-trans.item-type = "rb" THEN
    DO:
      FIND order-i OF order NO-LOCK
        WHERE order-i.item-no = v-trans.item-no NO-ERROR.
      IF NOT AVAILABLE order-i THEN
      DO:
        v-trans.before-value = v-trans.create-value.
        v-trans.after-value = v-trans.orig-value.
      END.
      ELSE IF AVAILABLE order-i THEN
        DO:
          v-trans.before-value = order-i.orig-value.
          v-trans.after-value = v-trans.orig-value.
        END.
    END.

    CREATE sale-i.
    ASSIGN
      sale-i.date-code     = t-datecode
      sale-i.serial-no     = v-trans.serial-no
      sale-i.LINK-Sale     = sale.LINK-sale
      sale-i.ITEM-NO       = v-trans.item-no
      sale-i.SKU-NO        = v-trans.SKU-NO
      sale-i.VENDOR-CODE   = v-trans.VENDOR-CODE
      sale-i.PRODUCT-NO    = v-trans.product-no
      /* 1st line below need to set link-rent */
      sale-i.DESCRIPTION   = IF (v-trans.estat = "p" AND v-trans.old-item = NO)
                          THEN v-trans.description
                          ELSE IF is-loan THEN "LOAN " + order.order-no
                          ELSE IF (order.order-no BEGINS "ro"
                            OR order.order-no BEGINS "o")
                            THEN "RENT-OWN " + order.order-no
                          ELSE IF sale-i.item-no = 903 THEN ""
                          ELSE "RENTAL " + order.order-no
      sale-i.avg-cost      = t-cost
      sale-i.over-retail   = v-trans.create-value
      sale-i.QTY           = v-trans.qty
      sale-i.TAX-EXEMPT    = NO
      sale-i.MKDN-AMT      = 0 /* swapped w/ pos-mkdn apr24/03 */
      sale-i.POS-MKDN      = v-trans.POS-MKDN
      sale-i.DISC-AMT      = IF f9active THEN v-trans.disc-amt
                          ELSE v-trans.pos-disc
      /* sale-i.POS-DISC     = v-trans.POS-DISC */
      sale-i.LINE-DESC[1]  = v-trans.LINE-DESC[1]
      sale-i.LINE-DESC[2]  = v-trans.LINE-DESC[2]
      sale-i.LINE-DESC[3]  = v-trans.LINE-DESC[3]
      sale-i.LINE-DESC[4]  = v-trans.LINE-DESC[4]
      sale-i.ITEM-TYPE     = IF v-trans.item-type = "ri" THEN "rp"
                          ELSE v-trans.item-type
      sale-i.REASON-CODE   = v-trans.REASON-CODE
      sale-i.uom           = IF v-trans.item-status = "OWING"
                          /* patch as sometimes item gets marked */
                            AND v-trans.rent-rate <> 0 THEN "O"
                          ELSE ""
      sale-i.VOID          = v-trans.void
      sale-i.INFO-ITEM     = NO
      sale-i.TAX-COST      = NO
      /* below was today set back to t-dt-enter from today */
      sale-i.DT-RENTED     = IF f9active THEN s-issue ELSE
                          IF v-trans.old-item = NO THEN TODAY
                          ELSE v-trans.dt-rented
      /* the above had t-dt-enter ????? why ??? */
      sale-i.dt-return     = IF sale-i.item-type = "rp" THEN ?
                          ELSE v-trans.dt-return

      sale-i.rent-credit   =    /* REPLACE FOR COUPONS. */
                              IF v-trans.item-type = "rr" THEN 0
                            ELSE  v-trans.rent-credit
      sale-i.rent-owed     = v-trans.rent-owed
      sale-i.used-flag     = IF v-trans.estat <> "P" AND v-trans.estat <> "B" THEN                             "U" ELSE ""
      sale-i.TAXABLE-AMT   = v-trans.TAXABLE-AMT
      sale-i.LINK-ITEM     = IF sale-i.item-type = "RE"
                        THEN v-trans.item-no ELSE v-trans.LINK-ITEM
      sale-i.LINK-RENT     = IF sale-i.description BEGINS "rent"
                    OR sale-i.description  BEGINS "loan"
                    THEN v-trans.item-no
                    ELSE 0
      sale-i.qty-from-new  = IF t-qty-from-new <> 0 THEN t-qty-from-new
        ELSE IF sale-i.item-type = "rr"
          THEN v-trans.qty-new * -1
        ELSE v-trans.qty-new
      sale-i.summer-chg    = v-trans.summer-chg

      sale-i.before-value  = v-trans.before-value
      sale-i.after-value   = v-trans.after-value
      sale-i.before-rate   = v-trans.before-rate
      sale-i.after-rate    = v-trans.after-rate
      sale-i.disc-reason   = v-trans.disc-reason
      sale-i.discount-note = v-trans.discount-note
      sale-i.rate-no       = v-trans.rate-no
      sale-i.rate-reason   = v-trans.rate-reason.
    /* patch sep2012*/
    /* must pass through and set yes from f3 to zero out */
    IF F3BANDATTENDER = YES AND t-mincharge = 0 THEN
      sale-i.summer-chg = 0.
    IF order.rent-code = "School" THEN
    DO:
      IF sale-i.uom = "o" THEN
      DO:
        ASSIGN
          sale-i.item-type = "rr".
        IF v-trans.dt-return = ? THEN sale-i.dt-return = TODAY.
      END.
    END.

    IF sale-i.item-type <> "RB" AND sale-i.line-desc[4] BEGINS "buy" THEN
      ASSIGN
        sale-i.line-desc[4]  = ""
        v-trans.line-desc[4] = "".  /* block for order-i. */

    IF sale-i.after-value = 0
      AND order.order-no BEGINS "ro" AND v-trans.orig-value <> 0 THEN
    DO:
      sale-i.after-value = v-trans.orig-value. /* salesman might change*/
    END.

    IF sale-i.item-type = "rb" AND sale-i.void = NO THEN
      ASSIGN
        sale-i.extended-warranty = v-trans.extended-warranty
        sale-i.rglr-warranty     = v-trans.rglr-warranty
        sale-i.warranty-link     = v-trans.warranty-link.

    IF p-rent-code BEGINS "re" AND NOT f9active THEN
    DO:
      ASSIGN
        sale-i.retail = v-trans.retail .
      IF p-status = "create" THEN
      DO:
        v-trans.extended = v-trans.retail + v-trans.pos-disc.
      END.
    /* above overrides initial amt as discounts
       can be done on created orders */
    END.

    ELSE IF p-rent-code BEGINS "re" AND f9active THEN
      DO:
        IF p-status = "create" AND f9active AND sale-i.item-type = "rp" THEN
        DO:
          sale-i.retail = v-trans.extended.
          sale-i.disc-amt = v-trans.disc-amt.
        END.
      END.
    /* NEXT IS FOR THE Sale department report */
    IF t-holdit AND sale-i.line-desc[1] BEGINS "RH"
      AND sale-i.item-type = "rp" THEN
      ASSIGN
        sale-i.hold-retail = ((sale-i.before-rate * sale-i.qty) * .15)
        sale-i.void        = NO
        sale-i.info-item   = NO. /* CANNOT SET TO YES BECAUSE ps/get-sale-tot.p */

    IF is-generic(sale-i.sku-no) AND retail-require(sale-i.sku-no) THEN
    DO:
      FIND inv-master NO-LOCK WHERE inv-master.sku-no = sale-i.sku-no NO-ERROR.
      IF AVAILABLE inv-master AND inv-master.cost% <> 0
        THEN sale-i.avg-cost = (sale-i.after-value) * (inv-master.cost% / 100).
    END.
    /* patch aug07/12 found on add from hold and f7 buy undone */
    IF sale-i.line-desc[4] = "BUYS" AND sale-i.item-type = "rp" THEN
      sale-i.line-desc[4] = "".

    IF sale-i.product-no BEGINS "returned/owed" THEN
      sale-i.uom = "o".
    ASSIGN
      sale-i.RETAIL = IF v-trans.estat = "r"
                      THEN v-trans.rntrefund
                      ELSE v-trans.retail.
    IF order.rent-code = "School" AND sale-i.retail < 0 THEN
    DO:
      /***** roll back of discount from f7key aug 2015 *****/
      sale-i.disc-amt = v-trans.pos-disc.
    END.
    IF order.rent-code = "BILLING" AND v-trans.item-status = "return"
      THEN ASSIGN
        sale-i.item-type = "RR"
        sale-i.uom       = "".  /* for owing items */

    IF s-item-no <= sale-i.item-no THEN s-item-no = sale-i.item-no + 1.

    /* compensate for order-i.item-type being RI -- INCONSISTENT -- */

    IF sale-i.item-type <> "RP" OR v-trans.old-item = NO THEN
    DO:
      CREATE sale-s.
      ASSIGN
        sale-s.LINK-sale = sale.LINK-sale
        sale-s.ITEM-NO   = v-trans.item-no
        sale-s.SERIAL-NO = v-trans.SERIAL-NO.
    END.
    ELSE IF t-holdit THEN
      DO:
        CREATE sale-s.
        ASSIGN
          sale-s.LINK-sale = sale.LINK-sale
          sale-s.ITEM-NO   = v-trans.item-no
          sale-s.SERIAL-NO = v-trans.SERIAL-NO.
      END.
    renum = renum + 1.
  END.
END.

/* @(#) rnproc-createsaleitax.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-createsaleitax.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE createsaleitax:
  DEFINE VARIABLE totamt AS DECIMAL.
  FIND sale NO-LOCK WHERE sale.link-sale = salerec.
  FIND sale-i OF sale NO-LOCK
    WHERE sale-i.sku-no = 9999999 USE-INDEX link-sale NO-ERROR.
  totamt = sale-i.retail.

  IF p-tax-amts1 <> 0 THEN
  DO:
    s-item-no = s-item-no + 1. /* create_transact got the blank v_rec*/
    IF t-hold THEN s-item-no = s-item-no + 1. /* hold-chg got the next one*/
    FIND tax NO-LOCK WHERE tax.tax-code = fed-tax-desc NO-ERROR.

    CREATE sale-i.
    ASSIGN
      sale-i.item-no     = s-item-no
      sale-i.link-sale   = sale.link-sale
      sale-i.retail      = p-tax-amts1
      sale-i.item-type   = "TX"
      sale-i.taxable-amt = totamt
      sale-i.link-rent   = 0
      sale-i.info-item   = NO.
    IF AVAILABLE tax THEN
      ASSIGN
        sale-i.reason-code = fed-tax-desc
        sale-i.description = tax.description.
  END.
  totamt = sale-i.retail.
  IF p-tax-amts2 <> 0 THEN
  DO:
    s-item-no = s-item-no + 1.
    FIND tax NO-LOCK WHERE tax.tax-code = prov-tax-desc NO-ERROR.
    CREATE sale-i.
    ASSIGN
      sale-i.item-no     = s-item-no
      sale-i.link-sale   = sale.link-sale
      sale-i.retail      = p-tax-amts2
      sale-i.item-type   = "TX"
      sale-i.reason-code = prov-tax-desc
      sale-i.tax-cost    = NO
      sale-i.link-rent   = 0
      sale-i.taxable-amt = totamt.
    IF AVAILABLE tax THEN
      ASSIGN
        sale-i.description = tax.description
        sale-i.reason-code = prov-tax-desc.
  END.
  IF t-allprotect = NO AND t-latecharge <> 0 THEN
  DO:
    CREATE sale-i.
    ASSIGN
      s-item-no           = s-item-no + 1
      sale-i.LINK-Sale    = sale.LINK-sale
      sale-i.ITEM-NO      = s-item-no
      sale-i.SKU-NO       = 23
      sale-i.serial-no    = "SKU#00000023"
      sale-i.PRODUCT-NO   = "PROTECTION"
      sale-i.RETAIL       = t-latecharge
      sale-i.QTY          = 1
      sale-i.TAX-EXEMPT   = NO
      sale-i.ITEM-TYPE    = "RB"
      sale-i.DT-RENTED    = TODAY
      sale-i.void         = NO
      sale-i.info-item    = NO
      sale-i.LINK-ITEM    = 0
      sale-i.link-rent    = 0
      sale-i.before-value = t-latecharge
      sale-i.after-value  = t-latecharge

      sale-i.TAXABLE-AMT  = sale-i.retail.
    CREATE sale-s.
    ASSIGN
      sale-s.LINK-sale = sale.LINK-sale
      sale-s.ITEM-NO   = sale-i.item-no
      sale-s.SERIAL-NO = sale-i.SERIAL-NO.
  END.
  IF (trunc(t-mincharge,2) > 0 AND NOT t-hold)
    OR (trunc(t-mincharge,2) < 0 AND order.rent-code = "School") THEN
  DO:
    IF order.rent-code = "billing" THEN t-mincharge = 0. /* do nothing */
    ELSE
    DO:
      CREATE sale-i.
      ASSIGN
        s-item-no         = s-item-no + 1
        sale-i.item-type  = "RB"  /* appears as purchase */
        /* sale-i.item-status = "Min Charge"*/
        sale-i.sku        = 9999998
        sale-i.qty        = 1
        sale-i.item-no    = s-item-no
        sale-i.product-no = IF order.rent-code = "School" THEN "Summer Charge"
     ELSE "Min Charge"
        sale-i.link-sale  = sale.link-sale
        sale-i.serial-no  = "SKU# 9999998"
        sale-i.retail     = t-mincharge.
    END.
  END.
END PROCEDURE.

/* @(#) rnproc-create_transact.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-create_transact.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE create_transact:
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  FIND FIRST v-trans WHERE NOT v-trans.serial-no BEGINS "sku#"
    AND v-trans.estat = "B" NO-ERROR.
  IF AVAILABLE v-trans THEN
  DO:
    DEFINE VARIABLE t-charge AS DECIMAL NO-UNDO.
    DEFINE VARIABLE t-credit AS DECIMAL NO-UNDO.
    RUN rn-owe-buy.p(v-trans.link-order, v-trans.item-no, NO,
      OUTPUT t-saletend-amt, OUTPUT t-charge, OUTPUT t-credit).
  END.
  FIND syscust NO-LOCK WHERE syscust.type = "RN" NO-ERROR.
  FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
  /* use item-no off this one */
  is_overdue = NO.
  FIND inv-master NO-LOCK
    WHERE inv-master.sku-no = syscust.int-flag[1].
  CREATE sale-i.
  ASSIGN
    sale-i.link-sale     = sale.link-sale
    sale-i.ITEM-NO       = s-item-no
    sale-i.SKU-NO        = 9999999
    sale-i.VENDOR-CODE   = "L&M"
    sale-i.PRODUCT-NO    = IF is-loan THEN "Loan " + order.order-no
                           ELSE IF t-funct-name = "loan.create" THEN
                           "Loan " + order.order-no
                          ELSE "RENTAL " + order.order-no
    sale-i.DESCRIPTION   = "RENTAL " + order.order-no
    sale-i.reason-code   = IF f9active THEN "BACKOFFICE"
                         ELSE STRING(order.charge-code)
    sale-i.AVG-COST      = IF is_charge THEN t-pay-enter ELSE 0
    sale-i.RETAIL        = IF is_charge THEN chargeit ELSE t-pay-enter
    sale-i.TAX-EXEMPT    = YES  /* w-trans.tax-exempt */
    sale-i.ITEM-TYPE     = "RP"
    sale-i.TAX-COST      = NO
    sale-i.DT-RENTED     = TODAY
    sale-i.LINK-RENT     = 0
    sale-i.uom           = IF order.reminders = YES THEN "y" ELSE "n"
    sale-i.dt-rented     = order.dt-last-notice
    sale-i.qty           = order.last-notice
    /* the only way to determine f9 or f10 on reports is look at avg-cost*/
    sale-i.pos-disc      = chargeit
    sale-i.line-desc[3]  = discreason
    sale-i.line-desc[2]  = loanreason + " " + loantype
    sale-i.discount-note = discreason
    sale-i.disc-reason   = t-disc-type
    sale-i.disc-amt      = discount
    sale-i.info-item     = YES
    s-item-no            = v-trans.item-no + 1.  /* set so we can use on taxes.  */

  /*patch oct30/2012 as n1703068 was able to get on easypay */
  IF t-funct-name = "loan.create" AND order.int-status = "create" THEN
    sale-i.reason-code = "0".

  IF t-saletend-amt >= 1 THEN
  DO:
    sale-i.line-desc[1] = "INVOICES IS $" + string(t-saletend-amt).
  END.
  /* calculate the wheel amount if it exists and store it. */
  DEFINE VARIABLE t-dt-due  AS DATE    NO-UNDO.
  DEFINE VARIABLE t-owed    AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-tax     AS DECIMAL NO-UNDO.
  DEFINE VARIABLE t-wheel   AS LOG.
  DEFINE VARIABLE t-sum-chg AS DECIMAL NO-UNDO.
  IF order.dt-due < TODAY THEN t-dt-due = TODAY.
  RUN rent-due.p(buffer order, INPUT-OUTPUT t-dt-due,  YES, "",
    OUTPUT t-owed, OUTPUT t-tax, OUTPUT t-wheel, OUTPUT t-sum-chg).

  /*over-write this for school owed amts after order-i set at rent-due.p*/
  IF t-owed > 0 THEN sale-i.after-value = t-owed.
  IF t-owed > 0 THEN sale-i.after-value = t-owed.
  IF order.rent-code = "school" THEN
  DO:
    DEFINE VARIABLE tschowed AS DECIMAL.
    FOR EACH v-trans WHERE v-trans.estat = "o" AND v-trans.dayrate <> 0 :
      tschowed = tschowed + v-trans.dayrate - v-trans.retail.
    END.
    IF tschowed <> 0 THEN sale-i.after-value = tschowed.
  END.

  IF sale-i.after-value < 0 THEN sale-i.after-value = 0.
  /* store the expected date if this transaction amount exceeds the
  promised amount and this transaction is on or after the promise date. */
  FIND promises NO-LOCK WHERE promises.cust-no = order.cust-no AND
    promises.link-order = s-link-order NO-ERROR.
  IF AVAILABLE promises AND
    sale.dt-trans >= promises.pr-dt AND promises.exp-amt <= sale-i.retail
    THEN sale-i.dt-return = promises.exp-dt.

  /* include monthly contracts  */
  IF order.rent-code = "school" OR order.rent-code = "billing" THEN
  DO:
    CREATE sale-i.
    ASSIGN
      sale-i.link-sale    = sale.link-sale
      sale-i.ITEM-NO      = s-item-no
      sale-i.SKU-NO       = 9999993
      sale-i.VENDOR-CODE  = "L&M"
      sale-i.info-item    = YES
      sale-i.void         = YES
      sale-i.line-desc[1] = tSchoolAcct
      sale-i.line-desc[2] = tTeacher
      sale-i.line-desc[3] = tStudent
      sale-i.line-desc[4] = IF tAcceptPass THEN "YES" ELSE "NO"
      sale-i.hold-flag    = tSchCostShare
      sale-i.hold-retail  = tSchCostShareValue
      s-item-no           = s-item-no + 1.  /* set so we can use on taxes.  */
  END.
END PROCEDURE.

/* @(#) rnproc-createsaleipd.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-createsaleipd.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE createsaleipd:
  IF s-deposit = 0 THEN RETURN.  /* don't create a deposit when amt is zero */
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
  DO TRANSACTION:
    CREATE sale-i.
    s-item-no = s-item-no + 1.
    ASSIGN
      sale-i.LINK-Sale   = sale.LINK-sale
      sale-i.ITEM-NO     = s-item-no
      sale-i.SKU-NO      = 0
      sale-i.DESCRIPTION = "RENTAL DEPOSIT"
      sale-i.RETAIL      = s-deposit   /* or t-deposit */
      sale-i.TAX-EXEMPT  = NO
      sale-i.ITEM-TYPE   = "PD"
      sale-i.VOID        = NO
      sale-i.INFO-ITEM   = NO
      sale-i.TAX-COST    = NO
      s-item-no          = s-item-no + 1.
  END.
END.

/* @(#) rnproc-credit_deposit.i 1.4 03/27/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-credit_deposit.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE credit_deposit:  /* -- Ask whether to use VISA or MC for deposit -- */

  DEFINE VARIABLE specrentmsg AS LOG. /* should be global */
  DEFINE VARIABLE t-pay-mini  AS DECIMAL.
  DEFINE VARIABLE t-chgcode   AS INTEGER.    /* not used */

  s-realdeposit = 0.
  t-reply = NO.
  s-chargex = FALSE.
  s-security = NO.
  tloc-receive  = 0.
  specrentmsg = NO.
  FIND syscust NO-LOCK WHERE syscust.type = "RN".
  t-pay-mini = syscust.dec-flag[5].      /* rental contract minimum amount */
  /* initialize these for f4 reasons */
  IF p-status = "create" THEN
  DO: /* dont charge deposit on new order when */
    DEFINE VARIABLE p-reply AS LOG INIT NO.
    FOR EACH v-trans WHERE RECID(v-trans) <> v_rec
      AND NOT v-trans.void: /* all are bought */
      IF v-trans.estat <> "P"
        THEN   /* at least one item is not bought */ p-reply = YES.
    END.
    IF p-reply = NO THEN
    DO:
    END.
  END.           /* next 2 are temp lines */
  FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
  ASSIGN
    p-status = order.int-status.
  /* ---------- section for school rentals ------------------ */
  is-cancel = NO.
  IF NOT order.rent-code BEGINS "RE" AND p-status = "create" THEN
  DO:
    IF p-reply THEN
    DO: /* at least one item is being rented */
      /* let f3 key handle deposit problems */
      t-deposit = 0.
      s-security = NO.
      s-chargex = TRUE.
    END.
  END.
  /* as of sept 19/2002 dont collect deposit if not already collected */
  ELSE IF NOT order.rent-code BEGINS "RE" AND p-status <> "create"
      AND t-deposit > 0 THEN
    DO:
      FIND FIRST v-trans WHERE v-trans.sku-no <> 0
        AND v-trans.item-type = "ri" NO-ERROR.  /* looks like a payment */
      IF AVAILABLE v-trans THEN
        t-deposit = 0.
    END.

  /* ------ end of section on school rentals ---------- */
  oMsg:msg-hide().
  IF p-status = "CREATE" AND p-rent-code <> "BILLING" THEN
  DO:   /* 6xx */
    is-cancel = NO.

    /**** this section is replacement nov 10    */
    IF p-rent-code BEGINS "RE" AND chg-code <> 0 THEN
    DO:
      s-chargex = TRUE.
      s-security = NO.
    END.
    ELSE IF p-rent-code BEGINS "RE" AND chg-code = 0 THEN
      DO:
        ASSIGN
          t-deposit  = syscust.dec-flag[2]   /* default (cash) deposit amount */
          s-security = YES.
      END.
      ELSE IF p-rent-code BEGINS "re" THEN
        DO:
          is-cancel = YES.
          RETURN.
        END.
  /* -------------------------------------- */
  END.

  /* special case if new order and amount is less then total rent-rate then
     use this amount instead  **/
  IF p-status = "create" THEN t-pay-enter = t-total.
  IF p-status = "create" AND p-rent-code BEGINS "re"
    THEN t-dt-enter = s-dt-return.
  IF s-co-complete THEN t-dt-enter = TODAY.
  IF p-rent-code BEGINS "re" AND p-status <> "create"
    AND LASTKEY = keycode("f4") THEN
  DO:  /**** reset from f4 back *****/
    IF NOT t-hold THEN t-dt-enter = order.dt-due.
    ELSE t-dt-enter = hold-order.dt-due.
    IF NOT f9active THEN s-dt-return = t-dt-enter.
  END.

  /****** THIS SECTION REGULAR/HOLD RENTS AND RTO'S **************/
  IF p-rent-code BEGINS "re" THEN
  DO:
    IF t-date-due <> ? THEN t-dt-enter = t-date-due.
    t-mincharge = 0.
    FOR EACH order-i OF order NO-LOCK WHERE order-i.item-type = "ri" OR
      order-i.item-type = "rr":
      t-mincharge = t-mincharge + order-i.extended.
    END.
    IF t-mincharge > 5 THEN t-mincharge = 0.   /* already have enough rent */
    ELSE t-mincharge = order.discount.     /* not enough collected yet */
    /* but also shouldn't charge min charge if all items are being bought */
    DEFINE VARIABLE setcharge AS LOG INIT NO.      /* assume dont set the charge */
    FOR EACH v-trans WHERE v-trans.sku-no <> 0 AND v-trans.item-type <> "re"
      AND NOT v-trans.void:
      IF v-trans.item-type = "ri" AND  v-trans.rent-rate <> 0
        /* and v-trans.estat <> "p"  */
        THEN
        setcharge = YES. /* at least one item can account for min charge */
    END.

    IF t-hold THEN setcharge = NO. /* no minimum on hold contracts */

    IF setcharge = NO THEN  /* assume items are bought or collected already*/
      t-mincharge = 0.   /* no item avail to set the charge for. */
    IF is-loan AND order.dt-due = ? THEN t-dt-enter = s-dt-return.
    ELSE IF is-loan THEN
        t-dt-enter = order.dt-due.
    DEFINE VARIABLE t-late AS LOG INIT NO NO-UNDO.
    RUN rn-mincharge.p(NO, s-link-order).
    FIND FIRST v-trans WHERE v-trans.item-no = 903 NO-ERROR.
    IF AVAILABLE v-trans THEN v-trans.estat = "".
    /* PATCH JOB */
    FOR EACH v-trans WHERE v-trans.estat = "p":
      ASSIGN
        v-trans.item-type   = "rb"
        v-trans.item-status = "BUYS".
    /* task 3342 guard code here */
    END.
    FOR EACH v-trans WHERE v-trans.sku-no = 9999994: /* remove on f4 back*/
      DELETE v-trans.
    END.
    RUN item-screen.p. /* make copy of v-trans in case of suspend sales */
    IF NOT hasProtect(order.order-no, order.cust-no) THEN prot-flag = NO.
    FIND v-sale-s WHERE v-sale-s.item-no = 903 NO-ERROR.
    IF AVAILABLE v-sale-s THEN DELETE v-sale-s.

    IF AVAILABLE order AND order.order-no BEGINS "ro" THEN
    DO:
      FOR EACH v-trans WHERE v-trans.rent-rate <> 0
        AND v-trans.old-item = NO:
        IF v-trans.orig-rentrate = 0 THEN
          v-trans.orig-rentrate = v-trans.rent-rate.
      END.
    END.
    FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
    IF NOT AVAILABLE sale THEN   /* task ?? */
      RUN testsale.
    RUN regtot.p
      (INPUT-OUTPUT t-deposit, p-orderid, INPUT-OUTPUT t-pay-enter,
      INPUT-OUTPUT t-dt-enter, t-paid, r-ins,
      INPUT f9active, INPUT t-hold, t-hold-link,  /* send with regtot*/
      OUTPUT discount, OUTPUT is_charge, OUTPUT discreason,
      OUTPUT t-disc-type,   /* send with regtot.p */
      OUTPUT chargeit, INPUT chg-code, INPUT-OUTPUT t-mincharge,
      OUTPUT f5active, OUTPUT fed-tax-desc, OUTPUT prov-tax-desc,
      OUTPUT p-tax-amts1, OUTPUT p-tax-amts2 ,INPUT-OUTPUT t-taxcollect,
      OUTPUT p-id1, OUTPUT p-id2, OUTPUT p-id3, OUTPUT p-id4, INPUT-OUTPUT
      t-late, OUTPUT t-visa, t-funct-name, OUTPUT p-backtrack,
      OUTPUT t-latecharge, INPUT prot-flag, OUTPUT t-allprotect).
    FIND FIRST v-trans NO-LOCK WHERE v-trans.sku-no = 351993 NO-ERROR.
    IF NOT AVAILABLE v-trans THEN
    DO:
      FOR EACH v-trans WHERE v-trans.estat = "" OR v-trans.estat = "r":
        v-trans.taxable-amt = 0.
      END.
    END.
    IF t-hold-link <> ? THEN
    DO:
      DEFINE VARIABLE t-label    AS CHARACTER NO-UNDO.
      DEFINE VARIABLE tz-retail  AS DECIMAL   NO-UNDO.
      DEFINE VARIABLE tz-deposit AS DECIMAL   NO-UNDO.
      RUN rn-collected.p(t-hold-link, INPUT-OUTPUT t-label,
        INPUT-OUTPUT tz-retail, OUTPUT tz-deposit).
      FIND v-trans WHERE v-trans.sku-no = 9999994 NO-ERROR.
      IF NOT AVAILABLE v-trans THEN
      DO:
        CREATE v-trans.
      END.
      ASSIGN
        v-trans.sku-no     = 9999994
        v-trans.retail     = tz-retail
        v-trans.item-no    = 905
        v-trans.item-type  = "pd"
        v-trans.link-order = order.link-order
        v-trans.serial-no  = "SKU# 9999994".

      FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
    END.
    IF s-co-complete AND t-dt-enter < TODAY THEN s-co-complete = NO.
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.

    IF LASTKEY = keycode("f4") THEN
    DO:
      IF order.order-no BEGINS "ro" AND order.int-status = "create" THEN
      DO:
        FOR EACH v-trans WHERE v-trans.old-item = NO
          AND v-trans.rent-rate <> 0:
          v-trans.rent-rate = v-trans.orig-rentrate.
        END.
      END.
      IF order.order-no BEGINS "ro" AND order.loc-code = "lw21" THEN
      DO:
        FOR EACH v-trans WHERE v-trans.rent-credit < 0 AND v-trans.sku-no = 28
          AND v-trans.estat = "r":
          v-trans.extended = v-trans.extended + v-trans.rent-credit.
        END.
      END.
      FOR EACH v-trans WHERE v-trans.sku-no = 351993:
        v-trans.extended = v-trans.orig-value * - 1.
        v-trans.retail = v-trans.orig-value * - 1.
      END.
      FOR EACH v-trans WHERE v-trans.sku-no = 28
        OR v-trans.item-no = 903 OR v-trans.item-no = 904
        OR v-trans.sku-no = 9999995:

        IF v-trans.sku-no = 28 AND p-rent-code <> "regular" THEN NEXT.
        DELETE v-trans.
      END.
      FOR EACH v-sale-s WHERE v-sale-s.item-no = 800:
        DELETE v-sale-s.
      END.
      FOR EACH v-trans WHERE v-trans.sku-no = 9999995
        OR v-trans.sku-no = 9999994:
        DELETE v-trans.
      END.
      FOR EACH v-trans WHERE v-trans.estat = "e":
        v-trans.extended = v-trans.origextend.
      END.
    END.

    IF LASTKEY <> keycode("f4") THEN
    DO:

      FIND FIRST v-trans WHERE v-trans.item-no = 907 NO-ERROR.
      IF AVAILABLE v-trans THEN
      DO:
        t-fund-chg = v-trans.retail.
        t-fund = YES.
        DELETE v-trans.
      END.
      FIND FIRST v-trans WHERE v-trans.sku-no = 98
        AND v-trans.retail = 0 NO-ERROR.
      IF AVAILABLE v-trans THEN
      DO:
        DELETE v-trans.
      END.

      t-late = NO.  /* no longer charge latecharges. */
      IF t-visa THEN
        FOR EACH v-trans WHERE v-trans.sku-no <> 0 AND v-trans.sku-no < 9999990:
          v-trans.retail = 0.
          v-trans.pos-disc = 0.
          v-trans.disc-amt = 0.
        END.
    END.
  /* ? mark occurs in pos-disc when rent rate 0 and late charge */
  END.
  /*********** THIS SECTION SCHOOL YEARLY AND MONTHLY OLD **********/
  ELSE
  DO:
    IF t-date-due <> ? THEN t-dt-enter = t-date-due.
    ELSE IF NOT t-hold THEN t-dt-enter = order.dt-due.

    t-fund-chg = 0.
    IF order.rent-code = "school" THEN
    DO:
      /* patch for items added with prorate > 1yr. */
      FOR EACH v-trans WHERE v-trans.estat = "" AND v-trans.old-item = NO :
        v-trans.retail = v-trans.extended.
        v-trans.rntrefund = v-trans.retail.
      END.
    END.
    IF order.rent-code = "billing" AND order.int-status = "create" THEN
    DO:
      FOR EACH v-trans:
        v-trans.retail = v-trans.extended.
        v-trans.rntrefund = v-trans.retail.
      END.
    END.
    RUN item-screen.p. /* make copy of v-trans in case of suspend sales */
    /*** task 5681 allow new billing contracts direct to tender
         on create of contract. **/
    IF order.rent-code = "BILLING" THEN
    DO:
      IF order.int-status = "create" AND chg-code = 0 THEN
        t-deposit = 20.
      ELSE IF order.int-status <> "create" THEN
          F3BANDATTENDER = YES.
    END.
    IF ORDER.RENT-CODE = "SCHOOL" OR order.rent-code = "BILLING" THEN
      /* section tested for basic going forward */
      IF F3BANDATTENDER = NO THEN
      DO:
        IF order.rent-code = "school" THEN
        DO:
          DEFINE VARIABLE t-due      AS DECIMAL NO-UNDO.
          DEFINE VARIABLE z-purchase AS DECIMAL NO-UNDO.
          t-pay-enter = 0.
          t-due = 0.
          z-purchase = 0.
          DEFINE VARIABLE tSumChg AS DECIMAL NO-UNDO.

          IF order.dt-due < TODAY THEN
            t-dt-enter = year-end. /* works for 2012 to 2013 */
          s-co-complete = NO. /**** test for full return of protection ***/
          RUN rnSchBalProt.p("AutoReturn",tSchCostShare).
          FIND FIRST v-trans WHERE (v-trans.estat = ""
            OR v-trans.estat = "E" OR v-trans.estat = "C") /* task 2706 */
            AND v-trans.sku-no > 0 AND v-trans.sku-no < 9999990 NO-ERROR.
          IF NOT AVAILABLE v-trans THEN s-co-complete = YES.
          /* MUST FORCE F9 ACTIVE FIRST TIME THROUGH OTHERWISE
             EARLY RETURNS WITH DISCOUNT ROLLOFF WILL NOT BE CORRECT
             ON CREATE OF THE SALE-I ********/
          IF t-dt-enter <> year-end THEN t-dt-enter = year-end.
          RUN rnPreSchlCalc.p(buffer order, F3BANDATTENDER,
            tSchCostShare, tSchCostShareValue,
            INPUT-OUTPUT t-pay-enter,
            INPUT-OUTPUT t-dt-enter,
            INPUT-OUTPUT t-due,
            INPUT-OUTPUT z-purchase,
            INPUT-OUTPUT t-purchase,
            INPUT-OUTPUT tSumChg,
            INPUT-OUTPUT t-mincharge,
            INPUT-OUTPUT tYears,
            INPUT-OUTPUT fed-tax-desc,
            INPUT-OUTPUT p-tax-amts1,
            INPUT-OUTPUT prov-tax-desc,
            INPUT-OUTPUT p-tax-amts2).
          p-tax-amts1 = ROUND(p-tax-amts1,2).
          p-tax-amts2 = ROUND(p-tax-amts2,2).
        END.
      END.
      ELSE IF ORDER.RENT-CODE = "SCHOOL" OR order.rent-code = "billing" THEN
        DO:
          IF order.rent-code = "school" THEN
          DO:
            RUN rn-taxes.p(INPUT s-link-order, OUTPUT fed-tax-desc,
              OUTPUT p-tax-amts1, OUTPUT prov-tax-desc, OUTPUT p-tax-amts2).
            RUN chkEastCoastTax.p(buffer order, INPUT-OUTPUT p-tax-amts1,
              INPUT-OUTPUT p-tax-amts2).
            t-dt-enter = DATE(MONTH(year-end),DAY(year-end)
              ,YEAR(year-end + (tYears - 1))).

            RUN SchRegtot.p
              (INPUT-OUTPUT t-deposit, p-orderid, INPUT-OUTPUT t-pay-enter,
              INPUT-OUTPUT t-dt-enter, t-paid, r-ins,
              INPUT f9active, tSchCostShare, tSchCostShareValue,
              OUTPUT discount, OUTPUT is_charge, OUTPUT discreason,
              OUTPUT t-disc-type,   /* send with regtot.p */
              OUTPUT chargeit, INPUT chg-code, INPUT tYears, INPUT-OUTPUT t-mincharge,
              OUTPUT f5active, OUTPUT fed-tax-desc, OUTPUT prov-tax-desc,
              OUTPUT p-tax-amts1, OUTPUT p-tax-amts2 ,INPUT-OUTPUT t-taxcollect,
              OUTPUT p-id1, OUTPUT p-id2, OUTPUT p-id3, OUTPUT p-id4, INPUT-OUTPUT
              t-late, OUTPUT t-visa, t-funct-name, OUTPUT p-backtrack,
              OUTPUT t-latecharge, INPUT prot-flag, OUTPUT t-allprotect).
          END.
          /**** on create and f3 from tender run this for monthly ****/
          ELSE IF order.rent-code = "billing" THEN
            DO:
              IF chg-code = 0 THEN
                t-deposit = 20.
              /* patch */
              t-dt-enter = order.dt-due.
              t-mincharge = 0.
              RUN rnSchBalProt.p("AutoReturn",tSchCostShare). /*8889*/
              FIND FIRST v-trans WHERE (v-trans.estat = ""
                OR v-trans.estat = "E" OR v-trans.estat = "C") /* task 2706 */
                AND v-trans.sku-no > 0 AND v-trans.sku-no < 9999990 NO-ERROR.
              IF NOT AVAILABLE v-trans THEN s-co-complete = YES.
              IF order.dt-created < 09/25/2017 THEN
                RUN oldrenttot.p
                  (INPUT-OUTPUT t-deposit, INPUT p-orderid, INPUT-OUTPUT t-pay-enter,
                  INPUT-OUTPUT t-dt-enter, INPUT t-paid, INPUT r-ins,
                  INPUT f9active, INPUT chg-code, OUTPUT discount, OUTPUT is_charge,
                  INPUT s-issue, OUTPUT p-tax-amts1, OUTPUT p-tax-amts2,
                  OUTPUT p-backtrack).
              ELSE
              DO:
                RUN renttot.p
                  (INPUT-OUTPUT t-deposit, 
                  INPUT p-orderid, 
                  INPUT-OUTPUT t-pay-enter,
                  INPUT-OUTPUT t-dt-enter, 
                  INPUT t-paid, 
                  INPUT chg-code, 
                  OUTPUT discount, 
                  INPUT s-issue, 
                  OUTPUT p-tax-amts1, 
                  OUTPUT p-tax-amts2,
                  OUTPUT p-backtrack).
                RUN rn-taxes.p(INPUT s-link-order, OUTPUT fed-tax-desc,
                  OUTPUT p-tax-amts1, OUTPUT prov-tax-desc, OUTPUT p-tax-amts2).
                RUN chkEastCoastTax.p(buffer order, INPUT-OUTPUT p-tax-amts1,
                  INPUT-OUTPUT p-tax-amts2).
              END.
            END.
          FIND order NO-LOCK WHERE RECID(order) = p-orderid NO-ERROR.
        END.
    FOR EACH v-trans WHERE v-trans.item-type = "re":
      v-trans.retail = 0.
    END.
    FIND FIRST v-trans WHERE v-trans.item-no = 907 NO-ERROR.
    IF AVAILABLE v-trans THEN
    DO:
      t-fund-chg = v-trans.retail.
      t-fund = YES.
      DELETE v-trans.
    END.
    IF s-issue < TODAY AND p-status = "create"
      AND t-pay-enter <> 0 THEN
    DO:
      f9active = YES. /* not backoffice. */
      IF NOT order.rent-code BEGINS "re" THEN   /* school contracts so */
        t-pay-enter = 0.
    END.
    FIND FIRST v-trans WHERE v-trans.sku-no = 98
      AND v-trans.retail = 0 NO-ERROR.
    IF AVAILABLE v-trans THEN
    DO:
      DELETE v-trans.
    END.
  END.
  PAUSE 0 NO-MESSAGE.

  IF LASTKEY = keycode("f4") THEN
  DO:
    oMsg:msg-refresh().
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
    t-taxcollect = order.tax-collect.  /* reset */
    RUN rs-fundraise.p(NO, 0).    /* delete this v-trans */
    FOR EACH v-trans WHERE v-trans.sku-no <> 0:
      IF v-trans.estat = "e" AND NOT order.rent-code = "school" THEN
      DO:
        IF v-trans.estat = "e" AND NOT order.rent-code = "school" THEN
          ASSIGN
            v-trans.rntrefund = 0
            v-trans.retail    = 0.
      END.
      IF order.rent-code = "billing" AND order.int-status <> "create" THEN
      DO:
        IF v-trans.old-item AND v-trans.estat = "o" THEN
        DO:
          FIND order-i OF order NO-LOCK
            WHERE order-i.item-no = v-trans.item-no NO-ERROR.
          IF AVAILABLE order-i AND order-i.item-status <> "owing" THEN
          DO:
            ASSIGN
              v-trans.estat       = "r"
              v-trans.item-type   = "RR"
              v-trans.item-status = "return"
              v-trans.dt-return   = TODAY.
          END.
        END.
      END.
      IF v-trans.estat = "O" THEN v-trans.item-status = "owing".
      IF p-status = "create" OR v-trans.item-status = "ri"
        THEN v-trans.extended = v-trans.origextend.
      IF v-trans.sku-no = 9999998 THEN
      DO:
        IF AVAILABLE v-trans THEN
          DELETE v-trans. /* delete min/late charges created on last screen*/
      END.
      ELSE IF v-trans.sku-no = 0000098 THEN
        DO:
          IF AVAILABLE v-trans THEN
            DELETE v-trans. /* delete min/late charges created on last screen*/
        END.
    END.
  END.
  ELSE
  DO:     /* shitty little patch , till i can find problem */
    FIND v-trans WHERE v-trans.sku-no = 9999998 NO-ERROR.
    IF AVAILABLE v-trans AND order.rent-code = "billing" THEN
      DELETE v-trans.  /* patch tsk 5681 */
  END.
END PROCEDURE.

/* @(#) rnproc-total.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-total.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE total:
  DEFINE FRAME fr-total.
  DEFINE VARIABLE d-total         AS DECIMAL   FORM "-ZZZZ,ZZ9.99".

  DEFINE VARIABLE sdep            AS CHARACTER INIT "DEPOSIT     :".
  DEFINE VARIABLE p-sub-total     AS DECIMAL.
  DEFINE VARIABLE p-tax-sub-total AS DECIMAL.
  HIDE FRAME fr-message NO-PAUSE.
  FIND location NO-LOCK WHERE location.loc-code = t-loc-code.
  /* patch as school contracts not up to snuff on calculations */
  /* dont include the old exchange item as well. */
  /*** required for renttot.p  **/



  IF NOT test-rs-regtot THEN
  DO:
    /*****THIS IS ALL FOR BILLING CONTRACTS **********/
    IF p-rent-code <> "regular" THEN p-backtrack = NO.
    IF NOT f5active AND NOT p-backtrack THEN
    DO:
      IF t-funct-name = "rental.create" THEN
      DO:
        IF AVAILABLE order AND order.rent-code = "billing" THEN
        DO:
          RUN rn-taxes.p
            (INPUT s-link-order, OUTPUT fed-tax-desc, OUTPUT p-tax-amts1
            ,OUTPUT prov-tax-desc, OUTPUT p-tax-amts2).
        END.
      END.
    END.
    p-sub-total = 0.
    p-tax-sub-total = 0.
  END.
  IF p-rent-code = "billing" THEN
  DO:
    FOR EACH v-trans WHERE v-trans.estat = "o" :
      ASSIGN
        v-trans.item-status = "owing"
        v-trans.item-type   = "ri"
        s-co-complete       = NO.
    END.
  END.
  IF p-rent-code = "school" /* task 2298 sep22 */ THEN
  DO:
    FOR EACH v-trans WHERE v-trans.estat = "o" :
      IF v-trans.dayrate > v-trans.retail THEN
        ASSIGN v-trans.item-status = "owing"
          v-trans.item-type   = "ri"
          s-co-complete       = NO.
    END.
  END.
  /* following adjusts writeoff against any deposits.  */
  IF NOT p-rent-code BEGINS "re" THEN .

  IF NOT p-rent-code BEGINS "re" AND p-status <> "create"
    AND NOT s-co-complete THEN
  DO:
    /* exception! roll back of school yearly.  */
    IF t-dt-enter = order.dt-created AND t-pay-enter < 0 AND p-rent-code
      = "SCHOOL" THEN.
  /* else t-deposit = 0.  new code should be able to collect off f3 key */
  END.
  s-deposit = t-deposit.
  /** Add deposit to be returned to customer **/
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
  IF s-co-complete OR (p-status = "create" AND s-security ) THEN
  DO:
    IF s-deposit <> 0 THEN
    DO:
      FIND order  NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
      /* allow deposit field to be set on creation of order */
      IF NOT p-rent-code BEGINS "re" THEN
        /* do not enable if monthly school with a easypay set up */
        IF order.int-status = "create" THEN
        DO:
          /*
          enable s-deposit with frame fr-total.
          wait-for return of s-deposit.

          assign s-deposit.
          */
          IF s-deposit < 0 THEN s-deposit = s-deposit * -1.
        /*     display s-deposit with frame fr-total.  */
        END.
    END.
    /* assign s-deposit. */
    s-total = s-total + s-deposit.
  END.

  IF NOT s-security AND p-status = "create" THEN
  DO:
    DEFINE VARIABLE t-chgcode AS INTEGER INIT 0 NO-UNDO.
    FIND order NO-LOCK WHERE order.link-order  = s-link-order NO-ERROR.
    FIND customer NO-LOCK WHERE customer.cust-no = order.cust-no.
    ASSIGN
      r-cust = RECID(customer).
    v_cust-no = customer.cust-no.
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  END.
END PROCEDURE.

/* @(#) rnproc-returnall.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-returnall.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE returnall:
  DEFINE VARIABLE holdrec AS RECID   NO-UNDO.
  DEFINE VARIABLE cnte    AS INTEGER.
  IF p-status = "create" THEN RETURN. /* dont activate on new orders */
  IF RECID(v-trans) <> v_rec THEN RETURN.
  FIND FIRST v-trans WHERE v-trans.item-type = 'RI' NO-ERROR.
  IF NOT AVAILABLE v-trans THEN
  DO:
    BELL.
    MESSAGE " ... ALL RENTED ITEMS ALREADY RETURNED ...".
    PAUSE.
    HIDE FRAME to-do NO-PAUSE.
    RETURN.
  END.
  ELSE
  DO:
    FOR EACH v-trans NO-LOCK WHERE NOT v-trans.void
      AND v-trans.item-type = "RI" AND NOT RECID(v-trans) = v_rec
      AND (v-trans.estat <> "R" OR v-trans.estat <> "O") :
      IF v-trans.item-status = "OWING" THEN.
      ELSE
      DO:    /* patch to return loans to new */

        IF (v-trans.qty >= 1 AND t-funct-name = "loan.create")
          AND v-trans.serial-no BEGINS "sku#" THEN
        DO:
          DISPLAY v-trans.description WITH FRAME fr-descrip.
          RUN returnloan-tonew(v-trans.item-no).
        END.
        ELSE
        DO:
          v-trans.qty-new = 0.
          RUN rentirtn.
        END.
      END.
    END.
    FIND v-trans WHERE RECID(v-trans) = v_rec.
    HIDE FRAME f NO-PAUSE.
    RUN reopenquery.
    RUN correcttotal.
    HIDE FRAME fr-descrip NO-PAUSE.
    DISPLAY e WITH FRAME f.
    ENABLE e WITH FRAME f ROW bl-row + offset COL 4.
    APPLY "entry" TO e IN FRAME f.

    RETURN.
  END.
END PROCEDURE.

/* @(#) rnproc-printbarcode.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-printbarcode.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE printbarcode:

  DEFINE VARIABLE t-prnt-ok AS LOG INIT NO.
  IF NOT is_suspend THEN
  DO:
    MESSAGE "Print a Bar Code for each returned item?"
      VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO-CANCEL
      UPDATE t-prnt-ok.
    IF t-prnt-ok = ? OR t-prnt-ok = NO THEN
    DO:
      t-prnt-ok = NO.
      RETURN.
    END.
    DEFINE VARIABLE t-barcode AS LOG NO-UNDO.
    DEFINE VARIABLE t-device  AS cha NO-UNDO.
    FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
    FOR EACH v-trans
      WHERE v-trans.estat = "o" OR v-trans.estat = "r":
      IF NOT v-trans.serial-no BEGINS "sku" THEN
      DO:
        FIND inv-master NO-LOCK
          WHERE inv-master.sku-no = v-trans.sku-no NO-ERROR.
        FIND inv-locsrl NO-LOCK
          WHERE inv-locsrl.serial-no = v-trans.serial-no
          AND inv-locsrl.sku-no = inv-master.sku-no NO-ERROR.
        IF AVAILABLE inv-locsrl THEN
        DO:
          DEFINE VARIABLE t-retail AS DECIMAL NO-UNDO.
          /*run im/locsrl-val.p ("retail",buffer inv-locsrl,output t-retail).*/
          t-retail = get-current-retail(inv-locsrl.sku-no, inv-locsrl.serial-no).
          /* destroy-locsrl-val().  */
          RUN im/bar-cd-prt.p
            (t-retail
            ,inv-locsrl.sku-no
            ,IF inv-locsrl.description <> ""
            THEN inv-locsrl.description ELSE inv-master.description
            ,inv-master.product-no
            ,1
            ,YES
            ,inv-locsrl.serial-no
            ,inv-locsrl.date-code,0,INPUT-OUTPUT t-device).
        END.
      END.
    END.
  END.
  RETURN.
END PROCEDURE.

/* @(#) rnproc-loadorigextend.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-loadorigextend.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE loadorigextend:
  DEFINE OUTPUT PARAMETER t-endkey AS LOG INIT NO.
  DEFINE VARIABLE counter AS INTEGER NO-UNDO.


  DEFINE VARIABLE blkexch AS LOG     INIT NO.
  counter = 0.
  FIND FIRST v-trans WHERE v-trans.estat = "x"
    AND v-trans.item-type = "RI" NO-ERROR.
  IF AVAILABLE v-trans THEN
  DO:
    t-endkey = YES.
    RETURN.
  END.

  FIND FIRST v-trans WHERE v-trans.sku-no <> 0
    OR (v-trans.sku-no <> 28 AND v-trans.void = YES) NO-ERROR.
  IF NOT AVAILABLE v-trans THEN
  DO:
    FIND FIRST v-trans NO-ERROR.
    t-endkey = YES.
    RETURN.
  END.

  IF p-status = "create" THEN
    FOR EACH v-trans: /* set up to recover on f4 */
      v-trans.origextend = v-trans.extended.
    END.
  FIND v-trans WHERE v-trans.sku-no = 0 .
  HIDE FRAME f NO-PAUSE.
  HIDE FRAME brws-frame NO-PAUSE.
  HIDE FRAME fr-total2 NO-PAUSE.
  HIDE FRAME fr-key NO-PAUSE.
  HIDE FRAME fr-keys NO-PAUSE.
END.

/* @(#) rnproc-testsale.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-testsale.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE testsale:
  FIND order NO-LOCK WHERE order.link-order = s-link-order NO-ERROR.
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
  DO TRANSACTION:
    IF NOT AVAILABLE sale THEN
      /** or (avail sale and sale-cust-no <> order.cust-no)  ***/
      RUN createsale.
    ELSE IF AVAILABLE sale THEN
      DO:
        FOR EACH sale-i OF sale:
          DELETE sale-i.
        END.
        FOR EACH sale-s OF sale:
          DELETE sale-s.
        END.
      END.
  END.
  FIND sale NO-LOCK WHERE sale.link-sale = salerec NO-ERROR.
END.

/* @(#) rnproc-rto-cost.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-rto-cost.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE rto-cost:
  DEFINE INPUT PARAMETER p-new AS LOG NO-UNDO.
  DEFINE OUTPUT PARAMETER p-endkey AS LOG NO-UNDO.
  DEFINE INPUT PARAMETER t-newvalue AS DECIMAL NO-UNDO.
  DEFINE INPUT PARAMETER t-serial-no LIKE inv-locsrl.serial-no NO-UNDO.
  DEFINE INPUT PARAMETER pF8 AS LOG NO-UNDO.

  DEFINE VARIABLE rateReply     AS LOG     NO-UNDO.
  DEFINE VARIABLE t-rate        AS DECIMAL INIT 0.
  DEFINE VARIABLE t-orig        AS DECIMAL.
  DEFINE VARIABLE t-mths        AS INTEGER.
  DEFINE VARIABLE t-used        AS DECIMAL.
  DEFINE VARIABLE origvalue     AS DECIMAL.
  DEFINE VARIABLE tMths         AS INTEGER.
  DEFINE VARIABLE t-newprice    AS DECIMAL.
  DEFINE VARIABLE t-newrate     AS DECIMAL.
  DEFINE VARIABLE t-usedrate    AS DECIMAL.
  DEFINE VARIABLE tx-endkey     AS LOG     NO-UNDO.
  DEFINE VARIABLE t-oldrate     AS DECIMAL.
  DEFINE VARIABLE t-oldvalue    AS DECIMAL.
  DEFINE VARIABLE maxCap        AS INTEGER.
  DEFINE VARIABLE tdays         AS INTEGER.
  DEFINE VARIABLE enddate       AS DATE.
  DEFINE VARIABLE cumInt        AS DECIMAL NO-UNDO.
  DEFINE VARIABLE defaultMonths AS DECIMAL NO-UNDO.
  maxcap = 60.
  IF v-trans.rent-rate = ? THEN v-trans.rent-rate = 0.
  IF pF8 THEN
  DO:
    origvalue = t-newvalue. /* the current selling can be over-ridden */
    IF v-trans.rent-rate <> 0 AND v-trans.rent-rate <> ? THEN
      t-rate = v-trans.rent-rate.
    DEFINE VARIABLE tja AS LOG INIT NO.
    IF origvalue / t-rate > 50 THEN tja = YES.
    /* i.e. orig = 745 / 10 = 74.5 mths is already out of bounds */
    IF tja THEN
    DO:
      p-endkey = YES.
      t-rate = t-orig-rate.  /* YFL285SII  */
      RETURN.
    END.
  END.
  ELSE
  DO:
    ASSIGN
      origvalue = v-trans.over-retail /* first time around */
      t-rate    = v-trans.rent-rate.
  END.

  /********************************************************/
  /******CASE OF SKU 39 OR 49 FOR NEW OR PF8 ************/
  /*******************************************************/
  IF (v-trans.sku-no = 39 OR v-trans.sku-no = 49) THEN
  DO:
    IF t-rate = 0 OR pf8 THEN
    DO:   /* tested RO031813 */
      IF pf8 AND t-rate <> 0 THEN
      DO: /* get new origvalue based on t-rate */
        RUN rnRtoUsedPriceCalc.p(origvalue,v-trans.sku-no,
          t-rate, OUTPUT t-orig, OUTPUT cumInt, OUTPUT defaultMonths).
        IF t-orig / t-rate > 58 THEN
        DO:
          p-endkey = YES.
          t-rate = t-orig-rate.
          MESSAGE "RTO PRICE CANNOT BE CALCULATED WITH THIS RATE "
            VIEW-AS ALERT-BOX.
          RETURN.
        END.
      END.
      ELSE
        RUN rnRtoNewPriceCalc.p(origvalue,v-trans.sku-no,
          OUTPUT t-orig, OUTPUT t-rate,
          OUTPUT cumInt, OUTPUT defaultMonths).
      RUN roundup(INPUT-OUTPUT defaultMonths).  /* task 2579 */
      t-orig = t-rate * defaultMonths.
      IF pf8 THEN
      DO:
        ASSIGN
          v-trans.orig-value  = t-orig
          v-trans.after-value = t-orig
          v-trans.rent-rate   = t-rate
          t-rto-tot           = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
          /*t-rto-tot = v-trans.orig-value*/
          t-rto-mth           = v-trans.orig-value / v-trans.rent-rate.
        RETURN.
      END.
    END.
    IF t-orig = ? THEN
    DO: /* t-rate is too low or too high */
      p-endkey = YES.
      t-rate = t-orig-rate.
      MESSAGE "RTO PRICE CANNOT BE CALCULATED WITH THIS RATE "
        VIEW-AS ALERT-BOX.
      RETURN.
    END.
    IF AVAILABLE v-trans AND v-trans.estat = "e" THEN   /* task 2360*/
      tMths = (t-orig - v-trans.extended) / t-rate.
    ELSE
      tMths = t-orig / t-rate.
  END.
  /********ELSE INV-RENT EXISTS FOR ITEM NEW OR PF8 **********/
  ELSE IF v-trans.pInvRentExists THEN
    DO:
      IF NOT pF8 THEN
      DO:    /* new used and unknown */
        IF v-trans.qty-new > 0 THEN
        DO:   /* new item first time around */
          IF v-trans.rto-price <> 0 THEN
          DO:  /* new rates */
            /* bufcopyvlocsrl will set these */
            v-trans.orig-value = v-trans.rto-price.
            v-trans.rent-rate = v-trans.rent-to-own.
            RETURN.
          END.
          ELSE IF v-trans.rto-rate1 <> 0 THEN
            DO: /* only seen if price = 0*/
              t-rate = inv-rent.rto-rate1.
              t-orig =
                myRent:GetRTOPrice(origvalue,t-rate,YES,OUTPUT t-usedrate).
            END.
            ELSE
            DO:   /* its new but rto record = 0 */
              RUN rnRtoNewPriceCalc.p(origvalue,v-trans.sku-no,
                OUTPUT t-orig, OUTPUT t-rate,
                OUTPUT cumInt, OUTPUT defaultMonths).
              t-orig = ROUND(t-orig,0).
            END.
        END.
        ELSE
        DO:  /* used with inv-rent record */
          IF inv-rent.rto-rate1 <> 0 THEN
          DO:  /* use current used-rate */
            t-rate = inv-rent.rto-rate1. /* tested RO031541 */
            RUN rnRtoUsedPriceCalc.p(origvalue,v-trans.sku-no,
              t-rate, OUTPUT t-orig, OUTPUT cumInt, OUTPUT defaultMonths).
            t-orig = ROUND(t-orig,0).
          END.
          ELSE
          DO: /* get a used rate NOT TESTED JAN20TH
            run rnRtoNewPriceCalc.p(origvalue,v-trans.sku-no,
              output t-orig, output t-rate,
              output cumInt, output defaultMonths). *******/
            t-rate = (origvalue * .0175)
              / (1 - exp((.0175 + 1),(v-trans.defaultMonths * -1))).
            RUN roundup(INPUT-OUTPUT t-rate).
            t-orig =
              myRent:GetRTOPrice(origvalue,t-rate,YES,OUTPUT t-usedrate).
          END.
        END.
      END.
      ELSE
      DO: /* pf8 chosen */
        IF v-trans.qty-new = 0 THEN
        DO: /* used item added */
          IF t-rate >= origvalue THEN
          DO:  /* avoid infinite loop */
            p-endkey = YES.
            t-rate = t-orig-rate.
            RETURN.
          END.
          IF v-trans.estat = "E" THEN
          DO:
            RUN rnRtoUsedPriceCalc.p(origvalue,v-trans.sku-no,
              t-rate, OUTPUT t-orig, OUTPUT cumInt, OUTPUT defaultMonths).
          END.
          ELSE
          DO:  /* t-rate is set so just use selling price and convert */
            /* tested f8 on RO031541 */
            RUN rnRtoUsedPriceCalc.p(origvalue,v-trans.sku-no,
              t-rate, OUTPUT t-orig, OUTPUT cumInt, OUTPUT defaultMonths).
          END.
        END.
        ELSE
        DO:  /* pf8 new item only reduce on value change */
          IF t-rate >= origvalue THEN
          DO:  /* avoid infinite loop */
            p-endkey = YES.
            t-rate = t-orig-rate.
            RETURN.
          END.
          DEFINE VARIABLE tcost  AS DECIMAL .
          DEFINE VARIABLE t-type AS CHARACTER NO-UNDO.
          RUN im/get-price.p
            (v-trans.sku-no,"",NO,OUTPUT tcost,OUTPUT t-type).
          IF tcost = origvalue AND t-rate = inv-rent.rent-to-own THEN ASSIGN
              t-orig = inv-rent.rto-price.
          ELSE IF v-trans.estat = "e" THEN
            DO:
              RUN rnRtoNewPriceCalc.p(origvalue,v-trans.sku-no,
                OUTPUT t-orig, OUTPUT t-rate,
                OUTPUT cumInt, OUTPUT defaultMonths).
              t-orig = ROUND(t-orig,0).
            /* t-orig =
            myRent:GetRTOPrice((origvalue),t-rate,yes,output t-usedrate).*/
            END.
            ELSE
            DO:  /* test case */
              RUN rnRtoUsedPriceCalc.p(origvalue,v-trans.sku-no,
                t-rate, OUTPUT t-orig, OUTPUT cumInt, OUTPUT defaultMonths).
              t-orig = ROUND(t-orig,0).
            END.
        END.
        IF t-orig = ? THEN
        DO: /* t-rate is too low or too high */
          p-endkey = YES.
          t-rate = t-orig-rate.
          MESSAGE "RTO PRICE CANNOT BE CALCULATED WITH THIS RATE "
            VIEW-AS ALERT-BOX.
          RETURN.
        END.
      END.
    END.
  IF AVAILABLE v-trans AND v-trans.estat = "e" THEN
  DO:   /* task 2360*/
    tMths = (t-orig - v-trans.extended) / t-rate.
    IF t-orig < v-trans.extended THEN
    DO: /*  2360 extension pf8 & exch */
      t-rate = t-orig-rate.
      MESSAGE
        "The amount paid for the old item exceeds the value of the" SKIP
        "New RTO ITEM. The new item value will be adjusted to match" SKIP
        "the old rent rate" VIEW-AS ALERT-BOX.
      v-trans.orig-value = v-trans.extended - t-orig-rate.
      RETURN.
    END.
  END.
  ELSE
    tMths = t-orig / t-rate.
  IF v-trans.estat = "e" THEN
  DO:
    /* higher price only */
    DEFINE VARIABLE txchorig AS DECIMAL.
    txchorig = t-orig - v-trans.extended.
    tmths = txchorig / t-rate.
  END.
  IF tMths > maxcap OR tMths = ? THEN
  DO:
    t-orig = origvalue.   /* rto-price puts it over 60 mths.     */
    IF t-rate = 0 OR t-rate = ? THEN t-rate = 1.
    RUN getT60Rate( maxCap,
      INPUT-OUTPUT tMths, INPUT-OUTPUT t-rate, INPUT-OUTPUT t-orig,
      OUTPUT p-endkey).
    IF NOT p-endkey THEN
    DO:
      ASSIGN
        t-rate   = t-orig-rate
        p-endkey = YES.
      RETURN.
    END.
  END.
  ASSIGN
    v-trans.orig-value  = t-orig
    v-trans.after-value = t-orig
    v-trans.rent-rate   = t-rate
    v-trans.over-retail = t-newvalue  /* the new orig value to calculated*/
    t-rto-tot           = (v-trans.orig-value * v-trans.qty) + v-trans.rent-credit
    /* t-rto-tot = v-trans.orig-value */
    t-rto-mth           = v-trans.orig-value / v-trans.rent-rate.
END PROCEDURE.

/* @(#) rnproc-getT60Rate.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getT60Rate.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getT60Rate:
  DEFINE INPUT PARAMETER maxcap AS INTEGER NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER pMths AS DECIMAL NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER t-60rate AS DECIMAL NO-UNDO.
  DEFINE INPUT-OUTPUT PARAMETER t-60prc AS DECIMAL NO-UNDO.
  DEFINE OUTPUT PARAMETER pEndkey AS LOG INIT YES NO-UNDO.
  /* assume cancel and return */

  DEFINE VARIABLE origvalue  AS DECIMAL NO-UNDO.
  DEFINE VARIABLE rateReply  AS LOG     NO-UNDO.
  DEFINE VARIABLE t-usedrate AS DECIMAL.
  DEFINE VARIABLE t-tempRate AS DECIMAL.

  IF pMths > maxcap THEN
  DO:
    DEFINE VARIABLE tempMths AS INTEGER.

    origvalue = t-60prc .
    t-tempRate = t-60rate + 1.

    tempMths = maxCap.   /* max allowed  */
    REPEAT:
      IF pMths <= maxCap THEN LEAVE.
      ASSIGN
        t-60prc = myRent:GetRTOPrice(origvalue,t-tempRate,YES,OUTPUT t-usedrate)
        pMths   = t-60prc / t-Temprate.

      IF pMths > maxCap OR pMths = ? THEN t-TEMPrate = t-TEMPrate + 1.

    END.
    t-60rate = t-tempRate.
    MESSAGE
      "The rate you have entered is invalid as it would result in a term" SKIP
      "longer than 60 months. The lowest rate you can have for this product is"
      SKIP t-60rate " per month." VIEW-AS ALERT-BOX
      QUESTION BUTTONS OK-CANCEL UPDATE rateReply.
    IF rateReply = ? THEN rateReply = NO.
    IF
      rateReply THEN
    DO:
      pendkey = NO.
    END.
  END.
END.

/* @(#) rnproc-rn-disc.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-rn-disc.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE rn-disc:
  DEFINE OUTPUT PARAMETER t-endkey AS LOG NO-UNDO.
  DEFINE VARIABLE p-rec      AS RECID     NO-UNDO.
  DEFINE VARIABLE t-second   AS LOG       NO-UNDO.
  DEFINE VARIABLE tempserial AS CHARACTER.
  tempserial =  v-trans.serial-no .
  IF v-trans.qty-new > 0 THEN
    v-trans.serial-no = "". /* this means the sku# is new */
  FIND cust-grp NO-LOCK
    WHERE cust-grp.cust-no = order.cust-no
    AND cust-grp.grp-no = 15 NO-ERROR.
  IF NOT AVAILABLE cust-grp THEN
  DO:
    IF NOT is-generic(v-trans.sku-no)  THEN
    DO:
      IF NOT v-trans.serial-no BEGINS "sku#" THEN
      DO:
        t-endkey = YES.
        p-rec = RECID(v-trans).
        DEFINE VARIABLE t-disc-cnt AS INTEGER NO-UNDO.
        FOR EACH v-trans:
          IF v-trans.disc-reason <> "" THEN
          DO:
            t-disc-reason = v-trans.disc-reason.
            t-discount-note = v-trans.discount-note.
            IF RECID(v-trans) <> p-rec THEN
            DO:
              t-disc-cnt = t-disc-cnt + 1.
            END.
          END.
        END.
        IF t-disc-cnt = 1 THEN ASSIGN tx-msg   = YES t-second = NO.
        IF tx-msg = NO THEN ASSIGN t-disc-reason   = "" t-discount-note = "".
        IF tx-msg = YES AND t-disc-cnt > 1 THEN t-second = YES.
        FIND v-trans WHERE RECID(v-trans) = p-rec.
        RUN rn-disc-reason.p(order.cust-no, v-trans.sku-no,
          v-trans.serial-no, "F8-RENT",INPUT-OUTPUT tx-msg, t-second,
          INPUT-OUTPUT t-discount-note,
          INPUT-OUTPUT t-disc-reason, OUTPUT t-endkey).
      END.
    END.
  END.
  oMsg:msg-refresh().
  v-trans.serial-no = tempserial.
  IF t-endkey = NO THEN
  DO:    /* continue on to orig-value box */
    v-trans.disc-reason = t-disc-reason.
    v-trans.discount-note = t-discount-note.
  END.
END.

/* @(#) rnproc-setup-tsale.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-setup-tsale.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE setup-tsale:
  IF AVAILABLE order THEN
  DO:
    FOR EACH sale OF order NO-LOCK WHERE NOT sale.void:
      CREATE tsale.
      BUFFER-COPY sale TO tsale.
      FOR EACH sale-i OF sale NO-LOCK WHERE NOT sale-i.void :
        CREATE tsalei.
        BUFFER-COPY sale-i TO tsalei.
      END.
    END.
  END.
END.

/* @(#) rnproc-getitem.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-getitem.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE getitem:
  /* when serial entered or left blank and f5 hit */

  DEFINE INPUT-OUTPUT PARAMETER pRec AS RECID NO-UNDO.
  DEFINE VARIABLE pSer LIKE inv-locsrl.serial-no NO-UNDO.
  pSer = v-trans.serial-no.
  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"save").
  oMsg:msg-hide().
  RUN testSourceProc.p(buffer inv-master, p-rent-code,
    INPUT-OUTPUT pSer, OUTPUT pRec).
  RUN save-frames.p(INPUT-OUTPUT t-frame-list,"restore").
  FIND inv-master NO-LOCK WHERE RECID(inv-master) = recm NO-ERROR.
  FIND FIRST vlocsrl WHERE RECID(vlocsrl) = pRec NO-ERROR.
  /* 9306 */
  IF AVAILABLE vlocsrl AND vlocsrl.demoitem = YES
    THEN
  DO:
    MESSAGE "Demo item will be changed into an used item." VIEW-AS ALERT-BOX.
  END. /* IF AVAILABLE inv-locslr*/
  IF AVAILABLE vlocsrl THEN
  DO:
    RUN bufCopyVlocsrl.
  END.
END.

/* @(#) rnproc-checkOtherContracts.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-checkOtherContracts.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE checkOtherContracts: /*rm get-contract funct; caller bufcopyvlocsrl*/
  DEFINE INPUT PARAMETER psku LIKE inv-locsrl.sku-no NO-UNDO.
  DEFINE INPUT PARAMETER pserial LIKE inv-locsrl.serial-no NO-UNDO.
  DEFINE OUTPUT PARAMETER txzendkey AS LOG NO-UNDO.
  DEFINE VARIABLE t-contract     LIKE order.order-no NO-UNDO.
  DEFINE VARIABLE t-contract-loc LIKE order.loc-code NO-UNDO.

  t-contract = chkContract(psku,pserial,OUTPUT t-contract-loc).
  IF is_exch AND order.rent-code = "school" AND MONTH(TODAY) = 5 THEN
  DO:
  END.
  ELSE
  DO:
    /* 6190# Change prompt when selling rented serial# */
    IF t-contract <> "":U THEN
    DO:
      MESSAGE
        SUBSTITUTE
        ("This Serial number is on rent on contract #&1 at location &2":T
        + ". Continuing may cause inventory issues.":T
        ,t-contract,t-contract-loc) SKIP(1)
        "Have you confirmed the accuracy of this serial number?":U
        VIEW-AS ALERT-BOX QUESTION BUTTON YES-NO UPDATE txzendkey.
      IF txzendkey = ? THEN txzendkey = NO.
    END.
  END.
END.

/* @(#) rnproc-bufCopyVlocsrl.i 1.7 03/06/23 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-bufCopyVlocsrl.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE bufCopyVlocsrl:
  DEFINE VARIABLE tz-endkey   AS LOG     NO-UNDO.
  DEFINE VARIABLE t-serial-no LIKE inv-locsrl.serial-no NO-UNDO.
  DEFINE VARIABLE t-dum-value AS DECIMAL NO-UNDO.
  DEFINE VARIABLE pInvRent    AS LOG     NO-UNDO.
  DEFINE VARIABLE pExists     AS LOG     NO-UNDO.
  DEFINE VARIABLE pBuy        AS LOG     NO-UNDO.

  FIND inv-master NO-LOCK
  WHERE inv-master.sku-no = vlocsrl.sku-no NO-ERROR.
  IF AVAILABLE inv-master THEN DO:
    /* Display any existing Rental Notes when adding a New In Stock item to a Rental */
    t-rental-notes = GetInvNotes(inv-master.sku-no, "rentals").

    IF t-rental-notes <> "" THEN
      MESSAGE t-rental-notes VIEW-AS ALERT-BOX INFORMATION.
    
    ASSIGN recm = RECID(inv-master).
  END.
  RUN checkOtherContracts(vlocsrl.sku-no, vlocsrl.serial-no, OUTPUT tz-endkey).
  IF tz-endkey THEN
  DO:
    DELETE vlocsrl.
    RETURN.
  END.

  /* PATCH JOB */
  IF t-dt-enter = ? THEN t-dt-enter = s-dt-return.

  DEFINE VARIABLE t-type AS CHARACTER NO-UNDO.
  IF is-generic(vlocsrl.sku-no) AND AVAILABLE vlocsrl THEN
  DO:
    ASSIGN
      v-trans.isGeneric   = YES
      v-trans.product-no  = vlocsrl.description
      vlocsrl.origvalue   = vlocsrl.over-retail /*remov testSourceProc.p*/
      v-trans.avg-cost    = vlocsrl.over-retail
      v-trans.over-retail = vlocsrl.over-retail.
  END.
  ELSE
    RUN im/get-price.p
      (inv-master.sku,"",YES,OUTPUT vlocsrl.origvalue,OUTPUT t-type).
  RUN im/get-cost.p(INPUT vlocsrl.sku-no, NO, OUTPUT vlocsrl.cost).
  vlocsrl.over-retail = vlocsrl.origvalue.
  BUFFER-COPY vlocsrl TO v-trans.
  ASSIGN
    vlocsrl.doc-ref       = order.order-no
    v-trans.qty           = 1
    v-trans.orig-value    = vlocsrl.origvalue
    v-trans.create-value  = v-trans.orig-value
    v-trans.before-value  = v-trans.orig-value
    v-trans.after-value   = v-trans.orig-value
    v-trans.avg-cost      = vlocsrl.origvalue
    v-trans.qty-new       = 1
    v-trans.old-item      = NO
    v-trans.serial-reqd   = inv-master.serial-reqd
    v-trans.never-used    = inv-master.never-used
    v-trans.defaultMonths = 36.
  t-old-value  = vlocsrl.origvalue.  /* for f8 keys */

  IF vlocsrl.description = "" THEN
    ASSIGN
      v-trans.product-no  = inv-master.product-no
      v-trans.description = inv-master.description.
  /* RTO'S */
  IF NOT is-generic(v-trans.sku-no) OR vlocsrl.description = "" THEN
    ASSIGN
      v-trans.description = inv-master.description
      v-trans.product-no  = inv-master.product-no.
  ELSE IF vlocsrl.description <> "" THEN
      v-trans.product-no = v-trans.description.

  RUN rentret(inv-master.sku-no).   /* 1st call in bufcopyvlocsrl */
  /* F7 MAY HAVE ALREADY SET THE FIELD */
  /* if sku49 and estat "p" then undo sets extended wrong */
  v-trans.amt-received = v-trans.extended.
  IF v-trans.estat = "P" THEN
  DO:
    /*2nd call bufvlocsrl */
    RUN rentret(v-trans.sku-no).  /* will bypass f7 = "p" without this */
    RUN buynewitem.  /* handles warranty */
    PAUSE 0 NO-MESSAGE. /* N.B */

  END.

  ELSE IF is_exch AND NOT t-funct-name = "r-own.create" THEN
    DO:
      IF v-trans.pInvRentExists THEN
      DO:
        /* BUG HERE as new item on exchange gets askagain */
        IF v-trans.rent-rate = 0 AND v-trans.rent-to-own > 0 THEN
          v-trans.rent-rate = v-trans.rent-to-own.
        RUN rentexch.
      END.
      RETURN.
    END.
  IF NOT t-funct-name = "r-own.create" THEN
  DO:
    RUN rentret(v-trans.sku-no). /* 3rd call bufcopyvlocsrl */
    IF NOT t-funct-name = "rental.create" THEN
      RUN regularrent(OUTPUT v-trans.extended).
  END.

  /******* SECTION FOR RTO'S *********************/
  IF t-funct-name = "r-own.create" THEN
  DO:
    RUN rnGetDefaultMths.p(inv-master.sku-no,
      OUTPUT v-trans.defaultMonths).
    IF AVAILABLE inv-master THEN
    DO:
      IF v-trans.sku-no <> 28 THEN
      DO:
        IF v-trans.sku-no = 39 OR v-trans.sku-no = 49 THEN
        DO:
          /*** tested for new item sku 39 and taskagain ***/
          ASSIGN
            t-serial-no = v-trans.serial-no
            t-dum-value = v-trans.avg-cost.
          RUN rto-cost(YES, OUTPUT tz-endkey, t-dum-value, t-serial-no,NO).
          RUN regularrent(OUTPUT v-trans.extended).
          IF is_exch THEN
          DO:
            RUN rentexch.
          END.
          ELSE IF v-trans.estat = "" THEN
            DO:
              RUN newwtrans.
              RUN tAskAgain(INPUT-OUTPUT t-ask-again).
            END.
            ELSE
              RUN newwtrans.
          RUN reopenquery.
          RETURN.
        END.  /* end of sku 39/49 */
        ELSE IF inv-master.serial-reqd = "N"
            OR (v-trans.isGeneric = YES) THEN
          DO:
            RUN getValidRtoAccessGroup.p(inv-master.group-no,OUTPUT pBuyOnly,
              OUTPUT pChoice).
            IF pChoice THEN
            DO:
              MESSAGE "Would customer like to add this product to the RTO contract?"         SKIP
                "Type Y to add this product to the RTO contract " SKIP
                "or Type N to purchase this product now."
                VIEW-AS ALERT-BOX QUESTION BUTTONS YES-NO UPDATE t-reply.
              IF t-reply = ? THEN t-reply = NO.
            END.
            IF t-reply = YES THEN
            DO:  /* add to contract */
              /* where to go */
              RETURN.
            END.
            FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
            ASSIGN
              v-trans.estat = "P"  /* will call buynewitem */
              buyrec        = RECID(v-trans).
            RUN buynewitem.
          END.
          ELSE
          DO:  /* serial required  */
            ASSIGN
              t-serial-no = v-trans.serial-no
              t-dum-value = v-trans.avg-cost.
            IF v-trans.pInvRentExists THEN
            DO:
              IF NOT is_exch THEN
              DO:
                ASSIGN   /* new record might be corrupt **/
                  v-trans.orig-value = ROUND(v-trans.rto-price,0)
                  v-trans.rent-rate  = v-trans.rent-to-own.
              END.
              /* both exchange and adds hit here */
              RUN rto-cost(YES, OUTPUT tz-endkey, t-dum-value, t-serial-no,NO).
              RUN regularrent(OUTPUT v-trans.extended).

            END.

            ELSE
            DO:  /* no inv-rent and not sku 39 or 49 ***/
              ASSIGN
                v-trans.estat = "P"  /* will call buynewitem */
                buyrec        = RECID(v-trans).
              RUN buynewitem.
            END.
            IF is_exch THEN
            DO:
              RUN rentexch.
            END.
            ELSE IF v-trans.estat = "" THEN
              DO:
                RUN newwtrans.
                RUN tAskAgain(INPUT-OUTPUT t-ask-again).
                RETURN.
              END.
              ELSE
                RUN newwtrans.
            RUN reopenquery.
            RETURN.
          END.
      END.
    END.
  END.      /* END OF NEW ITEM ON RTO */

  /********* SECTION FOR RENT PACKAGES **************/
  ELSE IF rentPackage(inv-master.sku-no) THEN
    DO:

      CREATE inv-locsrl.
      BUFFER-COPY vlocsrl TO inv-locsrl.
      IF NOT is-generic(inv-locsrl.sku-no) THEN
        inv-locsrl.over-retail = 0.
      IF AVAILABLE order THEN inv-locsrl.doc-ref = order.order-no.
      inv-locsrl.i-status = -1.
      DELETE vlocsrl.
      s-rec = RECID(inv-locsrl).
      FIND inv-locsrl NO-LOCK WHERE RECID(inv-locsrl) = s-rec NO-ERROR.
      is-unravel = NO.
      /* CALLS VERSION 1.19  */
      RUN rn-unravel.p(s-rec, recm, t-dt-enter, s-link-order,
        v-trans.orig-value, v-trans.rent-rate,
        INPUT-OUTPUT itemnum, OUTPUT is-unravel).
    END.
  IF order.rent-code = "school" OR order.rent-code = "billing" THEN
  DO:   /* blank and new error getitem*/
    RUN newwtrans.
    RUN tAskAgain(INPUT-OUTPUT t-ask-again).
  END.
  ELSE
    FIND v-trans WHERE v-trans.product-no = "" AND v-trans.sku-no = 0 NO-ERROR.
  IF NOT AVAILABLE v-trans THEN
    RUN newwtrans.
  RUN reopenquery.
END.

/* @(#) rnproc-tAskAgain.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-tAskAgain.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE tAskAgain:
  DEFINE INPUT-OUTPUT PARAMETER p-ask-again AS LOG NO-UNDO.
  DEFINE VARIABLE t-set-vsale AS LOG     NO-UNDO.
  DEFINE VARIABLE tprotrec    AS RECID   NO-UNDO.
  DEFINE VARIABLE tserProt    AS INTEGER NO-UNDO.
  DEFINE VARIABLE tAsk        AS INTEGER NO-UNDO.
  DEFINE VARIABLE t-days      AS INTEGER.
  DEFINE VARIABLE tyear       AS INTEGER.

  IF AVAILABLE v-trans THEN
    tprotrec = RECID(v-trans).
  FOR EACH v-trans:
    IF v-trans.sku-no = 28 THEN tAsk = tAsk + v-trans.qty.
    IF NOT v-trans.serial-no BEGINS "sku#" AND
      (v-trans.estat = "" OR v-trans.estat = "e")
      /*and v-trans.old-item = no */ THEN
      tserProt = tserProt + v-trans.qty.
  END.
  FIND v-trans WHERE RECID(v-trans) = tprotrec.
  IF tserProt > tAsk THEN
  DO:
    /* USED ITEM BEING ADDED */
    IF p-ask-again AND is_exch THEN RETURN.
    IF p-ask-again AND (order.order-no BEGINS "rs"
      OR order.order-no BEGINS "ro") THEN
    DO:
      RUN rs-insurance.p(buffer order,
        tSchCostShare,tSchCostShareValue,
        INPUT-OUTPUT v-trans.item-no, INPUT-OUTPUT v_rec,
        INPUT-OUTPUT t-ask-again, OUTPUT t-set-vsale).

      IF t-ask-again AND t-set-vsale = NO
        AND (order.rent-code = "school" OR order.rent-code = "billing") THEN
      DO:
        /* update a pre-existing sku 28 added on this transaction */
        FIND FIRST v-trans
          WHERE v-trans.sku-no = 28 AND v-trans.old-item = NO NO-ERROR.
        IF AVAILABLE  v-trans THEN
        DO: /* find pre-existing sku28 on contract */
          RUN rsSchoolProrate.p("school", v-trans.sku-no,
            v-trans.dt-rented, OUTPUT v-trans.percent). /* reset for costshare */
          IF TODAY >= date(06,30,YEAR(year-end))
            AND TODAY <= date(10,31,YEAR(year-end)) AND tyears = 1 THEN
            v-trans.percent = 1.
          ELSE IF tyears = 1 AND year-end = TODAY
              AND order.dt-due = TODAY THEN
              v-trans.percent = 0.
          IF tschCostShareValue > 0 AND tschCostShare THEN v-trans.percent = 1.
          IF tyears = 1 AND TODAY >= date(06,30,YEAR(year-end)) THEN
          DO:
            IF v-trans.old-item = NO
              AND (v-trans.sku-no = 28 OR v-trans.sku-no = 0) THEN
            DO:
              IF order.rent-code = "billing" THEN
              DO:
                RUN effectdays.p(TODAY, t-date-due, OUTPUT t-days).
                ASSIGN
                  v-trans.percent         = 1
                  v-trans.extended        = v-trans.rent-rate / 30 * t-days
                  v-trans.extended        = v-trans.extended * v-trans.qty
                  v-trans.extended        = ROUND(v-trans.extended,2)
                  v-trans.retail          = v-trans.extended
                  v-trans.est-repair-cost = 1.
              END.
              ELSE
                ASSIGN v-trans.extended        = 10 * v-trans.qty * 1
                  v-trans.est-repair-cost = 1.
            END.
          END.
          ELSE IF tyears > 1 THEN
            DO:
              tyear = YEAR(year-end).
              IF TODAY >= date(05,01,tyear) AND TODAY <= date(06,30,tyear)
                AND v-trans.old-item = NO
                AND (v-trans.sku-no = 28 OR v-trans.sku-no = 0)
                THEN
              DO:  /* its a fake v-trans it has no rent rate or sku */
                IF TODAY < date(06,01,tyear) THEN
                  v-trans.extended =
                    10 * v-trans.qty * 1.3.
                ELSE
                  v-trans.extended =
                    10 * v-trans.qty * 1.1.
                v-trans.retail = v-trans.extended.
              END.
              ELSE
              DO:
                ASSIGN
                  v-trans.extended        = (v-trans.rent-rate * v-trans.qty * v-trans.percent)
               + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 ))
                  v-trans.est-repair-cost = 1.

              END.
            END.
        END.
        FIND v-trans WHERE RECID(v-trans) = v_rec NO-ERROR.
        RETURN.
      END.
      /* when t-set-vsale = yes */
      IF ((order.rent-code = "school" OR order.rent-code = "billing")
        AND v-trans.old-item = NO)
        AND (v-trans.sku-no = 28 OR v-trans.sku-no = 0) THEN
      DO:
        v-trans.percent = 1.
        IF order.rent-code = "billing" THEN
        DO:
          RUN effectdays.p(TODAY, t-date-due, OUTPUT t-days).
          ASSIGN
            v-trans.percent         = 1
            v-trans.extended        = v-trans.rent-rate / 30 * t-days
            v-trans.extended        = v-trans.extended * v-trans.qty
            v-trans.extended        = ROUND(v-trans.extended,2)
            v-trans.retail          = v-trans.extended
            v-trans.est-repair-cost = 1.
        END.
        ELSE
        DO:
          RUN rsSchoolProrate.p(t-funct-name, v-trans.sku-no,
            v-trans.dt-rented, OUTPUT v-trans.percent).
          IF tacceptpass AND tSchCostShareValue <> 0 THEN v-trans.percent = 1.
          ELSE
            IF MONTH(v-trans.dt-rented) = 6 AND tyears = 0 THEN
              v-trans.percent = .1.
          IF TODAY >= date(06,30,YEAR(year-end))
            AND TODAY <= date(10,31,YEAR(year-end))
            AND tyears = 1 THEN v-trans.percent = 1.
          ELSE IF tyears = 1 AND year-end = TODAY
              AND order.dt-due = TODAY THEN
              v-trans.percent = 0.
          /* ON ADVANCE NO PRORATE FOR NEW ITEMS */
          IF year-end > order.dt-due AND v-trans.old-item THEN
            v-trans.percent = v-trans.percent + 1.
          /* THIS FAILS FOR 2014 TO 2016 */

          IF v-trans.old-item = NO THEN
          DO:
            IF tyears > 1 THEN
            DO:
              IF TODAY >= date(05,01,YEAR(year-end))
                AND TODAY <= date(06,30,YEAR(year-end))
                AND v-trans.old-item = NO
                AND v-trans.sku-no = 28
                THEN
              DO:  /* its a fake v-trans it has no rent rate or sku */
                IF v-trans.rent-rate = 0 THEN v-trans.rent-rate = 10.
                IF TODAY < date(06,01,YEAR(year-end)) THEN
                  v-trans.extended =
                    v-trans.rent-rate * v-trans.qty * 1.3.
                ELSE
                  v-trans.extended =
                    v-trans.rent-rate * v-trans.qty * 1.1.
                v-trans.retail = v-trans.extended.
              END.
              ELSE
                v-trans.extended = (v-trans.rent-rate * v-trans.qty * v-trans.percent)
                  + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 )).
              v-trans.est-repair-cost = 1.
            END.
            ELSE IF tyears = 1 THEN
              DO:
                IF  year-end = TODAY AND order.dt-due = TODAY THEN
                  v-trans.percent = 0.
                v-trans.extended = (v-trans.rent-rate * v-trans.percent)
                  * v-trans.qty * tyears.
                v-trans.est-repair-cost = 1.
              END.
          END.
          IF v-trans.old-item THEN
          DO:   /* no work may 12 */
            IF tYears > 1 THEN
            DO:  /* only add the new year. */
              v-trans.extended = v-trans.extended
                /* + (v-trans.rent-rate * v-trans.qty * v-trans.percent) */
                + ((v-trans.rent-rate * v-trans.qty) * (tYears - 1 )).
            END.
            ELSE IF tyears = 1 THEN
                v-trans.extended = (v-trans.rent-rate)
                  * v-trans.qty * tyears.
            v-trans.est-repair-cost = 1.
          END.
          v-trans.retail = v-trans.extended.
        /* all of the above is useless on adding a quantity  */
        END.
      END.
      IF t-set-vsale THEN
      DO:
        IF AVAILABLE v-trans AND t-ask-again AND v-trans.serial-no = "" THEN
        DO:
          v-trans.serial-no = "sku#00000028".
        END.
        IF t-ask-again AND
          (order.order-no BEGINS "rs" OR order.order-no BEGINS "ro")
          THEN
        DO:
          RUN newwtrans.
        END.
      END.
    END.
  END.
END.

/* @(#) rnproc-equipfailure.i 1.2 07/19/22 @(#) */
/*------------------------------------------------------------------------------
  File:  rn-newp2/rnproc-equipfailure.i

  Syntax:
    Not called directly.  Included from rn-newp2.p
  Input Parameters:
    <none>
  Output Parameters:
    <none>
  Input-Output Parameters:
    <none>
  History:
    RJ - 07/18/2022
       Fractured rn-newp2.p into multiple includes in an attempt to reduce code
       blocking.  The desire is to allow more than one developer to work
       within the rn-newp2.p code base.  This was an entirely mechanical
       process that separated functions, procedures and triggers into
       individual files.  All code remains included in their original sequence
       and all newly created files are contained within a single folder
       under:
          rn-newp2/rndefines-*.i
          rn-newp2/rnfunc-*.i
          rn-newp2/rnproc-*.i
          rn-newp2/rntrig-*.i

------------------------------------------------------------------------------*/

PROCEDURE equipfailure:
  DEFINE VARIABLE llogical      AS LOGICAL NO-UNDO.
  DEFINE VARIABLE lequipfailure AS LOGICAL NO-UNDO.
  DEFINE VARIABLE icount        AS INTEGER NO-UNDO.

  FOR EACH sale NO-LOCK
    WHERE sale.cust-no = order.cust-no
    AND sale.sale-type = "rn"
    BY sale.dt-trans DESCENDING
    BY sale.tm-trans DESCENDING :
    icount = icount + 1.
    IF icount >3 THEN RETURN NO-APPLY.

    FOR EACH sale-i OF sale NO-LOCK,
      EACH  discount NO-LOCK
      WHERE discount.disc-no = int(sale-i.disc-reason):
      IF AVAILABLE discount AND sale-i.disc-reason = "42" THEN llogical = YES.
      IF llogical AND NOT lequipfailure THEN
      DO:
        MESSAGE
          "This customer had a " + '"equip failure"' + " discount recently." SKIP
          "Please thoroughly test and demonstrate equipment." VIEW-AS ALERT-BOX.
        lequipfailure = YES.
      END.
    END. /* for each sale-i */
  END. /* for each sale */
END PROCEDURE.

//  ALL DONE!!